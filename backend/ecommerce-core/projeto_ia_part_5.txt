
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/ConfigBootstrap.java ---
package com.atelie.ecommerce.api.config;

import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class ConfigBootstrap implements ApplicationRunner {

    private final DynamicConfigService dynamicConfigService;

    public ConfigBootstrap(DynamicConfigService dynamicConfigService) {
        this.dynamicConfigService = dynamicConfigService;
    }

    @Override
    public void run(ApplicationArguments args) {
        // Cache inicial do motor dinâmico
        dynamicConfigService.refresh();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/StaticResourceConfig.java ---
package com.atelie.ecommerce.api.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.nio.file.Path;
import java.nio.file.Paths;

@Configuration
public class StaticResourceConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        Path uploadDir = Paths.get("./uploads");
        String uploadPath = uploadDir.toFile().getAbsolutePath();
        registry.addResourceHandler("/uploads/**").addResourceLocations("file:" + uploadPath + "/");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/exception/MissingConfigException.java ---
package com.atelie.ecommerce.api.config.exception;

public class MissingConfigException extends RuntimeException {
    public MissingConfigException(String key) {
        super("Config obrigatória ausente no banco: " + key);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/DynamicConfigService.java ---
package com.atelie.ecommerce.api.config;

import com.atelie.ecommerce.api.config.exception.MissingConfigException;
import com.atelie.ecommerce.domain.config.SystemConfig;
import com.atelie.ecommerce.domain.config.SystemConfigGateway;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.time.Clock;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class DynamicConfigService {

    private static final Logger log = LoggerFactory.getLogger(DynamicConfigService.class);
    public static final String CACHE_TTL_SECONDS_KEY = "CACHE_TTL_SECONDS";
    private static final long DEFAULT_CACHE_TTL_SECONDS = 300;

    private final SystemConfigGateway gateway;
    private final Clock clock;
    
    // Cache final e thread-safe
    private final Map<String, String> cache = new ConcurrentHashMap<>();
    
    // Volatile para garantir visibilidade
    private volatile LocalDateTime lastUpdate = LocalDateTime.MIN;

    public DynamicConfigService(SystemConfigGateway gateway, Clock clock) {
        this.gateway = gateway;
        this.clock = clock;
    }

    // Método sincronizado para evitar múltiplas queries ao banco simultaneamente
    public synchronized void refresh() {
        log.info("DynamicConfigService: Recarregando configurações...");
        cache.clear();
        for (SystemConfig c : gateway.findAll()) {
            if (c != null && c.key() != null) {
                cache.put(c.key(), c.value());
            }
        }
        lastUpdate = LocalDateTime.now(clock);
        log.info("DynamicConfigService: cache atualizado. Total chaves={}", cache.size());
    }

    private void checkCacheExpiration() {
        if (isCacheExpired()) {
            synchronized (this) {
                if (isCacheExpired()) { // Double check
                    refresh();
                }
            }
        }
    }

    private boolean isCacheExpired() {
        if (lastUpdate.equals(LocalDateTime.MIN)) return true;
        long ttlSeconds = getLongInternal(CACHE_TTL_SECONDS_KEY, DEFAULT_CACHE_TTL_SECONDS);
        return LocalDateTime.now(clock).isAfter(lastUpdate.plusSeconds(ttlSeconds));
    }

    // Helper interno que não dispara refresh recursivo
    private long getLongInternal(String key, long defaultValue) {
        String val = cache.get(key);
        if (val == null) return defaultValue;
        try { return Long.parseLong(val); } catch (Exception e) { return defaultValue; }
    }

    // Métodos públicos
    public boolean containsKey(String key) {
        checkCacheExpiration();
        return cache.containsKey(key);
    }

    public String getString(String key) {
        checkCacheExpiration();
        return cache.get(key);
    }

    public String requireString(String key) {
        String value = getString(key);
        if (value == null) throw new MissingConfigException(key);
        return value;
    }

    public BigDecimal requireBigDecimal(String key) {
        String v = requireString(key);
        try { return new BigDecimal(v.trim()); } 
        catch (Exception e) { throw new IllegalStateException("Config inválida (BigDecimal) para " + key); }
    }

    public long getLong(String key, long defaultValue) {
        String v = getString(key);
        if (v == null) return defaultValue;
        try { return Long.parseLong(v.trim()); } 
        catch (Exception e) { throw new IllegalStateException("Config inválida (long) para " + key); }
    }

    public boolean requireBoolean(String key) {
        String v = getString(key);
        if (v == null) throw new MissingConfigException(key);
        return Boolean.parseBoolean(v.trim());
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/OrderResponse.java ---
package com.atelie.ecommerce.api.order.dto;

import com.atelie.ecommerce.domain.order.OrderStatus;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

public record OrderResponse(
    UUID id,
    OrderStatus status,
    String source,
    String externalId,
    String customerName,
    BigDecimal totalAmount,
    LocalDateTime createdAt,
    List<OrderItemResponse> items
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/OrderItemResponse.java ---
package com.atelie.ecommerce.api.order.dto;

import java.math.BigDecimal;
import java.util.UUID;

public record OrderItemResponse(
    UUID productId,
    String productName,
    Integer quantity,
    BigDecimal unitPrice,
    BigDecimal totalPrice
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/CreateOrderRequest.java ---
package com.atelie.ecommerce.api.order.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank; // Importante!
import jakarta.validation.constraints.NotEmpty;
import java.util.List;

public record CreateOrderRequest(
    @NotBlank(message = "Source é obrigatório") 
    String source,
    
    @NotBlank(message = "External ID é obrigatório") 
    String externalId,
    
    @NotBlank(message = "Nome do cliente é obrigatório") 
    String customerName,
    
    @NotEmpty(message = "Lista de itens não pode ser vazia") 
    @Valid 
    List<CreateOrderItemRequest> items
) {}
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/CreateOrderItemRequest.java ---
package com.atelie.ecommerce.api.order.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import java.util.UUID;

public record CreateOrderItemRequest(
    @NotNull UUID productId,
    UUID variantId, // Novo campo opcional (se produto tiver variação, é obrigatório na lógica)
    @NotNull @Min(1) Integer quantity
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/OrderController.java ---
package com.atelie.ecommerce.api.order;

import com.atelie.ecommerce.api.order.dto.CreateOrderRequest;
import com.atelie.ecommerce.api.order.dto.OrderResponse;
import com.atelie.ecommerce.api.order.dto.OrderItemResponse;
import com.atelie.ecommerce.application.service.order.OrderService;
import com.atelie.ecommerce.domain.order.OrderStatus;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderEntity;
import jakarta.validation.Valid;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private final OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @PostMapping
    public ResponseEntity<OrderResponse> createOrder(@Valid @RequestBody CreateOrderRequest request) {
        OrderEntity created = orderService.createOrder(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(toResponse(created));
    }

    @GetMapping
    public Page<OrderResponse> getAllOrders(
            @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable
    ) {
        return orderService.getAllOrders(pageable).map(this::toResponse);
    }

    // Mapper Simples
    private OrderResponse toResponse(OrderEntity entity) {
        var items = entity.getItems().stream()
                .map(i -> new OrderItemResponse(
                        i.getProduct().getId(),
                        i.getProduct().getName(),
                        i.getQuantity(),
                        i.getUnitPrice(),
                        i.getTotalPrice()
                )).collect(Collectors.toList());

        return new OrderResponse(
                entity.getId(),
                OrderStatus.valueOf(entity.getStatus()),
                entity.getSource(),
                entity.getExternalId(),
                entity.getCustomerName(),
                entity.getTotalAmount(),
                entity.getCreatedAt().atZone(java.time.ZoneId.of("UTC")).toLocalDateTime(),
                items
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/payment/dto/PaymentResponse.java ---
package com.atelie.ecommerce.api.payment.dto;

import java.math.BigDecimal;
import java.util.Map;

public record PaymentResponse(
    String status,
    String provider,
    BigDecimal amount,
    boolean sandbox,
    Map<String, Object> metadata
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/dto/DashboardSummary.java ---
package com.atelie.ecommerce.api.dashboard.dto;

import java.math.BigDecimal;

public record DashboardSummary(
    BigDecimal totalSales,
    long pendingOrders,
    long lowStockAlerts
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/ProductManagementController.java ---
package com.atelie.ecommerce.api.dashboard;

import com.atelie.ecommerce.api.catalog.product.dto.ProductResponse;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/dashboard/products")
public class ProductManagementController {

    private final ProductRepository productRepository;

    public ProductManagementController(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @GetMapping
    public List<ProductResponse> listAll() {
        // Converte Entity para DTO antes de retornar
        return productRepository.findAll().stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    // Simplificado para Dashboard (admin vê tudo)
    private ProductResponse toResponse(ProductEntity entity) {
        var response = new ProductResponse(
                entity.getId(),
                entity.getName(),
                entity.getDescription(),
                entity.getPrice(),
                entity.getCategoryId(),
                entity.getActive()
        );
        response.setImageUrl(entity.getImageUrl());
        return response;
    }

    @PutMapping("/{id}/toggle-alert")
    public ResponseEntity<ProductResponse> toggleAlert(@PathVariable UUID id) {
        ProductEntity product = productRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Produto não encontrado"));
        product.setAlertEnabled(!Boolean.TRUE.equals(product.getAlertEnabled()));
        ProductEntity saved = productRepository.save(product);
        return ResponseEntity.ok(toResponse(saved));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/DashboardController.java ---
package com.atelie.ecommerce.api.dashboard;

import com.atelie.ecommerce.api.dashboard.dto.DashboardSummary;
import com.atelie.ecommerce.application.service.integration.N8nService;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderRepository;
import com.atelie.ecommerce.infrastructure.persistence.inventory.InventoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigRepository;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigEntity;
import com.atelie.ecommerce.api.config.DynamicConfigService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.math.BigDecimal;
import java.util.Map;

@RestController
@RequestMapping("/api/dashboard")
public class DashboardController {

    private final OrderRepository orderRepository;
    private final InventoryRepository inventoryRepository;
    private final N8nService n8nService;
    private final SystemConfigRepository configRepository;
    private final DynamicConfigService dynamicConfigService;

    public DashboardController(OrderRepository orderRepository, 
                               InventoryRepository inventoryRepository,
                               N8nService n8nService,
                               SystemConfigRepository configRepository,
                               DynamicConfigService dynamicConfigService) {
        this.orderRepository = orderRepository;
        this.inventoryRepository = inventoryRepository;
        this.n8nService = n8nService;
        this.configRepository = configRepository;
        this.dynamicConfigService = dynamicConfigService;
    }

    @GetMapping("/summary")
    public ResponseEntity<DashboardSummary> getSummary() {
        var totalSales = orderRepository.totalSalesPaid();
        if (totalSales == null) totalSales = BigDecimal.ZERO;
        
        long pending = orderRepository.countPendingOrders();
        long lowStock = inventoryRepository.countLowStockProducts(10); 

        return ResponseEntity.ok(new DashboardSummary(totalSales, pending, lowStock));
    }

    @GetMapping("/automation/status")
    public ResponseEntity<Map<String, Boolean>> getAutomationStatus() {
        return ResponseEntity.ok(Map.of("enabled", n8nService.isAutomationEnabled()));
    }

    @PostMapping("/automation/toggle")
    public ResponseEntity<Map<String, String>> toggleAutomation(@RequestBody Map<String, Boolean> body) {
        boolean enable = Boolean.TRUE.equals(body.get("enabled"));
        
        // Persiste a configuração no banco
        SystemConfigEntity config = new SystemConfigEntity();
        config.setConfigKey("N8N_Automation_Enabled");
        config.setConfigValue(String.valueOf(enable));
        configRepository.save(config);
        
        // Atualiza cache em memória
        dynamicConfigService.refresh();

        String status = enable ? "ATIVADA" : "DESATIVADA";
        return ResponseEntity.ok(Map.of("message", "Automação n8n " + status));
    }

    @PostMapping("/automation/test-trigger")
    public ResponseEntity<String> testTrigger() {
        n8nService.sendLowStockAlert("PRODUTO TESTE DASHBOARD", 5, 10);
        return ResponseEntity.ok("Disparo de teste enviado (Verifique os logs ou o n8n)");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminOrderController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.application.service.order.OrderService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;
import java.util.Map;

@RestController
@RequestMapping("/api/admin/orders")
public class AdminOrderController {

    private final OrderService orderService;

    public AdminOrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @PostMapping("/{id}/cancel")
    public ResponseEntity<Void> cancel(@PathVariable UUID id, @RequestBody(required = false) Map<String, String> body) {
        String reason = (body != null && body.containsKey("reason")) ? body.get("reason") : "Admin request";
        orderService.cancelOrder(id, reason);
        return ResponseEntity.ok().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminFeatureFlagController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.infrastructure.persistence.feature.FeatureFlagEntity;
import com.atelie.ecommerce.infrastructure.persistence.feature.FeatureFlagRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/features")
public class AdminFeatureFlagController {

    private final FeatureFlagRepository repository;

    public AdminFeatureFlagController(FeatureFlagRepository repository) {
        this.repository = repository;
    }

    @GetMapping
    public List<FeatureFlagEntity> list() {
        return repository.findAll();
    }

    @PostMapping
    public FeatureFlagEntity createOrUpdate(@RequestBody FeatureFlagEntity dto) {
        return repository.findByFlagKey(dto.getFlagKey())
                .map(existing -> {
                    existing.setEnabled(dto.isEnabled());
                    existing.setValueJson(dto.getValueJson());
                    return repository.save(existing);
                })
                .orElseGet(() -> repository.save(dto));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminCacheController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/admin/cache")
public class AdminCacheController {

    private final DynamicConfigService dynamicConfigService;
    private final ServiceProviderGateway providerGateway;
    private final ServiceRoutingRuleGateway routingRuleGateway;
    private final ServiceProviderConfigGateway providerConfigGateway;

    public AdminCacheController(
            DynamicConfigService dynamicConfigService,
            ServiceProviderGateway providerGateway,
            ServiceRoutingRuleGateway routingRuleGateway,
            ServiceProviderConfigGateway providerConfigGateway
    ) {
        this.dynamicConfigService = dynamicConfigService;
        this.providerGateway = providerGateway;
        this.routingRuleGateway = routingRuleGateway;
        this.providerConfigGateway = providerConfigGateway;
    }

    @PostMapping("/refresh")
    public ResponseEntity<Map<String, Object>> refreshAll() {
        dynamicConfigService.refresh();
        providerGateway.refresh();
        routingRuleGateway.refresh();
        providerConfigGateway.refresh();

        return ResponseEntity.ok(Map.of(
                "ok", true,
                "message", "Caches refreshed: dynamic-config + service-engine gateways"
        ));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminConfigController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigEntity;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/configs")
public class AdminConfigController {

    private final SystemConfigRepository repository;
    private final DynamicConfigService configService;

    public AdminConfigController(SystemConfigRepository repository, DynamicConfigService configService) {
        this.repository = repository;
        this.configService = configService;
    }

    @GetMapping
    public List<SystemConfigEntity> listAll() {
        return repository.findAll();
    }

    @PostMapping
    public ResponseEntity<SystemConfigEntity> upsert(@RequestBody SystemConfigEntity dto) {
        SystemConfigEntity saved = repository.save(dto);
        // Atualiza o cache local imediatamente para refletir a mudança
        configService.refresh();
        return ResponseEntity.ok(saved);
    }

    @DeleteMapping("/{key}")
    public ResponseEntity<Void> delete(@PathVariable String key) {
        repository.deleteById(key);
        configService.refresh();
        return ResponseEntity.noContent().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminRuleController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceRoutingRuleJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceRoutingRuleEntity;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/admin/rules")
public class AdminRuleController {

    private final ServiceRoutingRuleJpaRepository repository;
    private final ServiceRoutingRuleGateway gateway; // Injeta para refresh
    private final ExpressionParser parser = new SpelExpressionParser();
    private final ObjectMapper mapper = new ObjectMapper();

    public AdminRuleController(ServiceRoutingRuleJpaRepository repository, ServiceRoutingRuleGateway gateway) {
        this.repository = repository;
        this.gateway = gateway;
    }

    @GetMapping
    public List<ServiceRoutingRuleEntity> list(@RequestParam(required = false) String type) {
        if (type != null) {
            return repository.findByServiceTypeAndEnabledOrderByPriorityAsc(type, true);
        }
        return repository.findAll();
    }

    @PostMapping
    public ResponseEntity<?> create(@RequestBody ServiceRoutingRuleEntity entity) {
        try { validateSpel(entity.getMatchJson()); } 
        catch (IllegalArgumentException e) { return ResponseEntity.badRequest().body("Regra Inválida: " + e.getMessage()); }

        if (entity.getId() == null) entity.setId(UUID.randomUUID());
        entity.setUpdatedAt(LocalDateTime.now());
        
        ServiceRoutingRuleEntity saved = repository.save(entity);
        gateway.refresh(); // Limpa cache
        return ResponseEntity.ok(saved);
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> update(@PathVariable UUID id, @RequestBody ServiceRoutingRuleEntity entity) {
        if (!repository.existsById(id)) return ResponseEntity.notFound().build();
        try { validateSpel(entity.getMatchJson()); } 
        catch (IllegalArgumentException e) { return ResponseEntity.badRequest().body("Regra Inválida: " + e.getMessage()); }

        entity.setId(id);
        entity.setUpdatedAt(LocalDateTime.now());
        
        ServiceRoutingRuleEntity saved = repository.save(entity);
        gateway.refresh(); // Limpa cache
        return ResponseEntity.ok(saved);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable UUID id) {
        repository.deleteById(id);
        gateway.refresh(); // Limpa cache
        return ResponseEntity.noContent().build();
    }

    private void validateSpel(String json) {
        try {
            if (json == null || json.isBlank()) return;
            JsonNode root = mapper.readTree(json);
            if (root.hasNonNull("expression")) {
                String expr = root.get("expression").asText();
                parser.parseExpression(expr);
            }
        } catch (Exception e) {
            throw new IllegalArgumentException("Erro de Sintaxe SpEL ou JSON: " + e.getMessage());
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminProviderConfigController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderConfigJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceProviderConfigEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api/admin/provider-configs")
public class AdminProviderConfigController {

    private final ServiceProviderConfigJpaRepository repository;
    private final ServiceProviderConfigGateway gateway; // Injeta o gateway para limpar cache

    public AdminProviderConfigController(ServiceProviderConfigJpaRepository repository,
                                         ServiceProviderConfigGateway gateway) {
        this.repository = repository;
        this.gateway = gateway;
    }

    @GetMapping("/{providerId}/{env}")
    public ResponseEntity<ServiceProviderConfigEntity> get(@PathVariable UUID providerId, @PathVariable String env) {
        return repository.findTopByProviderIdAndEnvironmentOrderByVersionDesc(providerId, env)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<ServiceProviderConfigEntity> upsert(@RequestBody ServiceProviderConfigEntity config) {
        if (config.getId() == null) config.setId(UUID.randomUUID());
        
        Optional<ServiceProviderConfigEntity> current = repository
            .findTopByProviderIdAndEnvironmentOrderByVersionDesc(config.getProviderId(), config.getEnvironment());
            
        config.setVersion(current.map(c -> c.getVersion() + 1).orElse(1));
        config.setUpdatedAt(LocalDateTime.now());
        
        ServiceProviderConfigEntity saved = repository.save(config);
        
        // --- LIMPEZA DE CACHE IMEDIATA ---
        gateway.refresh();
        
        return ResponseEntity.ok(saved);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminProviderController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceProviderEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/admin/providers")
public class AdminProviderController {

    private final ServiceProviderJpaRepository repository;
    private final ServiceProviderGateway gateway; // Injeta o gateway para chamar o refresh

    public AdminProviderController(ServiceProviderJpaRepository repository, ServiceProviderGateway gateway) {
        this.repository = repository;
        this.gateway = gateway;
    }

    @GetMapping
    public List<ServiceProviderEntity> list() {
        return repository.findAll();
    }

    @PostMapping
    public ResponseEntity<ServiceProviderEntity> create(@RequestBody ServiceProviderEntity entity) {
        if (entity.getId() == null) entity.setId(UUID.randomUUID());
        entity.setCreatedAt(LocalDateTime.now());
        entity.setUpdatedAt(LocalDateTime.now());
        
        ServiceProviderEntity saved = repository.save(entity);
        gateway.refresh(); // Limpa cache
        return ResponseEntity.ok(saved);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ServiceProviderEntity> update(@PathVariable UUID id, @RequestBody ServiceProviderEntity dto) {
        return repository.findById(id)
            .map(existing -> {
                existing.setName(dto.getName());
                existing.setServiceType(dto.getServiceType());
                existing.setCode(dto.getCode());
                existing.setPriority(dto.getPriority());
                existing.setDriverKey(dto.getDriverKey());
                existing.setHealthEnabled(dto.isHealthEnabled());
                existing.setEnabled(dto.isEnabled());
                existing.setUpdatedAt(LocalDateTime.now());
                
                ServiceProviderEntity saved = repository.save(existing);
                gateway.refresh(); // Limpa cache
                return ResponseEntity.ok(saved);
            })
            .orElse(ResponseEntity.notFound().build());
    }

    @PatchMapping("/{id}/toggle")
    public ResponseEntity<ServiceProviderEntity> toggle(@PathVariable UUID id, @RequestBody Boolean enabled) {
        return repository.findById(id)
                .map(provider -> {
                    provider.setEnabled(enabled);
                    provider.setUpdatedAt(LocalDateTime.now());
                    
                    ServiceProviderEntity saved = repository.save(provider);
                    gateway.refresh(); // Limpa cache
                    return ResponseEntity.ok(saved);
                })
                .orElse(ResponseEntity.notFound().build());
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/common/error/GlobalExceptionHandler.java ---
package com.atelie.ecommerce.api.common.error;

import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.api.common.exception.UnauthorizedException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@lombok.extern.slf4j.Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidation(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage()));
        return ResponseEntity.badRequest().body(errors);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<String> handleDbConflict(DataIntegrityViolationException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body("Conflito de dados: Recurso duplicado ou restrição violada.");
    }

    // --- NOVOS HANDLERS ESPECÍFICOS ---

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgument(IllegalArgumentException ex) {
        // Retorna 400 Bad Request para erros de validação de lógica (ex: estoque negativo)
        return ResponseEntity.badRequest().body(ex.getMessage());
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<String> handleIllegalState(IllegalStateException ex) {
        // Retorna 409 Conflict ou 422 para estados inválidos (ex: cancelar pedido já enviado)
        return ResponseEntity.status(HttpStatus.CONFLICT).body(ex.getMessage());
    }

    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<String> handleNotFound(NotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }

    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<String> handleCustomConflict(ConflictException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body(ex.getMessage());
    }
    
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<String> handleUnauthorized(UnauthorizedException ex) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(ex.getMessage());
    }

    // ----------------------------------

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<String> handleRuntime(RuntimeException ex) {
        log.error("Erro não tratado capturado: ", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Erro interno do servidor. Contate o suporte.");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/common/error/ErrorResponse.java ---
package com.atelie.ecommerce.api.common.error;

import com.fasterxml.jackson.annotation.JsonInclude;

import java.time.OffsetDateTime;
import java.util.Map;

/**
 * ErrorResponse.
 *
 * Modelo padrão de resposta de erro da API.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {

    private final OffsetDateTime timestamp;
    private final int status;
    private final String error;
    private final String message;
    private final String path;
    private final Map<String, String> fields;

    /**
     * Constrói um ErrorResponse.
     *
     * @param status  status HTTP numérico
     * @param error   nome curto do erro (ex: "Bad Request")
     * @param message mensagem humana do erro
     * @param path    caminho da requisição
     * @param fields  mapa de erros por campo (opcional)
     */
    public ErrorResponse(int status, String error, String message, String path, Map<String, String> fields) {
        this.timestamp = OffsetDateTime.now();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.fields = fields;
    }

    /**
     * Cria resposta 400 (Bad Request) opcionalmente com erros por campo.
     *
     * @param message mensagem humana
     * @param path    rota solicitada
     * @param fields  erros por campo (pode ser null)
     * @return ErrorResponse 400
     */
    public static ErrorResponse badRequest(String message, String path, Map<String, String> fields) {
        return new ErrorResponse(400, "Bad Request", message, path, fields);
    }

    /**
     * Cria resposta 401 (Unauthorized).
     *
     * @param message mensagem humana
     * @param path    rota solicitada
     * @return ErrorResponse 401
     */
    public static ErrorResponse unauthorized(String message, String path) {
        return new ErrorResponse(401, "Unauthorized", message, path, null);
    }

    /**
     * Cria resposta 404 (Not Found).
     *
     * @param message mensagem humana
     * @param path    rota solicitada
     * @return ErrorResponse 404
     */
    public static ErrorResponse notFound(String message, String path) {
        return new ErrorResponse(404, "Not Found", message, path, null);
    }

    /**
     * Cria resposta 405 (Method Not Allowed).
     *
     * @param message mensagem humana
     * @param path    rota solicitada
     * @return ErrorResponse 405
     */
    public static ErrorResponse methodNotAllowed(String message, String path) {
        return new ErrorResponse(405, "Method Not Allowed", message, path, null);
    }

    /**
     * Cria resposta 409 (Conflict).
     *
     * @param message mensagem humana
     * @param path    rota solicitada
     * @return ErrorResponse 409
     */
    public static ErrorResponse conflict(String message, String path) {
        return new ErrorResponse(409, "Conflict", message, path, null);
    }

    /**
     * Cria resposta 500 (Internal Server Error).
     *
     * @param message mensagem humana
     * @param path    rota solicitada
     * @return ErrorResponse 500
     */
    public static ErrorResponse internalServerError(String message, String path) {
        return new ErrorResponse(500, "Internal Server Error", message, path, null);
    }

    public OffsetDateTime getTimestamp() {
        return timestamp;
    }

    public int getStatus() {
        return status;
    }

    public String getError() {
        return error;
    }

    public String getMessage() {
        return message;
    }

    public String getPath() {
        return path;
    }

    public Map<String, String> getFields() {
        return fields;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/common/exception/UnauthorizedException.java ---
package com.atelie.ecommerce.api.common.exception;

/**
 * UnauthorizedException.
 *
 * Use para cenários de autenticação/autorização inválida.
 */
public class UnauthorizedException extends RuntimeException {

    public UnauthorizedException(String message) {
        super(message);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/common/exception/NotFoundException.java ---
package com.atelie.ecommerce.api.common.exception;

/**
 * NotFoundException.
 *
 * Use para cenários de recurso não encontrado (ex: categoria inexistente).
 */
public class NotFoundException extends RuntimeException {

    public NotFoundException(String message) {
        super(message);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/common/exception/ConflictException.java ---
package com.atelie.ecommerce.api.common.exception;

/**
 * ConflictException.
 *
 * Use para cenários de conflito (ex: e-mail já cadastrado).
 */
public class ConflictException extends RuntimeException {

    public ConflictException(String message) {
        super(message);
    }
}

--- ARQUIVO: ./src/test/resources/application-test.yml ---
spring:
  main:
    allow-bean-definition-overriding: true
  datasource:
    url: jdbc:h2:mem:ecommerce_test;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    hibernate:
      ddl-auto: validate
    open-in-view: false
    properties:
      hibernate:
        format_sql: true
  flyway:
    enabled: true
    locations: classpath:db/migration

logging:
  level:
    root: WARN
    org.springframework: WARN
    org.hibernate.SQL: WARN

server:
  port: 0

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/ControllerTest.java ---
package com.atelie.ecommerce;

import com.atelie.ecommerce.infrastructure.security.SecurityConfig;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;
import org.springframework.context.annotation.Import;
import org.springframework.core.annotation.AliasFor;

import java.lang.annotation.*;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@WebMvcTest
@Import(TestMocksConfig.class)
public @interface ControllerTest {
    @AliasFor(annotation = WebMvcTest.class, attribute = "controllers")
    Class<?>[] controllers() default {};

    @AliasFor(annotation = WebMvcTest.class, attribute = "excludeFilters")
    ComponentScan.Filter[] excludeFilters() default {
        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = SecurityConfig.class)
    };
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/application/service/health/HealthServiceTest.java ---
package com.atelie.ecommerce.application.service.health;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * TESTES (DDT/TDD) - HealthService
 *
 * Contrato:
 * - getStatus() deve retornar exatamente "OK"
 * - não deve retornar null
 * - chamadas repetidas devem retornar o mesmo resultado (idempotente)
 *
 * Nota DDT:
 * - Este teste falhará na compilação enquanto o HealthService não existir.
 * - Isso é esperado nesta fase (teste antes da implementação).
 */
class HealthServiceTest {

    @Test
    void shouldReturnOkStatus() {
        HealthService service = new HealthService();
        String status = service.getStatus();

        assertNotNull(status);
        assertEquals("OK", status);
    }

    @Test
    void shouldReturnSameStatusWhenCalledManyTimes() {
        HealthService service = new HealthService();

        String first = service.getStatus();
        String second = service.getStatus();
        String third = service.getStatus();

        assertEquals("OK", first);
        assertEquals(first, second);
        assertEquals(second, third);
    }

    @Test
    void shouldNotThrowWhenGettingStatus() {
        HealthService service = new HealthService();

        assertDoesNotThrow(service::getStatus);
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/application/service/catalog/category/CategoryServiceTest.java ---
package com.atelie.ecommerce.application.service.catalog.category;

import com.atelie.ecommerce.api.catalog.category.dto.CategoryResponse;
import com.atelie.ecommerce.api.catalog.category.dto.CreateCategoryRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryEntity;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CategoryServiceTest {

    @Mock
    private CategoryRepository repository;

    @InjectMocks
    private CategoryService service;

    @Test
    void shouldCreateCategoryAndReturnResponse() {
        CreateCategoryRequest req = new CreateCategoryRequest();
        req.setName("Guias Espirituais");
        req.setActive(true);

        when(repository.findAll()).thenReturn(List.of());

        CategoryResponse res = service.create(req);

        assertNotNull(res);
        assertNotNull(res.getId());
        assertEquals("Guias Espirituais", res.getName());
        assertEquals(true, res.getActive());

        ArgumentCaptor<CategoryEntity> captor = ArgumentCaptor.forClass(CategoryEntity.class);
        verify(repository, times(1)).save(captor.capture());

        CategoryEntity saved = captor.getValue();
        assertNotNull(saved.getId());
        assertEquals("Guias Espirituais", saved.getName());
        assertEquals(true, saved.getActive());
    }

    @Test
    void shouldThrowConflictWhenCategoryAlreadyExistsIgnoringCase() {
        CreateCategoryRequest req = new CreateCategoryRequest();
        req.setName("velas");
        req.setActive(true);

        CategoryEntity existing = new CategoryEntity();
        existing.setId(UUID.randomUUID());
        existing.setName("Velas");
        existing.setActive(true);

        when(repository.findAll()).thenReturn(List.of(existing));

        assertThrows(ConflictException.class, () -> service.create(req));
        verify(repository, never()).save(any());
    }

    @Test
    void shouldCreateEvenWhenExistingIsDifferentName() {
        CreateCategoryRequest req = new CreateCategoryRequest();
        req.setName("Defumadores");
        req.setActive(false);

        CategoryEntity existing = new CategoryEntity();
        existing.setId(UUID.randomUUID());
        existing.setName("Velas");
        existing.setActive(true);

        when(repository.findAll()).thenReturn(List.of(existing));

        CategoryResponse res = service.create(req);

        assertNotNull(res.getId());
        assertEquals("Defumadores", res.getName());
        assertEquals(false, res.getActive());

        verify(repository, times(1)).save(any(CategoryEntity.class));
    }
}
