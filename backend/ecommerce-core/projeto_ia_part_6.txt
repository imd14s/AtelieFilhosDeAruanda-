
--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/application/service/order/OrderServiceTest.java ---
package com.atelie.ecommerce.application.service.order;

import com.atelie.ecommerce.infrastructure.persistence.order.OrderEntity;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository;
import com.atelie.ecommerce.application.service.inventory.InventoryService;
import com.atelie.ecommerce.domain.order.OrderStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.atelie.ecommerce.api.order.dto.CreateOrderRequest;
import com.atelie.ecommerce.api.order.dto.CreateOrderItemRequest;
import com.atelie.ecommerce.domain.inventory.MovementType;
import java.math.BigDecimal;
import java.util.List;

import java.util.ArrayList;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

class OrderServiceTest {

    @Mock
    private OrderRepository orderRepository;
    @Mock
    private ProductRepository productRepository;
    @Mock
    private ProductVariantRepository variantRepository;
    @Mock
    private InventoryService inventoryService;

    @InjectMocks
    private OrderService orderService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testCancelOrder() {
        UUID orderId = UUID.randomUUID();
        OrderEntity order = new OrderEntity();
        order.setId(orderId);
        order.setStatus(OrderStatus.PENDING.name());
        // Correção: Inicializa a lista de itens para evitar NullPointerException [cite:
        // 331]
        order.setItems(new ArrayList<>());

        when(orderRepository.findById(orderId)).thenReturn(Optional.of(order));
        when(orderRepository.save(any(OrderEntity.class))).thenReturn(order);

        orderService.cancelOrder(orderId, "Teste de cancelamento");

        verify(orderRepository, times(1)).save(any(OrderEntity.class));
    }

    @Test
    void shouldCreateOrderSuccessfully_WithVariantStockDown() {
        // CENÁRIO
        UUID productId = UUID.randomUUID();
        UUID variantId = UUID.randomUUID();
        
        // Produto Mock
        ProductEntity product = new ProductEntity();
        product.setId(productId);
        product.setPrice(new BigDecimal("100.00"));
        product.setActive(true);
        product.setName("Produto Teste");

        // Variante Mock
        ProductVariantEntity variant = new ProductVariantEntity();
        variant.setId(variantId);
        variant.setPrice(new BigDecimal("100.00")); // Preço da variante
        variant.setProduct(product);
        variant.setStockQuantity(10);

        // Request
        CreateOrderItemRequest itemReq = new CreateOrderItemRequest(productId, variantId, 2);
        CreateOrderRequest request = new CreateOrderRequest(
            "WEB", 
            "EXT-123", 
            "Cliente Teste", 
            List.of(itemReq)
        );

        // MOCKS
        when(productRepository.findById(productId)).thenReturn(Optional.of(product));
        when(variantRepository.findById(variantId)).thenReturn(Optional.of(variant));
        // O save deve retornar o objeto que foi passado (ou um novo com ID)
        when(orderRepository.save(any(OrderEntity.class))).thenAnswer(invocation -> {
            OrderEntity order = invocation.getArgument(0);
            if(order.getId() == null) order.setId(UUID.randomUUID()); // Simula geração de ID
            return order;
        });

        // EXECUÇÃO
        OrderEntity createdOrder = orderService.createOrder(request);

        // VALIDAÇÕES (Asserts)
        assertNotNull(createdOrder);
        assertEquals("PENDING", createdOrder.getStatus());
        // 2 itens * 100.00 = 200.00
        assertEquals(new BigDecimal("200.00"), createdOrder.getTotalAmount());

        // Verifica se baixou estoque corretamente (Critical Path)
        verify(inventoryService, times(1)).addMovement(
            eq(variantId), 
            eq(MovementType.OUT), 
            eq(2), 
            contains("Sale Order"), 
            anyString()
        );
        
        // Verifica persistência
        verify(orderRepository, times(1)).save(any(OrderEntity.class));
    }
    
    @Test
    void shouldThrowException_WhenProductInactive() {
        UUID productId = UUID.randomUUID();
        ProductEntity product = new ProductEntity();
        product.setId(productId);
        product.setActive(false); // Inativo

        CreateOrderItemRequest itemReq = new CreateOrderItemRequest(productId, null, 1);
        CreateOrderRequest request = new CreateOrderRequest("WEB", "123", "User", List.of(itemReq));

        when(productRepository.findById(productId)).thenReturn(Optional.of(product));

        assertThrows(IllegalStateException.class, () -> orderService.createOrder(request));
        verify(orderRepository, never()).save(any());
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/application/service/payment/PaymentServiceTest.java ---
package com.atelie.ecommerce.application.service.payment;

import com.atelie.ecommerce.api.serviceengine.ServiceOrchestrator;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.math.BigDecimal;
import java.util.UUID;

class PaymentServiceTest {

    // Mockamos a dependência complexa
    private final ServiceOrchestrator orchestrator = Mockito.mock(ServiceOrchestrator.class);
    
    // Injetamos no construtor correto
    private final PaymentService paymentService = new PaymentService(orchestrator);

    @Test
    void shouldValidateAmount() {
        RuntimeException exception = Assertions.assertThrows(RuntimeException.class, () -> {
            paymentService.createPixPayment(UUID.randomUUID(), "test@test.com", "12345678900", BigDecimal.ZERO);
        });
        Assertions.assertEquals("Valor do pagamento deve ser maior que zero", exception.getMessage());
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/application/inventory/InventoryServiceTest.java ---
package com.atelie.ecommerce.application.inventory;

import com.atelie.ecommerce.domain.inventory.MovementType;
import com.atelie.ecommerce.domain.inventory.event.InventoryChangedEvent;
import com.atelie.ecommerce.infrastructure.persistence.inventory.InventoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.inventory.entity.InventoryMovementEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository;
import com.atelie.ecommerce.application.inventory.InventoryService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.ApplicationEventPublisher;

import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class InventoryServiceTest {

    @Mock private InventoryRepository inventoryRepository;
    @Mock private ProductVariantRepository variantRepository;
    @Mock private ApplicationEventPublisher eventPublisher;

    @InjectMocks private InventoryService inventoryService;

    @Test
    void shouldDecrementStock_WhenBalanceIsSufficient() {
        UUID variantId = UUID.randomUUID();
        ProductVariantEntity variant = new ProductVariantEntity();
        variant.setId(variantId);
        variant.setSku("SKU-TEST");
        variant.setStockQuantity(10);
        variant.setProduct(new ProductEntity()); // Necessário para o evento

        when(variantRepository.findById(variantId)).thenReturn(Optional.of(variant));
        // Simula update bem sucedido (1 linha afetada)
        when(variantRepository.decrementStock(variantId, 5)).thenReturn(1);

        inventoryService.addMovement(variantId, MovementType.OUT, 5, "Venda", "REF-1");

        // Deve salvar histórico
        verify(inventoryRepository).save(any(InventoryMovementEntity.class));
        // Deve publicar evento
        verify(eventPublisher).publishEvent(any(InventoryChangedEvent.class));
    }

    @Test
    void shouldThrow_WhenStockInsufficient() {
        UUID variantId = UUID.randomUUID();
        ProductVariantEntity variant = new ProductVariantEntity();
        variant.setId(variantId);
        variant.setSku("SKU-TEST");

        when(variantRepository.findById(variantId)).thenReturn(Optional.of(variant));
        // Simula falha no update (0 linhas afetadas por causa do WHERE quantity >= X)
        when(variantRepository.decrementStock(variantId, 100)).thenReturn(0);

        assertThrows(IllegalArgumentException.class, () -> 
            inventoryService.addMovement(variantId, MovementType.OUT, 100, "Venda", "REF-1")
        );
        
        // Não deve salvar movimento se falhou
        verify(inventoryRepository, never()).save(any());
    }
}
--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/config/TestProfileConfig.java ---
package com.atelie.ecommerce.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.test.context.ActiveProfiles;

@Configuration
@ActiveProfiles("test")
public class TestProfileConfig {
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/config/TestApplication.java ---
package com.atelie.ecommerce.config;

import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = "com.atelie.ecommerce")
public class TestApplication {
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/TestMocksConfig.java ---
package com.atelie.ecommerce;

import com.atelie.ecommerce.infrastructure.persistence.order.OrderRepository;
import com.atelie.ecommerce.infrastructure.persistence.inventory.InventoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigRepository;
import com.atelie.ecommerce.application.service.integration.N8nService;
import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.infrastructure.security.JwtAuthenticationFilter;
import com.atelie.ecommerce.infrastructure.security.TokenProvider;
import org.mockito.Mockito;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@TestConfiguration
@EnableWebSecurity
public class TestMocksConfig {

    @Bean
    @Primary
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(AbstractHttpConfigurer::disable)
            .authorizeHttpRequests(auth -> auth.anyRequest().permitAll());
        return http.build();
    }

    @Bean @Primary public AuthenticationManager authenticationManager() { return Mockito.mock(AuthenticationManager.class); }
    // JwtService removido daqui pois a classe foi deletada
    @Bean @Primary public PasswordEncoder passwordEncoder() { return Mockito.mock(PasswordEncoder.class); }
    @Bean @Primary public TokenProvider tokenProvider() { return Mockito.mock(TokenProvider.class); }
    @Bean @Primary public JwtAuthenticationFilter jwtAuthenticationFilter() { return Mockito.mock(JwtAuthenticationFilter.class); }

    @Bean @Primary public OrderRepository orderRepository() { return Mockito.mock(OrderRepository.class); }
    @Bean @Primary public InventoryRepository inventoryRepository() { return Mockito.mock(InventoryRepository.class); }
    @Bean @Primary public SystemConfigRepository systemConfigRepository() { return Mockito.mock(SystemConfigRepository.class); }
    @Bean @Primary public N8nService n8nService() { return Mockito.mock(N8nService.class); }
    @Bean @Primary public DynamicConfigService dynamicConfigService() { return Mockito.mock(DynamicConfigService.class); }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/infrastructure/service/JpaServiceProviderGatewayCacheTest.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceProviderEntity;
import org.junit.jupiter.api.Test;

import java.time.*;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class JpaServiceProviderGatewayCacheTest {

    @Test
    void shouldUseCacheWithinTtlAndReloadAfterTtl() {
        ServiceProviderJpaRepository repo = mock(ServiceProviderJpaRepository.class);
        DynamicConfigService cfg = mock(DynamicConfigService.class);

        // TTL de 2s
        when(cfg.getLong(eq(DynamicConfigService.CACHE_TTL_SECONDS_KEY), anyLong())).thenReturn(2L);

        ServiceProviderEntity e = new ServiceProviderEntity();
        e.setId(UUID.randomUUID());
        e.setServiceType("SHIPPING");
        e.setCode("J3");
        e.setName("J3");
        e.setEnabled(true);
        e.setPriority(1);
        e.setDriverKey("j3");
        e.setHealthEnabled(true);

        when(repo.findByServiceTypeAndEnabledOrderByPriorityAsc("SHIPPING", true))
                .thenReturn(List.of(e));

        Instant base = Instant.parse("2026-01-01T00:00:00Z");
        Clock fixed = Clock.fixed(base, ZoneOffset.UTC);

        JpaServiceProviderGateway gw = new JpaServiceProviderGateway(repo, cfg, fixed);

        // 1) Primeira chamada: bate no repo
        gw.findEnabledByTypeOrdered(ServiceType.SHIPPING);
        // 2) Segunda chamada (mesmo clock): deve vir do cache
        gw.findEnabledByTypeOrdered(ServiceType.SHIPPING);

        verify(repo, times(1))
                .findByServiceTypeAndEnabledOrderByPriorityAsc("SHIPPING", true);

        // 3) Avança o tempo além do TTL (3s) e chama de novo => reload
        Clock after = Clock.fixed(base.plusSeconds(3), ZoneOffset.UTC);
        JpaServiceProviderGateway gw2 = new JpaServiceProviderGateway(repo, cfg, after);

        gw2.refresh(); // simula o mesmo bean tendo avançado o tempo no mundo real
        gw2.findEnabledByTypeOrdered(ServiceType.SHIPPING);

        verify(repo, times(2))
                .findByServiceTypeAndEnabledOrderByPriorityAsc("SHIPPING", true);
    }

    @Test
    void shouldCacheFindByCode() {
        ServiceProviderJpaRepository repo = mock(ServiceProviderJpaRepository.class);
        DynamicConfigService cfg = mock(DynamicConfigService.class);
        when(cfg.getLong(eq(DynamicConfigService.CACHE_TTL_SECONDS_KEY), anyLong())).thenReturn(300L);

        ServiceProviderEntity e = new ServiceProviderEntity();
        e.setId(UUID.randomUUID());
        e.setServiceType("SHIPPING");
        e.setCode("J3");
        e.setName("J3");
        e.setEnabled(true);
        e.setPriority(1);
        e.setDriverKey("j3");
        e.setHealthEnabled(true);

        when(repo.findByCode("J3")).thenReturn(Optional.of(e));

        Clock clock = Clock.fixed(Instant.parse("2026-01-01T00:00:00Z"), ZoneOffset.UTC);
        JpaServiceProviderGateway gw = new JpaServiceProviderGateway(repo, cfg, clock);

        gw.findByCode(ServiceType.SHIPPING, "J3");
        gw.findByCode(ServiceType.SHIPPING, "J3");

        verify(repo, times(1)).findByCode("J3");
        assertEquals("J3", gw.findByCode(ServiceType.SHIPPING, "J3").orElseThrow().code());
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/testsupport/SystemConfigTestHelper.java ---
package com.atelie.ecommerce.testsupport;

import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigEntity;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigRepository;

public final class SystemConfigTestHelper {

    private SystemConfigTestHelper() {}

    public static void upsert(SystemConfigRepository repo, String key, String value) {
        SystemConfigEntity c = repo.findById(key).orElseGet(SystemConfigEntity::new);
        c.setConfigKey(key);
        c.setConfigValue(value);
        repo.save(c);
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/ControllerTestBase.java ---
package com.atelie.ecommerce;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;

// Importa a nossa fábrica de mocks
@AutoConfigureMockMvc(addFilters = false)
@Import(TestMocksConfig.class)
public abstract class ControllerTestBase {

    @Autowired
    protected MockMvc mockMvc;

    @Autowired
    protected ObjectMapper objectMapper;
    
    // Não precisamos declarar @MockBean aqui, pois o TestInfraConfig já injetou tudo.
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/domain/service/engine/DefaultServiceEngineTest.java ---
package com.atelie.ecommerce.domain.service.engine;

import com.atelie.ecommerce.domain.provider.RuleMatcher;
import com.atelie.ecommerce.domain.service.model.ServiceProvider;
import com.atelie.ecommerce.domain.service.model.ServiceRoutingRule;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

class DefaultServiceEngineTest {

    // Instância real do RuleMatcher (lógica pura, sem mock necessário)
    private final RuleMatcher ruleMatcher = new RuleMatcher();

    @Test
    void shouldPickHighestPriorityEnabledProvider_whenNoRulesMatch() {
        // providers: J3 prio=10, CORREIOS prio=20 (menor = mais prioritário)
        ServiceProvider j3 = new ServiceProvider(UUID.randomUUID(), ServiceType.SHIPPING, "J3", "J3", true, 10, "shipping.j3", true);
        ServiceProvider correios = new ServiceProvider(UUID.randomUUID(), ServiceType.SHIPPING, "CORREIOS", "Correios", true, 20, "shipping.correios", true);

        ServiceProviderGateway providerGateway = new InMemoryProviderGateway(List.of(j3, correios));
        ServiceRoutingRuleGateway ruleGateway = new InMemoryRuleGateway(List.of()); // sem regras

        // CORREÇÃO: Passando ruleMatcher (3º argumento)
        DefaultServiceEngine engine = new DefaultServiceEngine(providerGateway, ruleGateway, ruleMatcher);
        ServiceContext ctx = new ServiceContext("BR", BigDecimal.valueOf(100), Map.of());

        ResolvedProvider resolved = engine.resolve(ServiceType.SHIPPING, ctx);

        assertEquals("J3", resolved.provider().code());
        assertTrue(resolved.reason().toLowerCase().contains("default") || resolved.reason().toLowerCase().contains("priority"));
    }

    @Test
    void shouldPickProviderByRuleMatch_whenRuleIsEnabledAndMatches() {
        ServiceProvider j3 = new ServiceProvider(UUID.randomUUID(), ServiceType.SHIPPING, "J3", "J3", true, 10, "shipping.j3", true);
        ServiceProvider correios = new ServiceProvider(UUID.randomUUID(), ServiceType.SHIPPING, "CORREIOS", "Correios", true, 20, "shipping.correios", true);
        
        // regra manda usar CORREIOS quando country=BR
        ServiceRoutingRule rule = new ServiceRoutingRule(
                UUID.randomUUID(),
                ServiceType.SHIPPING,
                "CORREIOS",
                true,
                1,
                "{\"country\":\"BR\"}",
                "{}"
        );

        ServiceProviderGateway providerGateway = new InMemoryProviderGateway(List.of(j3, correios));
        ServiceRoutingRuleGateway ruleGateway = new InMemoryRuleGateway(List.of(rule));

        // CORREÇÃO: Passando ruleMatcher (3º argumento)
        DefaultServiceEngine engine = new DefaultServiceEngine(providerGateway, ruleGateway, ruleMatcher);
        ServiceContext ctx = new ServiceContext("BR", BigDecimal.valueOf(100), Map.of());

        ResolvedProvider resolved = engine.resolve(ServiceType.SHIPPING, ctx);

        assertEquals("CORREIOS", resolved.provider().code());
        assertTrue(resolved.reason().toLowerCase().contains("rule"));
    }

    @Test
    void shouldThrow_whenNoEnabledProvidersExist() {
        ServiceProviderGateway providerGateway = new InMemoryProviderGateway(List.of());
        // nenhum provider
        ServiceRoutingRuleGateway ruleGateway = new InMemoryRuleGateway(List.of());
        
        // CORREÇÃO: Passando ruleMatcher (3º argumento)
        DefaultServiceEngine engine = new DefaultServiceEngine(providerGateway, ruleGateway, ruleMatcher);

        ServiceContext ctx = new ServiceContext("BR", BigDecimal.valueOf(100), Map.of());

        assertThrows(IllegalStateException.class, () -> engine.resolve(ServiceType.SHIPPING, ctx));
    }

    // ===== fakes in-memory =====

    static class InMemoryProviderGateway implements ServiceProviderGateway {
        private final List<ServiceProvider> data;
        InMemoryProviderGateway(List<ServiceProvider> data) { this.data = data; }

        @Override
        public void refresh() {}

        @Override
        public List<ServiceProvider> findEnabledByTypeOrdered(ServiceType type) {
            return data.stream()
                    .filter(p -> p.serviceType() == type)
                    .filter(ServiceProvider::enabled)
                    .sorted(Comparator.comparingInt(ServiceProvider::priority))
                    .toList();
        }

        @Override
        public Optional<ServiceProvider> findByCode(ServiceType type, String code) {
            return data.stream()
                    .filter(p -> p.serviceType() == type)
                    .filter(p -> p.code().equalsIgnoreCase(code))
                    .findFirst();
        }
    }

    static class InMemoryRuleGateway implements ServiceRoutingRuleGateway {
        private final List<ServiceRoutingRule> data;
        InMemoryRuleGateway(List<ServiceRoutingRule> data) { this.data = data; }
        
        @Override
        public void refresh() {}

        @Override
        public List<ServiceRoutingRule> findEnabledByTypeOrdered(ServiceType type) {
            return data.stream()
                    .filter(r -> r.serviceType() == type)
                    .filter(ServiceRoutingRule::enabled)
                    .sorted(Comparator.comparingInt(ServiceRoutingRule::priority))
                    .toList();
        }
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/domain/provider/RuleMatcherTest.java ---
package com.atelie.ecommerce.domain.provider;

import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

class RuleMatcherTest {

    private final RuleMatcher matcher = new RuleMatcher();

    @Test
    void shouldMatchSpelExpression_whenExpressionIsTrue() {
        RouteContext ctx = new RouteContext("BR", "01001-000", BigDecimal.valueOf(100), Map.of());

        String ruleJson = """
                {"expression":"country == 'BR'"}
                """;

        RuleMatch result = matcher.matches(ctx, ruleJson);

        assertTrue(result.matched());
        assertEquals("spel_matched", result.reason());
    }

    @Test
    void shouldNotMatchSpelExpression_whenExpressionIsFalse() {
        RouteContext ctx = new RouteContext("BR", "01001-000", BigDecimal.valueOf(100), Map.of());

        String ruleJson = """
                {"expression":"country == 'US'"}
                """;

        RuleMatch result = matcher.matches(ctx, ruleJson);

        assertFalse(result.matched());
        assertEquals("spel_mismatch", result.reason());
    }

    @Test
    void shouldMatchLegacyCountryRule_whenCountryMatches() {
        RouteContext ctx = new RouteContext("BR", "01001-000", BigDecimal.valueOf(100), Map.of());

        String ruleJson = """
                {"country":"BR"}
                """;

        RuleMatch result = matcher.matches(ctx, ruleJson);

        assertTrue(result.matched());
        assertEquals("legacy_matched", result.reason());
    }

    @Test
    void shouldNotMatchLegacyRules_whenCepPrefixOrMinTotalMismatch() {
        RouteContext ctx = new RouteContext("BR", "99999-000", BigDecimal.valueOf(50), Map.of());

        // cep_prefix não bate (espera começar com 010 ou 011) e min_total exige >= 100
        String ruleJson = """
                {"country":"BR","cep_prefix":["010","011"],"min_total":100}
                """;

        RuleMatch result = matcher.matches(ctx, ruleJson);

        assertFalse(result.matched());
        // pode falhar primeiro por cep_prefix ou por min_total — ambos são válidos
        assertTrue(
                result.reason().equals("cep_prefix_mismatch") || result.reason().equals("min_total_mismatch"),
                "reason inesperado: " + result.reason()
        );
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/api/auth/dto/AuthDtoValidationTest.java ---
package com.atelie.ecommerce.api.auth.dto;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

class AuthDtoValidationTest {

    private static ValidatorFactory factory;
    private static Validator validator;

    @BeforeAll
    static void setUp() {
        factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @AfterAll
    static void tearDown() {
        factory.close();
    }

    private RegisterRequest buildRegister(String name, String email, String password) {
        RegisterRequest r = new RegisterRequest();
        r.setName(name);
        r.setEmail(email);
        r.setPassword(password);
        return r;
    }

    @Test
    void shouldValidateRegisterRequest_whenValid() {
        RegisterRequest req = buildRegister("User", "user@email.com", "123456");
        Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(req);
        assertTrue(violations.isEmpty());
    }

    @Test
    void shouldFailValidation_whenNameIsBlank() {
        RegisterRequest req = buildRegister("", "user@email.com", "123456");
        Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(req);
        assertFalse(violations.isEmpty());
    }

    @Test
    void shouldFailValidation_whenEmailIsInvalid() {
        RegisterRequest req = buildRegister("User", "invalid", "123456");
        Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(req);
        assertFalse(violations.isEmpty());
    }

    @Test
    void shouldFailValidation_whenPasswordIsBlank() {
        RegisterRequest req = buildRegister("User", "user@email.com", "");
        Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(req);
        assertFalse(violations.isEmpty());
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/api/auth/dto/AuthResponseDtoTest.java ---
package com.atelie.ecommerce.api.auth.dto;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class AuthResponseDtoTest {
    @Test
    void shouldCreateLoginResponse() {
        LoginResponse response = new LoginResponse("token-123", "User Test", "test@test.com");
        
        Assertions.assertEquals("token-123", response.getToken());
        Assertions.assertEquals("User Test", response.getName());
        Assertions.assertEquals("test@test.com", response.getEmail());
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/api/common/error/ErrorResponseTest.java ---
package com.atelie.ecommerce.api.common.error;

import org.junit.jupiter.api.Test;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * ErrorResponseTest.
 */
class ErrorResponseTest {

    @Test
    void shouldExposeAllFields() {
        ErrorResponse response = new ErrorResponse(
                404,
                "Not Found",
                "Route not found",
                "/x",
                null
        );

        assertEquals(404, response.getStatus());
        assertEquals("Not Found", response.getError());
        assertEquals("Route not found", response.getMessage());
        assertEquals("/x", response.getPath());
        assertNotNull(response.getTimestamp());
    }

    @Test
    void shouldAllowNullFieldsInSkeletonPhase() {
        ErrorResponse response = ErrorResponse.badRequest("Validation error", "/x", null);

        assertEquals(400, response.getStatus());
        assertNotNull(response.getTimestamp());
        assertNull(response.getFields());
    }

    @Test
    void shouldAcceptFieldsMapWhenProvided() {
        ErrorResponse response = ErrorResponse.badRequest("Validation error", "/x", Map.of("email", "must not be blank"));

        assertEquals(400, response.getStatus());
        assertEquals("must not be blank", response.getFields().get("email"));
    }
}
