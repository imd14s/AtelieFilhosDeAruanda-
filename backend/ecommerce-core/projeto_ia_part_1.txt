
--- ARQUIVO: ./Dockerfile ---
FROM maven:3.9.6-eclipse-temurin-21-alpine AS builder
WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn clean package -DskipTests

FROM eclipse-temurin:21-jre-alpine
WORKDIR /app

# Cria grupo e usuário não-root
RUN addgroup -S spring && adduser -S spring -G spring

# Cria pasta de uploads e ajusta permissões
RUN mkdir -p /app/uploads && chown -R spring:spring /app

COPY --from=builder /build/target/ecommerce-core-0.0.1-SNAPSHOT.jar app.jar

# Troca para o usuário seguro
USER spring

VOLUME /app/uploads
EXPOSE 8080
ENTRYPOINT ["java", "-Duser.timezone=UTC", "-jar", "app.jar"]

--- ARQUIVO: ./.dockerignore ---
target
.git
.gitignore
node_modules
*.log
.env

--- ARQUIVO: ./.env.local_backup ---
# Configurações do Banco de Dados
DB_NAME=ecommerce_db
DB_USER=postgres
DB_PASSWORD=senha_ultra_secreta_de_producao_123

# Configurações do App
APP_PORT=8080
JWT_SECRET=5367566B59703373367639792F423F4528482B4D6251655468576D5A71347437
JWT_EXPIRATION_MS=86400000
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:4200

# ... (suas configurações anteriores)

# Integração n8n
N8N_WEBHOOK_URL=https://n8n.seu-dominio.com/webhook/alerta-estoque

# Integração Mercado Pago
MP_ACCESS_TOKEN=APP_USR-SEU_TOKEN_AQUI_COLE_ELE
MP_WEBHOOK_SECRET= (Deixe em branco por enquanto, só teremos isso depois de configurar o webhook)

# --- Banco de Dados (PostgreSQL) ---
SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/atelie_db
SPRING_DATASOURCE_USERNAME=postgres
SPRING_DATASOURCE_PASSWORD=postgres

# --- Integrações (Opcionais para Local) ---
# Se não tiver token real agora, mantenha "dummy" para os drivers mockados funcionarem
MP_ACCESS_TOKEN=dummy_access_token
N8N_WEBHOOK_URL=http://localhost:5678/webhook/test
--- ARQUIVO: ./.env.example ---
# --- TEMPLATE DE CONFIGURAÇÃO (NÃO COLOQUE SENHAS REAIS AQUI) ---
DB_NAME=ecommerce_db
DB_USER=postgres
DB_PASSWORD=change_me_in_production
APP_PORT=8080

# Gere uma nova chave: openssl rand -hex 32
JWT_SECRET=change_me_min_32_bytes_hex_string
JWT_EXPIRATION_MS=86400000

# Segurança
CORS_ALLOWED_ORIGINS=http://localhost:3000
WEBHOOK_SECRET=change_me_strong_secret

# Integrações
SPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/ecommerce

--- ARQUIVO: ./.gitignore ---
# Java / Maven
/target/
*.class
*.log
*.jar
*.war
*.ear
*.iml

# Coverage / Reports
*.exec
*.html
/jacoco.exec

# IDEs
.idea/
.vscode/

# OS
.DS_Store

# Env
.env
.env.*

--- ARQUIVO: ./pom.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.2.1</version>
    <relativePath />
  </parent>

  <groupId>com.atelie</groupId>
  <artifactId>ecommerce-core</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>Ateliê Filhos de Aruanda - Backend</name>
  <description>Core E-commerce API</description>

  <properties>
    <java.version>21</java.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
      <version>2.3.0</version>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <scope>runtime</scope>
    </dependency>

    <dependency>
      <groupId>org.flywaydb</groupId>
      <artifactId>flyway-core</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
    </dependency>

    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-api</artifactId>
      <version>0.11.5</version>
    </dependency>
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-impl</artifactId>
      <version>0.11.5</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-jackson</artifactId>
      <version>0.11.5</version>
      <scope>runtime</scope>
    </dependency>

    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
        <configuration>
          <source>21</source>
          <target>21</target>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
      <plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.12</version>
    <executions>
      <execution>
        <id>prepare-agent</id>
        <goals>
          <goal>prepare-agent</goal>
        </goals>
      </execution>
      <execution>
        <id>report</id>
        <phase>test</phase>
        <goals>
          <goal>report</goal>
        </goals>
      </execution>
      <execution>
        <id>check</id>
        <goals>
          <goal>check</goal>
        </goals>
        <configuration>
          <rules>
            <rule>
              <element>BUNDLE</element>
              <limits>
                <limit>
                  <counter>INSTRUCTION</counter>
                  <value>COVEREDRATIO</value>
                  <minimum>0.60</minimum>
                </limit>
              </limits>
            </rule>
          </rules>
        </configuration>
      </execution>
    </executions>
  </plugin>
</plugins>
</build>
</project>

--- ARQUIVO: ./src/main/resources/db/migration/V19__add_indexes_for_dashboard.sql ---
-- Índices para acelerar as queries do Dashboard e Listagem
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at);

--- ARQUIVO: ./src/main/resources/db/migration/V7__add_image_url_to_products.sql ---
ALTER TABLE products ADD COLUMN image_url VARCHAR(255);

--- ARQUIVO: ./src/main/resources/db/migration/V11__create_service_provider_core.sql ---
-- Núcleo universal para serviços controlados por dashboard:
-- providers (shipping/payment/etc), configs por ambiente, regras de roteamento e feature flags.

CREATE TABLE IF NOT EXISTS service_providers (
  id            UUID PRIMARY KEY,
  service_type  VARCHAR(40)  NOT NULL,
  code          VARCHAR(80)  NOT NULL,
  name          VARCHAR(160) NOT NULL,
  enabled       BOOLEAN      NOT NULL DEFAULT TRUE,
  priority      INTEGER      NOT NULL DEFAULT 100,
  driver_key    VARCHAR(160) NOT NULL,
  health_enabled BOOLEAN     NOT NULL DEFAULT TRUE,
  created_at    TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at    TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_service_providers_type_code
  ON service_providers(service_type, code);

CREATE INDEX IF NOT EXISTS ix_service_providers_type_enabled_priority
  ON service_providers(service_type, enabled, priority);


CREATE TABLE IF NOT EXISTS service_provider_configs (
  id           UUID PRIMARY KEY,
  provider_id  UUID        NOT NULL,
  environment  VARCHAR(20) NOT NULL,  -- dev/test/prod
  config_json  CLOB        NOT NULL,
  secrets_ref  VARCHAR(200),
  version      INTEGER     NOT NULL DEFAULT 1,
  updated_at   TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT fk_provider_configs_provider
    FOREIGN KEY (provider_id) REFERENCES service_providers(id)
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_provider_configs_provider_env
  ON service_provider_configs(provider_id, environment);


CREATE TABLE IF NOT EXISTS service_routing_rules (
  id            UUID PRIMARY KEY,
  service_type   VARCHAR(40) NOT NULL,
  enabled        BOOLEAN     NOT NULL DEFAULT TRUE,
  priority       INTEGER     NOT NULL DEFAULT 100,
  match_json     CLOB        NOT NULL,   -- critérios de match
  provider_code  VARCHAR(80) NOT NULL,   -- alvo
  behavior_json  CLOB,                  -- timeout, fallback, etc
  updated_at     TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS ix_routing_rules_type_enabled_priority
  ON service_routing_rules(service_type, enabled, priority);


CREATE TABLE IF NOT EXISTS feature_flags (
  id          UUID PRIMARY KEY,
  flag_key    VARCHAR(140) NOT NULL,
  enabled     BOOLEAN      NOT NULL DEFAULT FALSE,
  value_json  CLOB,
  updated_at  TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_feature_flags_key
  ON feature_flags(flag_key);

--- ARQUIVO: ./src/main/resources/db/migration/V4__create_inventory_movements.sql ---
CREATE TABLE inventory_movements (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    type VARCHAR(10) NOT NULL, -- IN, OUT, RESERVED
    quantity INTEGER NOT NULL,
    reason VARCHAR(255),
    reference_id VARCHAR(255), -- ID do pedido ou ajuste externo
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_product_inventory FOREIGN KEY (product_id) REFERENCES products(id)
);

CREATE INDEX idx_inventory_product ON inventory_movements(product_id);

--- ARQUIVO: ./src/main/resources/db/migration/V8__add_total_price_to_items.sql ---
-- Adiciona a coluna que faltava na tabela de itens do pedido
ALTER TABLE order_items 
ADD COLUMN total_price NUMERIC(38, 2) NOT NULL DEFAULT 0;

--- ARQUIVO: ./src/main/resources/db/migration/V9__create_system_config.sql ---
CREATE TABLE IF NOT EXISTS system_config (
  config_key VARCHAR(120) PRIMARY KEY,
  config_value TEXT NOT NULL,
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_system_config_updated_at ON system_config(updated_at);

--- ARQUIVO: ./src/main/resources/db/migration/V6__create_product_integrations.sql ---
CREATE TABLE product_integrations (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    integration_type VARCHAR(50) NOT NULL, -- MERCADO_LIVRE, TIKTOK
    external_id VARCHAR(255) NOT NULL,     -- Ex: MLB-123456
    sku_external VARCHAR(255),
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_pi_product FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT uk_integration_external UNIQUE (integration_type, external_id)
);

--- ARQUIVO: ./src/main/resources/db/migration/V10__seed_system_config_shipping.sql ---
-- Frete: motor dinâmico (sem hardcode)
-- Modos: J3 ou FLAT_RATE
INSERT INTO system_config (config_key, config_value)
VALUES
  ('SHIPPING_PROVIDER_MODE', 'J3'),
  ('J3_RATE', '13.00'),
  ('J3_FREE_SHIPPING_THRESHOLD', '299.00'),
  -- Lista simples de prefixos de CEP (3 a 5 dígitos), separados por vírgula. Ex: "010,011,20040,301"
  ('J3_CEP_PREFIXES', ''),
  ('FLAT_RATE', '13.00'),
  ('FLAT_FREE_SHIPPING_THRESHOLD', '299.00')
ON CONFLICT (config_key) DO NOTHING;

--- ARQUIVO: ./src/main/resources/db/migration/V25__seed_dashboard_configs.sql ---
-- Configurações de IA (Inicialmente vazias ou desativadas)
INSERT INTO system_config (config_key, config_value) VALUES
('AI_ENABLED', 'false'),
('AI_API_URL', 'https://api.openai.com/v1/chat/completions'),
('AI_API_KEY', ''), -- Admin deve preencher
('AI_MODEL', 'gpt-4o-mini'),
('AI_PROMPT_TEMPLATE_DESC', 'Crie uma descrição para o produto {product} com contexto: {context}')
ON CONFLICT (config_key) DO NOTHING;

-- Configurações Fiscal
INSERT INTO system_config (config_key, config_value) VALUES
('FISCAL_WEBHOOK_URL', '') -- Admin deve colocar a URL do n8n/Bling aqui
ON CONFLICT (config_key) DO NOTHING;

--- ARQUIVO: ./src/main/resources/db/migration/V18__seed_admin_user.sql ---
-- ATENÇÃO: Usuário Admin de Bootstrap.
-- Nasce INATIVO (active=false). Deve ser ativado manualmente via Banco de Dados
-- ou via procedure segura de reset de senha.
INSERT INTO users (id, name, email, password, role, active, created_at)
VALUES (
  gen_random_uuid(),
  'Admin Bootstrap',
  'admin@atelie.com',
  'DISABLED_ACCOUNT_CHANGE_PASSWORD', -- Hash inválida intencionalmente
  'ADMIN',
  false, -- Segurança: Inativo por padrão
  now()
)
ON CONFLICT (email) DO NOTHING;

--- ARQUIVO: ./src/main/resources/db/migration/V13__add_jsonb_to_system_config.sql ---
-- Adiciona JSONB ao system_config (Postgres). Em H2 test profile, Flyway está desligado.
ALTER TABLE system_config
  ADD COLUMN IF NOT EXISTS config_json JSONB;

-- Cria config agrupada do frete (modelo 2)
INSERT INTO system_config (config_key, config_value, config_json)
VALUES (
  'SHIPPING_RULES',
  '{}',
  '{
    "provider_mode": "J3",
    "j3": {
      "rate": 13.00,
      "free_threshold": 299.00,
      "cep_prefixes": ["010", "20040"]
    },
    "flat_rate": {
      "rate": 13.00,
      "free_threshold": 299.00
    }
  }'::jsonb
)
ON CONFLICT (config_key) DO UPDATE
SET config_json = EXCLUDED.config_json,
    updated_at = NOW();

--- ARQUIVO: ./src/main/resources/db/migration/V17__seed_n8n_config.sql ---
-- Configurações padrão para automação N8n (Evita crash na inicialização)
INSERT INTO system_config (config_key, config_value)
VALUES
  ('N8N_WEBHOOK_URL', 'http://localhost:5678/webhook/test'),
  ('N8N_Automation_Enabled', 'false') -- Desativado por padrão para segurança
ON CONFLICT (config_key) DO NOTHING;

--- ARQUIVO: ./src/main/resources/db/migration/V16__seed_feature_flags.sql ---
-- Seed inicial de Feature Flags
INSERT INTO feature_flags (id, flag_key, enabled, value_json, updated_at)
VALUES 
(gen_random_uuid(), 'MAINTENANCE_MODE', false, '{"reason": "Upgrade de sistema", "eta": "2h"}', NOW())
ON CONFLICT (flag_key) DO NOTHING;

--- ARQUIVO: ./src/main/resources/db/migration/V12__add_dynamic_attributes_to_products.sql ---
-- Adiciona coluna JSONB para guardar variáveis customizadas do produto
-- Exemplo de uso: { "material": "algodão", "peso": "200g", "personalizavel": true }
ALTER TABLE products ADD COLUMN attributes JSONB DEFAULT '{}';

-- Cria um índice para busca rápida dentro do JSON (Performance para Analytics)
-- Ex: Buscar todos os produtos onde attributes->>'cor' = 'azul'
CREATE INDEX idx_products_attributes ON products USING GIN (attributes);

--- ARQUIVO: ./src/main/resources/db/migration/V23__seed_system_config_cache_ttl.sql ---
-- TTL do cache em memória (segundos) - mutável via dashboard
INSERT INTO system_config (config_key, config_value)
VALUES ('CACHE_TTL_SECONDS', '300')
ON CONFLICT (config_key) DO NOTHING;

--- ARQUIVO: ./src/main/resources/db/migration/V2__create_categories.sql ---
CREATE TABLE categories (
  id UUID PRIMARY KEY,
  name VARCHAR(120) NOT NULL UNIQUE,
  active BOOLEAN NOT NULL
);

--- ARQUIVO: ./src/main/resources/db/migration/V20__ensure_inventory_idempotency.sql ---
-- Garante que um mesmo pedido (reference_id) não possa baixar estoque (OUT) do mesmo produto duas vezes.
-- Isso blinda o sistema contra cliques duplos, retentativas de fila e race conditions.

CREATE UNIQUE INDEX IF NOT EXISTS ux_inventory_idempotency 
ON inventory_movements (product_id, type, reference_id)
WHERE reference_id IS NOT NULL;

--- ARQUIVO: ./src/main/resources/db/migration/V3__create_products.sql ---
CREATE TABLE products (
  id UUID PRIMARY KEY,
  name VARCHAR(160) NOT NULL,
  description VARCHAR(2000) NOT NULL,
  price NUMERIC(19,2) NOT NULL,
  category_id UUID NOT NULL,
  active BOOLEAN NOT NULL,

  CONSTRAINT fk_products_category
    FOREIGN KEY (category_id) REFERENCES categories(id)
);

--- ARQUIVO: ./src/main/resources/db/migration/V22__create_invoices_table.sql ---
CREATE TABLE invoices (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL,
    external_invoice_id VARCHAR(100), -- ID no Bling/Gov
    status VARCHAR(50) NOT NULL,      -- EMITTED, ERROR, CANCELED
    xml_url VARCHAR(500),
    pdf_url VARCHAR(500),
    issued_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT fk_invoices_order FOREIGN KEY (order_id) REFERENCES orders(id)
);

CREATE INDEX idx_invoices_order ON invoices(order_id);

--- ARQUIVO: ./src/main/resources/db/migration/V15__seed_service_engine.sql ---
-- ============================================================================
-- SEED: Inicialização do Motor de Serviços (Tornando o sistema funcional no Dia 1)
-- ============================================================================

-- 1. Registrar os DRIVERS Java no Banco de Dados (Service Providers)
-- Estes códigos (code) ligam o Dashboard às classes Java (driver_key)

INSERT INTO service_providers (id, service_type, code, name, enabled, priority, driver_key, health_enabled) VALUES
-- Frete
(gen_random_uuid(), 'SHIPPING', 'J3', 'J3 Transportadora', true, 10, 'shipping.j3', true),
(gen_random_uuid(), 'SHIPPING', 'FLAT', 'Frete Fixo', true, 90, 'shipping.flat_rate', false),
(gen_random_uuid(), 'SHIPPING', 'LOGGI_WEBHOOK', 'Loggi (Via API)', false, 20, 'universal.shipping.webhook', true),

-- Pagamento
(gen_random_uuid(), 'PAYMENT', 'MERCADO_PAGO', 'Mercado Pago', true, 10, 'payment.mercadopago', true),
(gen_random_uuid(), 'PAYMENT', 'PIX_BANK_WEBHOOK', 'Banco Pix (Webhook)', false, 20, 'universal.payment.webhook', false),

-- Notificação
(gen_random_uuid(), 'NOTIFICATION', 'WHATSAPP', 'WhatsApp (Twilio/Z-API)', false, 10, 'universal.notification.webhook', false)
ON CONFLICT (service_type, code) DO NOTHING;


-- 2. Configurações Iniciais (JSONs que o Dashboard edita)

-- Config do J3
INSERT INTO service_provider_configs (id, provider_id, environment, config_json, version)
SELECT gen_random_uuid(), id, 'prod', '{
  "rate": 14.50,
  "free_threshold": 299.00,
  "cep_prefixes": "010,011,012,200,220"
}', 1
FROM service_providers WHERE code = 'J3' AND service_type = 'SHIPPING';

-- Config do Frete Fixo
INSERT INTO service_provider_configs (id, provider_id, environment, config_json, version)
SELECT gen_random_uuid(), id, 'prod', '{
  "rate": 25.00,
  "free_threshold": 500.00
}', 1
FROM service_providers WHERE code = 'FLAT' AND service_type = 'SHIPPING';

-- Config do Mercado Pago
INSERT INTO service_provider_configs (id, provider_id, environment, config_json, version)
SELECT gen_random_uuid(), id, 'prod', '{
  "public_key": "APP_USR-...",
  "access_token": "APP_USR-...",
  "sandbox": false
}', 1
FROM service_providers WHERE code = 'MERCADO_PAGO' AND service_type = 'PAYMENT';


-- 3. Regras de Roteamento (O Cérebro da Escolha)

-- Regra 1: Se o carrinho > R$ 500,00, Tenta J3 (Frete Grátis configurado nele)
INSERT INTO service_routing_rules (id, service_type, enabled, priority, match_json, provider_code, behavior_json)
VALUES (
  gen_random_uuid(), 
  'SHIPPING', 
  true, 
  10, 
  '{ "expression": "#ctx.cartTotal >= 500" }', 
  'J3', 
  '{ "timeout_ms": 2000 }'
);

-- Regra 2: Fallback padrão para J3 em SP (prefixo 01)
INSERT INTO service_routing_rules (id, service_type, enabled, priority, match_json, provider_code)
VALUES (
  gen_random_uuid(), 
  'SHIPPING', 
  true, 
  50, 
  '{ "cep_prefix": ["01", "02", "03", "04", "05"] }', 
  'J3'
);

-- Regra 3: Default geral (Frete Fixo) para o resto do Brasil
INSERT INTO service_routing_rules (id, service_type, enabled, priority, match_json, provider_code)
VALUES (
  gen_random_uuid(), 
  'SHIPPING', 
  true, 
  999, 
  '{ "expression": "true" }', 
  'FLAT'
);

-- Regra 4: Pagamento Padrão = Mercado Pago
INSERT INTO service_routing_rules (id, service_type, enabled, priority, match_json, provider_code)
VALUES (
  gen_random_uuid(), 
  'PAYMENT', 
  true, 
  100, 
  '{ "expression": "true" }', 
  'MERCADO_PAGO'
);

--- ARQUIVO: ./src/main/resources/db/migration/V24__fix_inventory_index_and_variant_logic.sql ---
-- 1. Drops the wrong index (which blocked multiple variants of the same product in the same order)
DROP INDEX IF EXISTS ux_inventory_idempotency;

-- 2. Creates the correct index based on VARIANT_ID
-- This ensures that the uniqueness check is applied per SKU, not per Product Parent
CREATE UNIQUE INDEX IF NOT EXISTS ux_inventory_idempotency 
ON inventory_movements (variant_id, type, reference_id)
WHERE reference_id IS NOT NULL;
--- ARQUIVO: ./src/main/resources/db/migration/V5__create_orders_tables.sql ---
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    status VARCHAR(20) NOT NULL, -- PENDING, PAID, SHIPPED, CANCELED
    source VARCHAR(50) NOT NULL, -- INTERNAL, MERCADO_LIVRE, TIKTOK
    external_id VARCHAR(255),    -- ID na loja externa
    customer_name VARCHAR(255),
    total_amount DECIMAL(19, 2) NOT NULL,
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE order_items (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL,
    product_id UUID NOT NULL,
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(19, 2) NOT NULL,
    CONSTRAINT fk_order_items_order FOREIGN KEY (order_id) REFERENCES orders(id),
    CONSTRAINT fk_order_items_product FOREIGN KEY (product_id) REFERENCES products(id)
);

CREATE INDEX idx_orders_external ON orders(external_id);

--- ARQUIVO: ./src/main/resources/db/migration/V21__create_product_variants_structure.sql ---
-- 1. Cria a tabela de variantes
CREATE TABLE product_variants (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    sku VARCHAR(100) NOT NULL,
    gtin VARCHAR(14), -- EAN/UPC
    price NUMERIC(19, 2), -- Preço específico da variante (se null, usa do pai)
    stock_quantity INTEGER NOT NULL DEFAULT 0,
    attributes_json JSONB, -- { "cor": "azul", "tamanho": "M" }
    active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT fk_variants_product FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT uk_variants_sku UNIQUE (sku)
);

CREATE INDEX idx_variants_product ON product_variants(product_id);
CREATE INDEX idx_variants_gtin ON product_variants(gtin);

-- 2. Migração de Dados: Cria uma variante "Default" para cada produto existente
-- Isso garante que o estoque atual não se perca.
INSERT INTO product_variants (id, product_id, sku, stock_quantity, price, active, attributes_json)
SELECT 
  gen_random_uuid(), 
  id, 
  'SKU-' || substring(id::text, 1, 8), -- Gera um SKU provisório
  stock_quantity, 
  price, 
  active,
  '{"default": true}'::jsonb
FROM products;

-- 3. Atualizar tabela de movimentos de estoque para apontar para variante
ALTER TABLE inventory_movements ADD COLUMN variant_id UUID;
ALTER TABLE inventory_movements ADD CONSTRAINT fk_inventory_variant FOREIGN KEY (variant_id) REFERENCES product_variants(id);

-- 4. Atualizar itens do pedido para apontar para variante
ALTER TABLE order_items ADD COLUMN variant_id UUID;
ALTER TABLE order_items ADD CONSTRAINT fk_order_items_variant FOREIGN KEY (variant_id) REFERENCES product_variants(id);

--- ARQUIVO: ./src/main/resources/db/migration/V1__create_users.sql ---
-- Habilita a extensão para gerar UUIDs (Apenas se for Postgres, ignora erro no H2)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE users (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'USER',
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW()
);

-- Índices para performance no Login
CREATE INDEX idx_users_email ON users(email);

--- ARQUIVO: ./src/main/resources/application.yml ---
spring:
  application:
    name: ecommerce-core

  datasource:
    url: ${DB_URL:jdbc:postgresql://localhost:5432/ecommerce}
    username: ${DB_USER:postgres}
    password: ${DB_PASS:postgres}
    # TUNING PARA PRODUÇÃO
    hikari:
      maximum-pool-size: ${DB_POOL_SIZE:20}
      minimum-idle: 5
      idle-timeout: 30000
      connection-timeout: 20000
      max-lifetime: 1800000

  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        format_sql: false # Desligar em produção para performance
    open-in-view: false   # Boas práticas: desativar OSIV para evitar conexões presas

  flyway:
    enabled: true
    locations: classpath:db/migration

# Suporte a Proxy Reverso (Nginx/AWS LB/Https)
server:
  port: ${PORT:8080}
  forward-headers-strategy: native

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/EcommerceApplication.java ---
package com.atelie.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Classe principal da aplicação.
 * Responsável apenas por iniciar o Spring Boot.
 */
@SpringBootApplication
public class EcommerceApplication {

    public static void main(String[] args) {
        SpringApplication.run(EcommerceApplication.class, args);
    }

}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/health/HealthService.java ---
package com.atelie.ecommerce.application.service.health;

import org.springframework.stereotype.Service;

/**
 * HealthService.
 *
 * Serviço simples para healthcheck da aplicação.
 */
@Service
public class HealthService {

    /**
     * Retorna o status atual da aplicação.
     *
     * @return String com o status (ex: "OK")
     */
    public String getStatus() {
        return "OK";
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/category/CategoryService.java ---
package com.atelie.ecommerce.application.service.catalog.category;

import com.atelie.ecommerce.api.catalog.category.dto.CategoryResponse;
import com.atelie.ecommerce.api.catalog.category.dto.CreateCategoryRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryEntity;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Service
public class CategoryService {

    private final CategoryRepository repository;

    public CategoryService(CategoryRepository repository) {
        this.repository = repository;
    }

    public CategoryResponse create(CreateCategoryRequest request) {
        boolean exists = repository.findAll().stream()
                .anyMatch(c -> c.getName().equalsIgnoreCase(request.getName()));

        if (exists) {
            throw new ConflictException("Category already exists");
        }

        CategoryEntity entity = new CategoryEntity();
        entity.setId(UUID.randomUUID());
        entity.setName(request.getName());
        entity.setActive(request.getActive());

        repository.save(entity);

        return new CategoryResponse(entity.getId(), entity.getName(), entity.getActive());
    }

    public List<CategoryResponse> list() {
        return repository.findAll().stream()
                .map(c -> new CategoryResponse(c.getId(), c.getName(), c.getActive()))
                .toList();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/product/ProductService.java ---
package com.atelie.ecommerce.application.service.catalog.product;

import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.domain.catalog.event.ProductSavedEvent;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryEntity;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity; // Import
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository; // Import
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
public class ProductService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final ProductVariantRepository variantRepository; // New dependency
    private final GtinGeneratorService gtinGenerator;         // New dependency
    private final ApplicationEventPublisher eventPublisher;

    public ProductService(ProductRepository productRepository,
                          CategoryRepository categoryRepository,
                          ProductVariantRepository variantRepository,
                          GtinGeneratorService gtinGenerator,
                          ApplicationEventPublisher eventPublisher) {
        this.productRepository = productRepository;
        this.categoryRepository = categoryRepository;
        this.variantRepository = variantRepository;
        this.gtinGenerator = gtinGenerator;
        this.eventPublisher = eventPublisher;
    }

    @Transactional(readOnly = true)
    public ProductEntity findById(UUID id) {
        return productRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Product not found with ID: " + id));
    }

    @Transactional
    public ProductEntity saveProduct(ProductEntity product, UUID categoryId) {
        CategoryEntity category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new NotFoundException("Category not found with ID: " + categoryId));
        product.setCategory(category);
        
        boolean isNew = product.getId() == null;
        if (isNew) {
            product.setId(UUID.randomUUID()); // Ensure ID is generated before saving variant
        }

        ProductEntity saved = productRepository.save(product);

        // --- CRITICAL FIX: Create Default Variant for New Products ---
        if (isNew) {
            createDefaultVariant(saved);
        }

        eventPublisher.publishEvent(new ProductSavedEvent(saved.getId(), isNew));
        return saved;
    }

    private void createDefaultVariant(ProductEntity product) {
        ProductVariantEntity defaultVariant = ProductVariantEntity.builder()
                .product(product)
                .sku("SKU-" + product.getId().toString().substring(0, 8).toUpperCase())
                .gtin(gtinGenerator.generateInternalEan13())
                .price(null) // Null means "inherit from parent"
                .stockQuantity(product.getStockQuantity() != null ? product.getStockQuantity() : 0)
                .active(true)
                .attributesJson("{\"default\": true}")
                .build();
        
        variantRepository.save(defaultVariant);
    }

    @Transactional(readOnly = true)
    public Page<ProductEntity> getAllActiveProducts(Pageable pageable) {
        return productRepository.findByActiveTrue(pageable);
    }
}
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/product/GtinGeneratorService.java ---
package com.atelie.ecommerce.application.service.catalog.product;

import org.springframework.stereotype.Service;
import java.util.Random;

@Service
public class GtinGeneratorService {

    private final Random random = new Random();

    /**
     * Gera um EAN-13 válido iniciado com '2' (Uso interno/Restrito).
     * Formato: 2 + 11 dígitos aleatórios + Dígito Verificador.
     */
    public String generateInternalEan13() {
        StringBuilder sb = new StringBuilder("2"); // Prefixo interno comum
        for (int i = 0; i < 11; i++) {
            sb.append(random.nextInt(10));
        }
        String codeWithoutDigit = sb.toString();
        int checkDigit = calculateCheckDigit(codeWithoutDigit);
        return codeWithoutDigit + checkDigit;
    }

    private int calculateCheckDigit(String code) {
        int sum = 0;
        for (int i = 0; i < code.length(); i++) {
            int digit = Character.getNumericValue(code.charAt(i));
            if (i % 2 == 0) { // Par (0-index, na spec é ímpar) -> x1
                sum += digit;
            } else { // Ímpar (0-index, na spec é par) -> x3
                sum += digit * 3;
            }
        }
        int remainder = sum % 10;
        return (remainder == 0) ? 0 : 10 - remainder;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/product/ProductIntegrationService.java ---
package com.atelie.ecommerce.application.service.catalog.product;

import com.atelie.ecommerce.api.catalog.product.dto.LinkIntegrationRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductIntegrationRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductIntegrationEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.UUID;

@Service
public class ProductIntegrationService {

    private final ProductRepository productRepository;
    private final ProductIntegrationRepository integrationRepository;

    public ProductIntegrationService(ProductRepository productRepository, ProductIntegrationRepository integrationRepository) {
        this.productRepository = productRepository;
        this.integrationRepository = integrationRepository;
    }

    @Transactional
    public void linkProduct(UUID productId, LinkIntegrationRequest request) {
        ProductEntity product = productRepository.findById(productId)
                .orElseThrow(() -> new NotFoundException("Product not found"));

        if (integrationRepository.findByExternalIdAndIntegrationType(request.externalId(), request.integrationType()).isPresent()) {
            throw new ConflictException("External ID " + request.externalId() + " already linked for type " + request.integrationType());
        }

        ProductIntegrationEntity link = new ProductIntegrationEntity(
                product,
                request.integrationType().toUpperCase(), // Padroniza
                request.externalId(),
                request.skuExternal()
        );
        integrationRepository.save(link);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/product/ProductVariantService.java ---
package com.atelie.ecommerce.application.service.catalog.product;

import com.atelie.ecommerce.api.catalog.product.dto.CreateVariantRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;

@Service
public class ProductVariantService {

    private final ProductRepository productRepository;
    private final ProductVariantRepository variantRepository;
    private final GtinGeneratorService gtinGenerator;

    public ProductVariantService(ProductRepository productRepository, 
                                 ProductVariantRepository variantRepository,
                                 GtinGeneratorService gtinGenerator) {
        this.productRepository = productRepository;
        this.variantRepository = variantRepository;
        this.gtinGenerator = gtinGenerator;
    }

    @Transactional
    public ProductVariantEntity create(UUID productId, CreateVariantRequest request) {
        ProductEntity product = productRepository.findById(productId)
                .orElseThrow(() -> new NotFoundException("Produto pai não encontrado"));

        if (variantRepository.existsBySku(request.sku())) {
            throw new ConflictException("SKU já existe: " + request.sku());
        }

        // Gera GTIN automático se não vier no request
        String gtin = (request.gtin() == null || request.gtin().isBlank()) 
                ? gtinGenerator.generateInternalEan13() 
                : request.gtin();

        ProductVariantEntity variant = ProductVariantEntity.builder()
                .product(product)
                .sku(request.sku())
                .gtin(gtin)
                .price(request.price()) // Pode ser null (usa do pai)
                .stockQuantity(request.initialStock())
                .attributesJson(request.attributesJson()) // Ex: {"cor":"azul"}
                .active(true)
                .build();

        return variantRepository.save(variant);
    }

    public List<ProductVariantEntity> listByProduct(UUID productId) {
        return variantRepository.findByProductId(productId);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/auth/AuthService.java ---
package com.atelie.ecommerce.application.service.auth;

import com.atelie.ecommerce.api.auth.dto.LoginRequest;
import com.atelie.ecommerce.api.auth.dto.RegisterRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.infrastructure.persistence.auth.UserRepository;
import com.atelie.ecommerce.infrastructure.persistence.auth.entity.UserEntity;
import com.atelie.ecommerce.infrastructure.security.TokenProvider;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AuthService {

    private final AuthenticationManager authenticationManager;
    private final TokenProvider tokenProvider;
    private final PasswordEncoder passwordEncoder;
    private final UserRepository userRepository;

    public AuthService(AuthenticationManager authenticationManager, 
                       TokenProvider tokenProvider, 
                       PasswordEncoder passwordEncoder,
                       UserRepository userRepository) {
        this.authenticationManager = authenticationManager;
        this.tokenProvider = tokenProvider;
        this.passwordEncoder = passwordEncoder;
        this.userRepository = userRepository;
    }

    public String login(LoginRequest request) {
        // Autentica e gera o token usando o objeto de autenticação completo (mais seguro)
        Authentication auth = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword())
        );
        return tokenProvider.generateToken(auth);
    }

    @Transactional
    public void register(RegisterRequest request) {
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new ConflictException("E-mail já cadastrado no sistema.");
        }

        UserEntity newUser = new UserEntity(
            request.getName(),
            request.getEmail(),
            passwordEncoder.encode(request.getPassword()),
            "USER"
        );
        userRepository.save(newUser);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/inventory/InventoryService.java ---
package com.atelie.ecommerce.application.service.inventory;

import com.atelie.ecommerce.domain.inventory.MovementType;
import com.atelie.ecommerce.domain.inventory.event.InventoryChangedEvent;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import com.atelie.ecommerce.infrastructure.persistence.inventory.InventoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.inventory.entity.InventoryMovementEntity;
import com.atelie.ecommerce.api.common.exception.NotFoundException;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
public class InventoryService {

    private final InventoryRepository inventoryRepository;
    private final ProductVariantRepository variantRepository; // Agora usa VariantRepo
    private final ApplicationEventPublisher eventPublisher;

    public InventoryService(InventoryRepository inventoryRepository, 
                            ProductVariantRepository variantRepository,
                            ApplicationEventPublisher eventPublisher) {
        this.inventoryRepository = inventoryRepository;
        this.variantRepository = variantRepository;
        this.eventPublisher = eventPublisher;
    }

    @Transactional(readOnly = true)
    public Integer getStock(UUID variantId) {
        return variantRepository.findById(variantId)
                .map(ProductVariantEntity::getStockQuantity)
                .orElseThrow(() -> new NotFoundException("Variant not found"));
    }

    @Transactional
    public void addMovement(UUID variantId, MovementType type, Integer quantity, String reason, String refId) {
        ProductVariantEntity variant = variantRepository.findById(variantId)
                .orElseThrow(() -> new NotFoundException("Variant not found"));

        if (type == MovementType.OUT) {
            int rowsUpdated = variantRepository.decrementStock(variantId, quantity);
            if (rowsUpdated == 0) {
                throw new IllegalArgumentException("Estoque insuficiente para a variante: " + variant.getSku());
            }
        } else if (type == MovementType.IN) {
            variantRepository.incrementStock(variantId, quantity);
        }

        // Registra histórico (InventoryMovementEntity precisará ser atualizado para ter variant)
        // Por compatibilidade com o código antigo, estamos setando o produto pai
        InventoryMovementEntity movement = new InventoryMovementEntity();
        movement.setId(UUID.randomUUID());
        movement.setProduct(variant.getProduct());
        movement.setVariantId(variant.getId()); // Campo novo
        movement.setType(type);
        movement.setQuantity(quantity);
        movement.setReason(reason);
        movement.setReferenceId(refId);
        
        inventoryRepository.save(movement);

        Integer newBalance = variantRepository.findById(variantId)
                .orElseThrow(() -> new com.atelie.ecommerce.api.common.exception.NotFoundException("Variant not found"))
                .getStockQuantity();
        // Publica evento usando o ID do produto pai para listeners de vitrine, mas o saldo é da variante
        eventPublisher.publishEvent(new InventoryChangedEvent(variant.getProduct().getId(), newBalance));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/file/FileStorageService.java ---
package com.atelie.ecommerce.application.service.file;

import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.*;
import java.util.List;
import java.util.UUID;

/**
 * FileStorageService
 *
 * Regras de segurança:
 * - Bloqueia upload vazio
 * - Limita tamanho máximo (default 5MB)
 * - Permite apenas extensões conhecidas
 * - Gera nome novo (UUID) para impedir path traversal/colisão
 */
@Service
public class FileStorageService {

    private static final long MAX_FILE_SIZE_BYTES = 5L * 1024L * 1024L; // 5MB
    private static final List<String> ALLOWED_EXTENSIONS = List.of("jpg", "jpeg", "png", "webp", "gif");

    private final Path root = Paths.get("./uploads");

    public FileStorageService() {
        try {
            Files.createDirectories(root);
        } catch (IOException e) {
            throw new IllegalStateException("Não foi possível inicializar a pasta de upload.", e);
        }
    }

    public String save(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Arquivo inválido (vazio).");
        }
        if (file.getSize() > MAX_FILE_SIZE_BYTES) {
            throw new IllegalArgumentException("Arquivo excede o tamanho máximo permitido (5MB).");
        }

        String originalFilename = file.getOriginalFilename();
        String extension = getExtension(originalFilename).toLowerCase();

        if (!ALLOWED_EXTENSIONS.contains(extension)) {
            throw new SecurityException("Tipo de arquivo não permitido: " + extension);
        }

        String filename = UUID.randomUUID() + "." + extension;
        Path destination = root.resolve(filename).normalize();

        // Garante que o arquivo final está dentro de /uploads
        if (!destination.startsWith(root.normalize())) {
            throw new SecurityException("Caminho de upload inválido.");
        }

        try (InputStream in = file.getInputStream()) {
            Files.copy(in, destination, StandardCopyOption.REPLACE_EXISTING);
            return filename;
        } catch (IOException e) {
            throw new IllegalStateException("Falha ao salvar arquivo.", e);
        }
    }

    private String getExtension(String filename) {
        if (filename == null) return "";
        int i = filename.lastIndexOf('.');
        return i > 0 ? filename.substring(i + 1) : "";
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/fiscal/InvoiceService.java ---
package com.atelie.ecommerce.application.service.fiscal;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import java.util.Map;
import java.util.UUID;

@Slf4j
@Service
public class InvoiceService {

    private final DynamicConfigService configService;
    private final RestTemplate restTemplate;

    public InvoiceService(DynamicConfigService configService, RestTemplate restTemplate) {
        this.configService = configService;
        this.restTemplate = restTemplate;
    }

    public void emitInvoiceForOrder(UUID orderId) {
        String webhookUrl = configService.getString("FISCAL_WEBHOOK_URL");
        
        if (webhookUrl == null || webhookUrl.isBlank()) {
            log.info("Emissão de NFe ignorada: URL de webhook fiscal não configurada no Dashboard.");
            return;
        }

        try {
            // Dispara um POST simples para o integrador fiscal (Bling, Tiny, eNotas)
            // O payload é genérico, o integrador lá na ponta que se vire para buscar os dados do pedido
            Map<String, Object> payload = Map.of(
                "event", "ORDER_APPROVED",
                "order_id", orderId.toString()
            );
            
            restTemplate.postForLocation(webhookUrl, payload);
            log.info("Solicitação de NFe enviada para: {}", webhookUrl);

        } catch (Exception e) {
            log.error("Falha ao chamar webhook fiscal", e);
        }
    }
}
