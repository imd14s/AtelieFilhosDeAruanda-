
--- ARQUIVO: ./Dockerfile ---
FROM maven:3.9.6-eclipse-temurin-21-alpine AS builder
WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn clean package -DskipTests

FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
RUN addgroup -S spring && adduser -S spring -G spring
RUN mkdir -p /app/uploads && chown -R spring:spring /app
COPY --from=builder /build/target/ecommerce-core-0.0.1-SNAPSHOT.jar app.jar
USER spring
VOLUME /app/uploads
EXPOSE 8080
ENTRYPOINT ["java", "-Duser.timezone=UTC", "-jar", "app.jar"]

--- ARQUIVO: ./.dockerignore ---
target
.git
.gitignore
node_modules
*.log
.env

--- ARQUIVO: ./.gitignore ---
# Java / Maven
/target/
*.class
*.log
*.jar
*.war
*.ear
*.iml

# Coverage / Reports
*.exec
*.html
/jacoco.exec

# IDEs
.idea/
.vscode/

# OS
.DS_Store

# Env
.env
.env.*

--- ARQUIVO: ./pom.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.1</version>
        <relativePath/>
    </parent>
    <groupId>com.atelie</groupId>
    <artifactId>ecommerce-core</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ecommerce-core</name>
    <description>Atelie Filhos de Aruanda - Backend</description>

    <properties>
        <java.version>21</java.version>
        <jjwt.version>0.11.5</jjwt.version>
        <springdoc.version>2.3.0</springdoc.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

--- ARQUIVO: ./src/main/resources/db/migration/V3__seed_data.sql ---
-- 1. Categoria Padrão (Sem Pai)
INSERT INTO categories (id, name, active) VALUES
(gen_random_uuid(), 'Geral', true)
ON CONFLICT (name) DO NOTHING;

-- 2. Providers (Drivers)
-- CORREÇÃO: Adicionamos created_at e updated_at
INSERT INTO service_providers (id, service_type, code, name, enabled, priority, driver_key, health_enabled, created_at, updated_at) VALUES
(gen_random_uuid(), 'SHIPPING', 'J3', 'J3 Transportadora', true, 10, 'shipping.j3', true, NOW(), NOW()),
(gen_random_uuid(), 'SHIPPING', 'FLAT', 'Frete Fixo', true, 90, 'shipping.flat_rate', false, NOW(), NOW()),
(gen_random_uuid(), 'SHIPPING', 'LOGGI_WEBHOOK', 'Loggi API', false, 20, 'universal.shipping.webhook', true, NOW(), NOW()),
(gen_random_uuid(), 'PAYMENT', 'MERCADO_PAGO', 'Mercado Pago', true, 10, 'payment.mercadopago', true, NOW(), NOW()),
(gen_random_uuid(), 'PAYMENT', 'PIX_BANK_WEBHOOK', 'Banco Pix', false, 20, 'universal.payment.webhook', false, NOW(), NOW()),
(gen_random_uuid(), 'NOTIFICATION', 'WHATSAPP', 'WhatsApp', false, 10, 'universal.notification.webhook', false, NOW(), NOW())
ON CONFLICT (service_type, code) DO NOTHING;

-- 3. Configs Padrão para Providers (Exemplo)
INSERT INTO service_provider_configs (id, provider_id, environment, config_json, version, active, updated_at)
SELECT gen_random_uuid(), id, 'PRODUCTION', '{"apiKey": "CHANGEME"}', 1, true, NOW()
FROM service_providers WHERE code = 'J3'
ON CONFLICT DO NOTHING;

INSERT INTO service_provider_configs (id, provider_id, environment, config_json, version, active, updated_at)
SELECT gen_random_uuid(), id, 'PRODUCTION', '{"price": 15.00}', 1, true, NOW()
FROM service_providers WHERE code = 'FLAT'
ON CONFLICT DO NOTHING;

-- 4. Routing Rules Iniciais
INSERT INTO service_routing_rules (id, service_type, provider_code, enabled, priority, match_json, behavior_json, updated_at) VALUES
(gen_random_uuid(), 'SHIPPING', 'FLAT', true, 999, '{"expression": "true"}', NULL, NOW())
ON CONFLICT DO NOTHING;

--- ARQUIVO: ./src/main/resources/db/migration/V4__seed_products.sql ---
-- Criação de Categoria Específica
INSERT INTO categories (id, name, active) 
VALUES (gen_random_uuid(), 'Artigos Religiosos', true)
ON CONFLICT (name) DO NOTHING;

-- CTE (Common Table Expression) para capturar o ID da categoria
WITH cat AS (
    SELECT id FROM categories WHERE name = 'Artigos Religiosos' LIMIT 1
)
INSERT INTO products (id, name, description, price, category_id, active, stock_quantity, created_at, updated_at) VALUES
-- Produto 1
(
    'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 
    'Vela de 7 Dias Branca', 
    'Vela votiva de parafina pura, duração estimada de 7 dias. Ideal para rituais de paz e firmeza de anjo da guarda.', 
    12.90, 
    (SELECT id FROM cat), 
    true, 
    100, 
    NOW(), NOW()
),
-- Produto 2
(
    'b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a22', 
    'Incenso Artesanal de Arruda', 
    'Incenso natural de arruda para limpeza energética e proteção do ambiente. Caixa com 10 varetas.', 
    8.50, 
    (SELECT id FROM cat), 
    true, 
    200, 
    NOW(), NOW()
),
-- Produto 3
(
    'c0eebc99-9c0b-4ef8-bb6d-6bb9bd380a33', 
    'Imagem de Oxalá (20cm)', 
    'Estatueta de gesso resinado de Oxalá, acabamento fino e pintura manual. Altura 20cm.', 
    89.90, 
    (SELECT id FROM cat), 
    true, 
    15, 
    NOW(), NOW()
),
-- Produto 4
(
    'd0eebc99-9c0b-4ef8-bb6d-6bb9bd380a44', 
    'Banho de Ervas - Abre Caminho', 
    'Mix de ervas secas selecionadas para banho de descarrego e abertura de caminhos. Contém levante, guiné e alecrim.', 
    25.00, 
    (SELECT id FROM cat), 
    true, 
    50, 
    NOW(), NOW()
),
-- Produto 5
(
    'e0eebc99-9c0b-4ef8-bb6d-6bb9bd380a55', 
    'Guia de Proteção Vermelha e Preta', 
    'Guia de proteção confeccionada com miçangas de vidro e firma. Cores vibrantes.', 
    45.00, 
    (SELECT id FROM cat), 
    true, 
    30, 
    NOW(), NOW()
),
-- Produto 6
(
    'f0eebc99-9c0b-4ef8-bb6d-6bb9bd380a66', 
    'Defumador Completo com Carvão', 
    'Kit contendo turibulo pequeno, carvão vegetal e mix de resinas sagradas para defumação.', 
    110.00, 
    (SELECT id FROM cat), 
    true, 
    10, 
    NOW(), NOW()
)
ON CONFLICT (id) DO NOTHING;

-- Inserir Imagens para os Produtos (Usando Placeholders por enquanto)
INSERT INTO product_images (product_id, image_url) VALUES
('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'https://placehold.co/600x400/EEE/31343C?text=Vela+7+Dias'),
('b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a22', 'https://placehold.co/600x400/2E7D32/FFFFFF?text=Incenso+Arruda'),
('c0eebc99-9c0b-4ef8-bb6d-6bb9bd380a33', 'https://placehold.co/600x400/FFFFFF/000000?text=Imagem+Oxala'),
('d0eebc99-9c0b-4ef8-bb6d-6bb9bd380a44', 'https://placehold.co/600x400/81C784/000000?text=Banho+Ervas'),
('e0eebc99-9c0b-4ef8-bb6d-6bb9bd380a55', 'https://placehold.co/600x400/B71C1C/FFFFFF?text=Guia+Protecao'),
('f0eebc99-9c0b-4ef8-bb6d-6bb9bd380a66', 'https://placehold.co/600x400/5D4037/FFFFFF?text=Defumador');

-- Inserir Variantes (Obrigatório para o carrinho funcionar corretamente)
INSERT INTO product_variants (id, product_id, sku, price, stock_quantity, active, created_at, updated_at) VALUES
(gen_random_uuid(), 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'VELA-001', 12.90, 100, true, NOW(), NOW()),
(gen_random_uuid(), 'b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a22', 'INC-001', 8.50, 200, true, NOW(), NOW()),
(gen_random_uuid(), 'c0eebc99-9c0b-4ef8-bb6d-6bb9bd380a33', 'IMG-OXA-01', 89.90, 15, true, NOW(), NOW()),
(gen_random_uuid(), 'd0eebc99-9c0b-4ef8-bb6d-6bb9bd380a44', 'BNH-001', 25.00, 50, true, NOW(), NOW()),
(gen_random_uuid(), 'e0eebc99-9c0b-4ef8-bb6d-6bb9bd380a55', 'GUA-001', 45.00, 30, true, NOW(), NOW()),
(gen_random_uuid(), 'f0eebc99-9c0b-4ef8-bb6d-6bb9bd380a66', 'DEF-KIT-01', 110.00, 10, true, NOW(), NOW())
ON CONFLICT DO NOTHING;

--- ARQUIVO: ./src/main/resources/db/migration/V1__init_schema.sql ---
-- Extensão para UUIDs (Postgres)
${PGCRYPTO_EXTENSION}

-- 1. Usuários e Autenticação
CREATE TABLE users (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'USER',
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
CREATE INDEX idx_users_email ON users(email);

-- 2. Catálogo (Categorias, Produtos e Variantes)
CREATE TABLE categories (
    id UUID PRIMARY KEY,
    name VARCHAR(120) NOT NULL UNIQUE,
    active BOOLEAN NOT NULL
);

CREATE TABLE products (
    id UUID PRIMARY KEY,
    name VARCHAR(160) NOT NULL,
    description VARCHAR(2000) NOT NULL,
    price NUMERIC(19,2) NOT NULL,
    category_id UUID NOT NULL,
    active BOOLEAN NOT NULL,
    image_url VARCHAR(255),
    attributes JSONB DEFAULT '{}',
    alert_enabled BOOLEAN DEFAULT FALSE,
    stock_quantity INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_products_category FOREIGN KEY (category_id) REFERENCES categories(id)
);
CREATE INDEX idx_products_attributes ON products USING GIN (attributes);

CREATE TABLE product_images (
    product_id UUID NOT NULL,
    image_url VARCHAR(500) NOT NULL,
    CONSTRAINT fk_product_images_product FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
);
CREATE INDEX idx_product_images_product_id ON product_images(product_id);

CREATE TABLE product_variants (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    sku VARCHAR(100) NOT NULL UNIQUE,
    gtin VARCHAR(20),
    stock_quantity INTEGER NOT NULL DEFAULT 0,
    price DECIMAL(19, 2),
    active BOOLEAN DEFAULT TRUE,
    attributes_json JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_variant_product FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX ux_product_variant_gtin ON product_variants(gtin) WHERE gtin IS NOT NULL;

CREATE TABLE product_integrations (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    integration_type VARCHAR(50) NOT NULL,
    external_id VARCHAR(255) NOT NULL,
    sku_external VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_pi_product FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT uk_integration_external UNIQUE (integration_type, external_id)
);

-- 3. Estoque
CREATE TABLE inventory_movements (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    variant_id UUID NOT NULL,
    type VARCHAR(10) NOT NULL,
    quantity INTEGER NOT NULL,
    reason VARCHAR(255),
    reference_id VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_inventory_product FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT fk_inventory_variant FOREIGN KEY (variant_id) REFERENCES product_variants(id)
);
CREATE INDEX idx_inventory_product ON inventory_movements(product_id);
CREATE UNIQUE INDEX ux_inventory_idempotency ON inventory_movements (variant_id, type, reference_id) WHERE reference_id IS NOT NULL;

-- 4. Pedidos e Faturamento
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    status VARCHAR(20) NOT NULL,
    source VARCHAR(50) NOT NULL,
    external_id VARCHAR(255) NOT NULL,
    customer_name VARCHAR(255),
    customer_email VARCHAR(255),
    total_amount DECIMAL(19, 2) NOT NULL,
    version BIGINT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_external ON orders(external_id);
CREATE INDEX idx_orders_created_at ON orders(created_at);

CREATE TABLE order_items (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL,
    product_id UUID NOT NULL,
    variant_id UUID NOT NULL,
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(19, 2) NOT NULL,
    total_price DECIMAL(38, 2) NOT NULL DEFAULT 0,
    CONSTRAINT fk_order_items_order FOREIGN KEY (order_id) REFERENCES orders(id),
    CONSTRAINT fk_order_items_product FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT fk_order_items_variant FOREIGN KEY (variant_id) REFERENCES product_variants(id)
);

CREATE TABLE invoices (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL,
    external_invoice_id VARCHAR(100),
    status VARCHAR(50) NOT NULL,
    xml_url VARCHAR(500),
    pdf_url VARCHAR(500),
    issued_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT fk_invoices_order FOREIGN KEY (order_id) REFERENCES orders(id)
);
CREATE INDEX idx_invoices_order ON invoices(order_id);

-- 5. Media Assets
CREATE TABLE IF NOT EXISTS media_assets (
  id BIGSERIAL PRIMARY KEY,
  type VARCHAR(16) NOT NULL,
  storage_key VARCHAR(512) NOT NULL UNIQUE,
  original_filename VARCHAR(255),
  mime_type VARCHAR(128) NOT NULL,
  size_bytes BIGINT NOT NULL CHECK (size_bytes >= 0),
  checksum_sha256 VARCHAR(64),
  is_public BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_media_assets_type ON media_assets(type);
CREATE INDEX IF NOT EXISTS idx_media_assets_public ON media_assets(is_public);

-- 6. Tabela de Configuração do Sistema (Dynamic Config)
CREATE TABLE IF NOT EXISTS system_config (
    config_key VARCHAR(100) PRIMARY KEY,
    config_value VARCHAR(255),
    config_json JSONB
);

-- 7. Service Routing Rules e Providers (Logística e Integrações)
CREATE TABLE service_routing_rules (
    id UUID PRIMARY KEY,
    service_type VARCHAR(40) NOT NULL,
    provider_code VARCHAR(80) NOT NULL,
    enabled BOOLEAN NOT NULL,
    priority INT NOT NULL,
    match_json JSONB NOT NULL,
    behavior_json JSONB,
    updated_at TIMESTAMP NOT NULL
);

CREATE TABLE service_providers (
    id UUID PRIMARY KEY,
    service_type VARCHAR(40) NOT NULL,
    code VARCHAR(80) NOT NULL,
    name VARCHAR(160) NOT NULL,
    enabled BOOLEAN NOT NULL,
    priority INT NOT NULL,
    driver_key VARCHAR(160) NOT NULL,
    health_enabled BOOLEAN NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    CONSTRAINT ux_service_providers_type_code UNIQUE (service_type, code)
);

-- CORREÇÃO: version alterado de BIGINT para INTEGER para casar com Java (Integer)
CREATE TABLE service_provider_configs (
    id UUID PRIMARY KEY,
    provider_id UUID NOT NULL,
    environment VARCHAR(20) NOT NULL,
    config_json JSONB NOT NULL,
    secrets_ref VARCHAR(200),
    version INTEGER NOT NULL, 
    active BOOLEAN NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    CONSTRAINT fk_provider_config FOREIGN KEY (provider_id) REFERENCES service_providers(id)
);

--- ARQUIVO: ./src/main/resources/db/migration/V2__init_service_engine.sql ---
-- 2. Feature Flags (Mantido pois não existe no V1)
CREATE TABLE feature_flags (
    id          UUID PRIMARY KEY,
    flag_key    VARCHAR(100) NOT NULL UNIQUE,
    enabled     BOOLEAN DEFAULT false,
    value_json  TEXT,
    updated_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- As tabelas system_config, service_providers, configs e routing_rules
-- foram movidas para V1__init_schema.sql para atender validação inicial do JPA.

--- ARQUIVO: ./src/main/resources/db/migration/V1__init_schema.sql.bak.20260201_221342 ---
-- Extensão para UUIDs (Postgres)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 1. Usuários e Autenticação
CREATE TABLE users (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'USER',
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
CREATE INDEX idx_users_email ON users(email);

-- 2. Catálogo (Categorias, Produtos e Variantes)
CREATE TABLE categories (
    id UUID PRIMARY KEY,
    name VARCHAR(120) NOT NULL UNIQUE,
    active BOOLEAN NOT NULL
);

CREATE TABLE products (
    id UUID PRIMARY KEY,
    name VARCHAR(160) NOT NULL,
    description VARCHAR(2000) NOT NULL,
    price NUMERIC(19,2) NOT NULL,
    category_id UUID NOT NULL,
    active BOOLEAN NOT NULL,
    image_url VARCHAR(255),
    attributes JSONB DEFAULT '{}',
    alert_enabled BOOLEAN DEFAULT FALSE,
    stock_quantity INTEGER DEFAULT 0, -- Mantido para compatibilidade legado
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_products_category FOREIGN KEY (category_id) REFERENCES categories(id)
);
CREATE INDEX idx_products_attributes ON products USING GIN (attributes);

CREATE TABLE product_variants (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    sku VARCHAR(100) NOT NULL UNIQUE,
    gtin VARCHAR(20),
    stock_quantity INTEGER NOT NULL DEFAULT 0,
    price DECIMAL(19, 2),
    active BOOLEAN DEFAULT TRUE,
    attributes_json JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_variant_product FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX ux_product_variant_gtin ON product_variants(gtin) WHERE gtin IS NOT NULL;

CREATE TABLE product_integrations (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    integration_type VARCHAR(50) NOT NULL,
    external_id VARCHAR(255) NOT NULL,
    sku_external VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_pi_product FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT uk_integration_external UNIQUE (integration_type, external_id)
);

-- 3. Estoque
CREATE TABLE inventory_movements (
    id UUID PRIMARY KEY,
    product_id UUID NOT NULL,
    variant_id UUID NOT NULL, -- Coluna obrigatória para o novo modelo
    type VARCHAR(10) NOT NULL,
    quantity INTEGER NOT NULL,
    reason VARCHAR(255),
    reference_id VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_inventory_product FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT fk_inventory_variant FOREIGN KEY (variant_id) REFERENCES product_variants(id)
);
CREATE INDEX idx_inventory_product ON inventory_movements(product_id);
CREATE UNIQUE INDEX ux_inventory_idempotency ON inventory_movements (variant_id, type, reference_id) WHERE reference_id IS NOT NULL;

-- 4. Pedidos e Faturamento
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    status VARCHAR(20) NOT NULL,
    source VARCHAR(50) NOT NULL,
    external_id VARCHAR(255) NOT NULL,
    customer_name VARCHAR(255),
    customer_email VARCHAR(255),
    total_amount DECIMAL(19, 2) NOT NULL,
    version BIGINT DEFAULT 0, -- Optimistic Locking (@Version)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_external ON orders(external_id);
CREATE INDEX idx_orders_created_at ON orders(created_at);

CREATE TABLE order_items (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL,
    product_id UUID NOT NULL,
    variant_id UUID NOT NULL, -- Obrigatório agora
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(19, 2) NOT NULL,
    total_price DECIMAL(38, 2) NOT NULL DEFAULT 0,
    CONSTRAINT fk_order_items_order FOREIGN KEY (order_id) REFERENCES orders(id),
    CONSTRAINT fk_order_items_product FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT fk_order_items_variant FOREIGN KEY (variant_id) REFERENCES product_variants(id)
);

CREATE TABLE invoices (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL,
    external_invoice_id VARCHAR(100),
    status VARCHAR(50) NOT NULL,
    xml_url VARCHAR(500),
    pdf_url VARCHAR(500),
    issued_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT fk_invoices_order FOREIGN KEY (order_id) REFERENCES orders(id)
);
CREATE INDEX idx_invoices_order ON invoices(order_id);

-- V4: Media Assets (images/videos)
CREATE TABLE IF NOT EXISTS media_assets (
  id BIGSERIAL PRIMARY KEY,
  type VARCHAR(16) NOT NULL,                     -- IMAGE | VIDEO
  storage_key VARCHAR(512) NOT NULL UNIQUE,      -- e.g. media/uuid.ext
  original_filename VARCHAR(255),
  mime_type VARCHAR(128) NOT NULL,
  size_bytes BIGINT NOT NULL CHECK (size_bytes >= 0),
  checksum_sha256 VARCHAR(64),

  is_public BOOLEAN NOT NULL DEFAULT TRUE,

  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_media_assets_type ON media_assets(type);
CREATE INDEX IF NOT EXISTS idx_media_assets_public ON media_assets(is_public);

--- ARQUIVO: ./src/main/resources/application.yml ---
spring:
  application:
    name: ecommerce-core

  datasource:
    url: ${DB_URL:jdbc:postgresql://localhost:5432/ecommerce}
    username: ${DB_USER:postgres}
    password: ${DB_PASS:postgres}
    hikari:
      maximum-pool-size: ${DB_POOL_SIZE:20}
      minimum-idle: 5
      idle-timeout: 30000
      connection-timeout: 20000
      max-lifetime: 1800000

  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        format_sql: false
    open-in-view: false

  flyway:
    enabled: true
    locations: classpath:db/migration
    placeholders:
      PGCRYPTO_EXTENSION: 'CREATE EXTENSION IF NOT EXISTS "pgcrypto";'

# AQUI ESTÁ A CORREÇÃO: Mapeamento direto da ENV VAR.
# Se a env var não existir, o Spring lança erro no startup (correto).
WEBHOOK_SECRET: ${WEBHOOK_SECRET}

server:
  port: ${PORT:8080}
  forward-headers-strategy: native

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/EcommerceApplication.java ---
package com.atelie.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Classe principal da aplicação.
 * Responsável apenas por iniciar o Spring Boot.
 */
@SpringBootApplication
public class EcommerceApplication {

    public static void main(String[] args) {
        SpringApplication.run(EcommerceApplication.class, args);
    }

}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/health/HealthService.java ---
package com.atelie.ecommerce.application.service.health;

import org.springframework.stereotype.Service;

/**
 * HealthService.
 *
 * Serviço simples para healthcheck da aplicação.
 */
@Service
public class HealthService {

    /**
     * Retorna o status atual da aplicação.
     *
     * @return String com o status (ex: "OK")
     */
    public String getStatus() {
        return "OK";
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/category/CategoryService.java ---
package com.atelie.ecommerce.application.service.catalog.category;

import com.atelie.ecommerce.api.catalog.category.dto.CategoryResponse;
import com.atelie.ecommerce.api.catalog.category.dto.CreateCategoryRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryEntity;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Service
public class CategoryService {

    private final CategoryRepository repository;

    public CategoryService(CategoryRepository repository) {
        this.repository = repository;
    }

    public CategoryResponse create(CreateCategoryRequest request) {
        boolean exists = repository.findAll().stream()
                .anyMatch(c -> c.getName().equalsIgnoreCase(request.getName()));

        if (exists) {
            throw new ConflictException("Category already exists");
        }

        CategoryEntity entity = new CategoryEntity();
        entity.setId(UUID.randomUUID());
        entity.setName(request.getName());
        entity.setActive(request.getActive());

        repository.save(entity);

        return new CategoryResponse(entity.getId(), entity.getName(), entity.getActive());
    }

    public List<CategoryResponse> list() {
        return repository.findAll().stream()
                .map(c -> new CategoryResponse(c.getId(), c.getName(), c.getActive()))
                .toList();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/product/ProductService.java ---
package com.atelie.ecommerce.application.service.catalog.product;

import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.domain.catalog.event.ProductSavedEvent;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryEntity;
import com.atelie.ecommerce.infrastructure.persistence.category.CategoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity; // Import
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository; // Import
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
public class ProductService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final ProductVariantRepository variantRepository; // New dependency
    private final GtinGeneratorService gtinGenerator;         // New dependency
    private final ApplicationEventPublisher eventPublisher;

    public ProductService(ProductRepository productRepository,
                          CategoryRepository categoryRepository,
                          ProductVariantRepository variantRepository,
                          GtinGeneratorService gtinGenerator,
                          ApplicationEventPublisher eventPublisher) {
        this.productRepository = productRepository;
        this.categoryRepository = categoryRepository;
        this.variantRepository = variantRepository;
        this.gtinGenerator = gtinGenerator;
        this.eventPublisher = eventPublisher;
    }

    @Transactional(readOnly = true)
    public ProductEntity findById(UUID id) {
        return productRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Product not found with ID: " + id));
    }

    @Transactional
    public ProductEntity saveProduct(ProductEntity product, UUID categoryId) {
        CategoryEntity category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new NotFoundException("Category not found with ID: " + categoryId));
        product.setCategory(category);
        
        boolean isNew = product.getId() == null;
        if (isNew) {
            product.setId(UUID.randomUUID()); // Ensure ID is generated before saving variant
        }

        ProductEntity saved = productRepository.save(product);

        // --- CRITICAL FIX: Create Default Variant for New Products ---
        if (isNew) {
            createDefaultVariant(saved);
        }

        eventPublisher.publishEvent(new ProductSavedEvent(saved.getId(), isNew));
        return saved;
    }

    private void createDefaultVariant(ProductEntity product) {
        ProductVariantEntity defaultVariant = ProductVariantEntity.builder()
                .product(product)
                .sku("SKU-" + product.getId().toString().substring(0, 8).toUpperCase())
                .gtin(gtinGenerator.generateInternalEan13())
                .price(null) // Null means "inherit from parent"
                .stockQuantity(product.getStockQuantity() != null ? product.getStockQuantity() : 0)
                .active(true)
                .attributesJson("{\"default\": true}")
                .build();
        
        variantRepository.save(defaultVariant);
    }

    @Transactional(readOnly = true)
    public Page<ProductEntity> getAllActiveProducts(Pageable pageable) {
        return productRepository.findByActiveTrue(pageable);
    }
}
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/product/GtinGeneratorService.java ---
package com.atelie.ecommerce.application.service.catalog.product;

import org.springframework.stereotype.Service;
import java.util.Random;

@Service
public class GtinGeneratorService {

    private final Random random = new Random();

    /**
     * Gera um EAN-13 válido iniciado com '2' (Uso interno/Restrito).
     * Formato: 2 + 11 dígitos aleatórios + Dígito Verificador.
     */
    public String generateInternalEan13() {
        StringBuilder sb = new StringBuilder("2"); // Prefixo interno comum
        for (int i = 0; i < 11; i++) {
            sb.append(random.nextInt(10));
        }
        String codeWithoutDigit = sb.toString();
        int checkDigit = calculateCheckDigit(codeWithoutDigit);
        return codeWithoutDigit + checkDigit;
    }

    private int calculateCheckDigit(String code) {
        int sum = 0;
        for (int i = 0; i < code.length(); i++) {
            int digit = Character.getNumericValue(code.charAt(i));
            if (i % 2 == 0) { // Par (0-index, na spec é ímpar) -> x1
                sum += digit;
            } else { // Ímpar (0-index, na spec é par) -> x3
                sum += digit * 3;
            }
        }
        int remainder = sum % 10;
        return (remainder == 0) ? 0 : 10 - remainder;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/product/ProductIntegrationService.java ---
package com.atelie.ecommerce.application.service.catalog.product;

import com.atelie.ecommerce.api.catalog.product.dto.LinkIntegrationRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductIntegrationRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductIntegrationEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.UUID;

@Service
public class ProductIntegrationService {

    private final ProductRepository productRepository;
    private final ProductIntegrationRepository integrationRepository;

    public ProductIntegrationService(ProductRepository productRepository, ProductIntegrationRepository integrationRepository) {
        this.productRepository = productRepository;
        this.integrationRepository = integrationRepository;
    }

    @Transactional
    public void linkProduct(UUID productId, LinkIntegrationRequest request) {
        ProductEntity product = productRepository.findById(productId)
                .orElseThrow(() -> new NotFoundException("Product not found"));

        if (integrationRepository.findByExternalIdAndIntegrationType(request.externalId(), request.integrationType()).isPresent()) {
            throw new ConflictException("External ID " + request.externalId() + " already linked for type " + request.integrationType());
        }

        ProductIntegrationEntity link = new ProductIntegrationEntity(
                product,
                request.integrationType().toUpperCase(), // Padroniza
                request.externalId(),
                request.skuExternal()
        );
        integrationRepository.save(link);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/catalog/product/ProductVariantService.java ---
package com.atelie.ecommerce.application.service.catalog.product;

import com.atelie.ecommerce.api.catalog.product.dto.CreateVariantRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;

@Service
public class ProductVariantService {

    private final ProductRepository productRepository;
    private final ProductVariantRepository variantRepository;
    private final GtinGeneratorService gtinGenerator;

    public ProductVariantService(ProductRepository productRepository, 
                                 ProductVariantRepository variantRepository,
                                 GtinGeneratorService gtinGenerator) {
        this.productRepository = productRepository;
        this.variantRepository = variantRepository;
        this.gtinGenerator = gtinGenerator;
    }

    @Transactional
    public ProductVariantEntity create(UUID productId, CreateVariantRequest request) {
        ProductEntity product = productRepository.findById(productId)
                .orElseThrow(() -> new NotFoundException("Produto pai não encontrado"));

        if (variantRepository.existsBySku(request.sku())) {
            throw new ConflictException("SKU já existe: " + request.sku());
        }

        // Gera GTIN automático se não vier no request
        String gtin = (request.gtin() == null || request.gtin().isBlank()) 
                ? gtinGenerator.generateInternalEan13() 
                : request.gtin();

        ProductVariantEntity variant = ProductVariantEntity.builder()
                .product(product)
                .sku(request.sku())
                .gtin(gtin)
                .price(request.price()) // Pode ser null (usa do pai)
                .stockQuantity(request.initialStock())
                .attributesJson(request.attributesJson()) // Ex: {"cor":"azul"}
                .active(true)
                .build();

        return variantRepository.save(variant);
    }

    public List<ProductVariantEntity> listByProduct(UUID productId) {
        return variantRepository.findByProductId(productId);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/auth/AuthService.java ---
package com.atelie.ecommerce.application.service.auth;

import com.atelie.ecommerce.api.auth.dto.LoginRequest;
import com.atelie.ecommerce.api.auth.dto.RegisterRequest;
import com.atelie.ecommerce.api.common.exception.ConflictException;
import com.atelie.ecommerce.infrastructure.persistence.auth.UserRepository;
import com.atelie.ecommerce.infrastructure.persistence.auth.entity.UserEntity;
import com.atelie.ecommerce.infrastructure.security.TokenProvider;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AuthService {

    private final AuthenticationManager authenticationManager;
    private final TokenProvider tokenProvider;
    private final PasswordEncoder passwordEncoder;
    private final UserRepository userRepository;

    public AuthService(AuthenticationManager authenticationManager, 
                       TokenProvider tokenProvider, 
                       PasswordEncoder passwordEncoder,
                       UserRepository userRepository) {
        this.authenticationManager = authenticationManager;
        this.tokenProvider = tokenProvider;
        this.passwordEncoder = passwordEncoder;
        this.userRepository = userRepository;
    }

    public String login(LoginRequest request) {
        // Autentica e gera o token usando o objeto de autenticação completo (mais seguro)
        Authentication auth = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword())
        );
        return tokenProvider.generateToken(auth);
    }

    @Transactional
    public void register(RegisterRequest request) {
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new ConflictException("E-mail já cadastrado no sistema.");
        }

        UserEntity newUser = new UserEntity(
            request.getName(),
            request.getEmail(),
            passwordEncoder.encode(request.getPassword()),
            "USER"
        );
        userRepository.save(newUser);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/inventory/InventoryService.java ---
package com.atelie.ecommerce.application.service.inventory;

import com.atelie.ecommerce.domain.inventory.MovementType;
import com.atelie.ecommerce.domain.inventory.event.InventoryChangedEvent;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import com.atelie.ecommerce.infrastructure.persistence.inventory.InventoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.inventory.entity.InventoryMovementEntity;
import com.atelie.ecommerce.api.common.exception.NotFoundException;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
public class InventoryService {

    private final InventoryRepository inventoryRepository;
    private final ProductVariantRepository variantRepository; // Agora usa VariantRepo
    private final ApplicationEventPublisher eventPublisher;

    public InventoryService(InventoryRepository inventoryRepository, 
                            ProductVariantRepository variantRepository,
                            ApplicationEventPublisher eventPublisher) {
        this.inventoryRepository = inventoryRepository;
        this.variantRepository = variantRepository;
        this.eventPublisher = eventPublisher;
    }

    @Transactional(readOnly = true)
    public Integer getStock(UUID variantId) {
        return variantRepository.findById(variantId)
                .map(ProductVariantEntity::getStockQuantity)
                .orElseThrow(() -> new NotFoundException("Variant not found"));
    }

    @Transactional
    public void addMovement(UUID variantId, MovementType type, Integer quantity, String reason, String refId) {
        ProductVariantEntity variant = variantRepository.findById(variantId)
                .orElseThrow(() -> new NotFoundException("Variant not found"));

        if (type == MovementType.OUT) {
            int rowsUpdated = variantRepository.decrementStock(variantId, quantity);
            if (rowsUpdated == 0) {
                throw new IllegalArgumentException("Estoque insuficiente para a variante: " + variant.getSku());
            }
        } else if (type == MovementType.IN) {
            variantRepository.incrementStock(variantId, quantity);
        }

        // Registra histórico (InventoryMovementEntity precisará ser atualizado para ter variant)
        // Por compatibilidade com o código antigo, estamos setando o produto pai
        InventoryMovementEntity movement = new InventoryMovementEntity();
        movement.setId(UUID.randomUUID());
        movement.setProduct(variant.getProduct());
        movement.setVariantId(variant.getId()); // Campo novo
        movement.setType(type);
        movement.setQuantity(quantity);
        movement.setReason(reason);
        movement.setReferenceId(refId);
        
        inventoryRepository.save(movement);

        Integer newBalance = variantRepository.findById(variantId)
                .orElseThrow(() -> new com.atelie.ecommerce.api.common.exception.NotFoundException("Variant not found"))
                .getStockQuantity();
        // Publica evento usando o ID do produto pai para listeners de vitrine, mas o saldo é da variante
        eventPublisher.publishEvent(new InventoryChangedEvent(variant.getProduct().getId(), newBalance));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/file/FileStorageService.java ---
package com.atelie.ecommerce.application.service.file;

import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.*;
import java.util.List;
import java.util.UUID;

/**
 * FileStorageService
 *
 * Regras de segurança:
 * - Bloqueia upload vazio
 * - Limita tamanho máximo (default 5MB)
 * - Permite apenas extensões conhecidas
 * - Gera nome novo (UUID) para impedir path traversal/colisão
 */
@Service
public class FileStorageService {

    private static final long MAX_FILE_SIZE_BYTES = 5L * 1024L * 1024L; // 5MB
    private static final List<String> ALLOWED_EXTENSIONS = List.of("jpg", "jpeg", "png", "webp", "gif");

    private final Path root = Paths.get("./uploads");

    public FileStorageService() {
        try {
            Files.createDirectories(root);
        } catch (IOException e) {
            throw new IllegalStateException("Não foi possível inicializar a pasta de upload.", e);
        }
    }

    public String save(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("Arquivo inválido (vazio).");
        }
        if (file.getSize() > MAX_FILE_SIZE_BYTES) {
            throw new IllegalArgumentException("Arquivo excede o tamanho máximo permitido (5MB).");
        }

        String originalFilename = file.getOriginalFilename();
        String extension = getExtension(originalFilename).toLowerCase();

        if (!ALLOWED_EXTENSIONS.contains(extension)) {
            throw new SecurityException("Tipo de arquivo não permitido: " + extension);
        }

        String filename = UUID.randomUUID() + "." + extension;
        Path destination = root.resolve(filename).normalize();

        // Garante que o arquivo final está dentro de /uploads
        if (!destination.startsWith(root.normalize())) {
            throw new SecurityException("Caminho de upload inválido.");
        }

        try (InputStream in = file.getInputStream()) {
            Files.copy(in, destination, StandardCopyOption.REPLACE_EXISTING);
            return filename;
        } catch (IOException e) {
            throw new IllegalStateException("Falha ao salvar arquivo.", e);
        }
    }

    private String getExtension(String filename) {
        if (filename == null) return "";
        int i = filename.lastIndexOf('.');
        return i > 0 ? filename.substring(i + 1) : "";
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/fiscal/InvoiceService.java ---
package com.atelie.ecommerce.application.service.fiscal;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import java.util.Map;
import java.util.UUID;

@Service
@lombok.extern.slf4j.Slf4j
public class InvoiceService {

    private final DynamicConfigService configService;
    private final RestTemplate restTemplate;

    public InvoiceService(DynamicConfigService configService, RestTemplate restTemplate) {
        this.configService = configService;
        this.restTemplate = restTemplate;
    }

    public void emitInvoiceForOrder(UUID orderId) {
        String webhookUrl = configService.getString("FISCAL_WEBHOOK_URL");
        
        if (webhookUrl == null || webhookUrl.isBlank()) {
            log.info("Emissão de NFe ignorada: URL de webhook fiscal não configurada no Dashboard.");
            return;
        }

        try {
            // Dispara um POST simples para o integrador fiscal (Bling, Tiny, eNotas)
            // O payload é genérico, o integrador lá na ponta que se vire para buscar os dados do pedido
            Map<String, Object> payload = Map.of(
                "event", "ORDER_APPROVED",
                "order_id", orderId.toString()
            );
            
            restTemplate.postForLocation(webhookUrl, payload);
            log.info("Solicitação de NFe enviada para: {}", webhookUrl);

        } catch (Exception e) {
            log.error("Falha ao chamar webhook fiscal", e);
        }
    }
}
