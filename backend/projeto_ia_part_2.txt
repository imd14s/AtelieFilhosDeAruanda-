
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/order/OrderService.java ---
package com.atelie.ecommerce.application.service.order;

import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.api.order.dto.CreateOrderItemRequest;
import com.atelie.ecommerce.api.order.dto.CreateOrderRequest;
import com.atelie.ecommerce.application.service.inventory.InventoryService;
import com.atelie.ecommerce.domain.inventory.MovementType;
import com.atelie.ecommerce.domain.order.OrderStatus;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderEntity;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderItemEntity;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantRepository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Service
public class OrderService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final ProductVariantRepository variantRepository;
    private final InventoryService inventoryService;

    public OrderService(OrderRepository orderRepository,
                        ProductRepository productRepository,
                        ProductVariantRepository variantRepository,
                        InventoryService inventoryService) {
        this.orderRepository = orderRepository;
        this.productRepository = productRepository;
        this.variantRepository = variantRepository;
        this.inventoryService = inventoryService;
    }

    @Transactional
    public OrderEntity createOrder(CreateOrderRequest request) {
        OrderEntity order = new OrderEntity();
        order.setId(UUID.randomUUID());
        order.setSource(request.source());
        order.setExternalId(request.externalId() != null ? request.externalId() : order.getId().toString());
        order.setCustomerName(request.customerName());
        order.setStatus(OrderStatus.PENDING.name());
        order.setCreatedAt(Instant.now());
        
        List<OrderItemEntity> items = new ArrayList<>();
        BigDecimal totalOrder = BigDecimal.ZERO;

        for (CreateOrderItemRequest itemReq : request.items()) {
            ProductEntity product = productRepository.findById(itemReq.productId())
                    .orElseThrow(() -> new NotFoundException("Product not found: " + itemReq.productId()));

            if (Boolean.FALSE.equals(product.getActive())) {
                throw new IllegalStateException("O produto '" + product.getName() + "' não está mais disponível.");
            }

            // --- CORREÇÃO DA LÓGICA DE VARIANTE ---
            UUID targetVariantId = itemReq.variantId();
            ProductVariantEntity variant;

            if (targetVariantId != null) {
                // Captura o ID em variável final para usar na lambda
                final UUID lookupId = targetVariantId;
                variant = variantRepository.findById(targetVariantId)
                    .orElseThrow(() -> new NotFoundException("Variante não encontrada: " + lookupId));
            } else {
                // Fallback: Tenta achar a variante default criada na migração
                var variants = variantRepository.findByProductId(product.getId());
                if (!variants.isEmpty()) {
                    variant = variants.get(0); // Pega a primeira/default
                    targetVariantId = variant.getId(); // Atualiza o ID alvo
                } else {
                    throw new IllegalStateException("Produto sem variantes cadastradas. Impossível baixar estoque.");
                }
            }

            // Baixa estoque na VARIANTE correta
            inventoryService.addMovement(
                    targetVariantId,
                    MovementType.OUT,
                    itemReq.quantity(),
                    "Sale Order " + order.getId(),
                    order.getId().toString()
            );

            // Preço: Usa o da variante se existir, senão usa do produto pai
            BigDecimal finalPrice = (variant.getPrice() != null) ? variant.getPrice() : product.getPrice();
            BigDecimal itemTotal = finalPrice.multiply(new BigDecimal(itemReq.quantity()));
            totalOrder = totalOrder.add(itemTotal);

            OrderItemEntity itemEntity = new OrderItemEntity();
            itemEntity.setId(UUID.randomUUID());
            itemEntity.setOrder(order);
            itemEntity.setProduct(product);
            itemEntity.setVariant(variant);
            itemEntity.setQuantity(itemReq.quantity());
            itemEntity.setUnitPrice(finalPrice);
            itemEntity.setTotalPrice(itemTotal);
            
            items.add(itemEntity);
        }

        order.setTotalAmount(totalOrder);
        order.setItems(items);
        return orderRepository.save(order);
    }
    
    @Transactional
    public void approveOrder(UUID orderId) {
        OrderEntity order = orderRepository.findById(orderId)
            .orElseThrow(() -> new NotFoundException("Pedido não encontrado"));
        
        if (!OrderStatus.PENDING.name().equals(order.getStatus())) {
             throw new IllegalStateException("Pedido não está pendente");
        }
        order.setStatus(OrderStatus.PAID.name());
        orderRepository.save(order);
    }
    
    @Transactional
    public void cancelOrder(UUID orderId, String reason) {
        OrderEntity order = orderRepository.findById(orderId)
            .orElseThrow(() -> new NotFoundException("Pedido não encontrado"));
            
        // Se já foi pago ou enviado, lógica de estorno seria necessária (simplificado aqui)
        if (OrderStatus.CANCELED.name().equals(order.getStatus())) return;

        // Estorno de estoque
        for (OrderItemEntity item : order.getItems()) {
             UUID variantId = item.getVariant() != null ? item.getVariant().getId() : null;
             if (variantId != null) {
                 inventoryService.addMovement(variantId, MovementType.IN, item.getQuantity(), "Order Cancelled: " + reason, orderId.toString());
             }
        }

        order.setStatus(OrderStatus.CANCELED.name());
        orderRepository.save(order);
    }

    public Page<OrderEntity> getAllOrders(Pageable pageable) {
        return orderRepository.findAll(pageable);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/payment/PaymentController.java ---
package com.atelie.ecommerce.application.service.payment;

import com.atelie.ecommerce.api.payment.dto.PaymentResponse;
import com.atelie.ecommerce.application.service.payment.dto.CreatePixPaymentRequest;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/payments")
public class PaymentController {

    private final PaymentService paymentService;

    public PaymentController(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @PostMapping("/pix")
    public ResponseEntity<PaymentResponse> createPayment(@Valid @RequestBody CreatePixPaymentRequest req) {
        PaymentResponse response = paymentService.createPixPayment(
                req.orderId(),
                req.email(),
                req.cpf(),
                req.amount()
        );
        return ResponseEntity.ok(response);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/payment/PaymentService.java ---
package com.atelie.ecommerce.application.service.payment;

import com.atelie.ecommerce.api.payment.dto.PaymentResponse;
import com.atelie.ecommerce.api.serviceengine.ServiceOrchestrator;
import com.atelie.ecommerce.api.serviceengine.ServiceResult;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
public class PaymentService {

    private final ServiceOrchestrator orchestrator;

    @Value("${spring.profiles.active:prod}")
    private String activeProfile;

    public PaymentService(ServiceOrchestrator orchestrator) {
        this.orchestrator = orchestrator;
    }

    public PaymentResponse createPixPayment(UUID orderId, String email, String cpf, BigDecimal amount) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new RuntimeException("Valor do pagamento deve ser maior que zero");
        }

        Map<String, Object> request = new HashMap<>();
        request.put("orderId", orderId.toString());
        request.put("email", email);
        request.put("cpf", cpf);
        request.put("amount", amount);
        request.put("method", "PIX");

        ServiceResult result = orchestrator.execute(ServiceType.PAYMENT, request, activeProfile);

        if (!result.success()) {
            throw new RuntimeException("Falha no pagamento: " + result.payload().getOrDefault("error", "Erro desconhecido"));
        }

        Map<String, Object> payload = result.payload();
        
        return new PaymentResponse(
            (String) payload.getOrDefault("status", "UNKNOWN"),
            (String) payload.getOrDefault("provider", "UNKNOWN"),
            amount,
            Boolean.TRUE.equals(payload.get("sandbox")),
            payload
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/payment/dto/CreatePixPaymentRequest.java ---
package com.atelie.ecommerce.application.service.payment.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

import java.math.BigDecimal;
import java.util.UUID;

public record CreatePixPaymentRequest(
        @NotNull UUID orderId,
        @NotBlank @Email String email,
        @NotBlank String cpf,
        @NotNull @Positive BigDecimal amount
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/ai/AiContentService.java ---
package com.atelie.ecommerce.application.service.ai;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.application.service.file.FileStorageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.Files;
import java.util.Map;
import java.util.UUID;

@Service
@lombok.extern.slf4j.Slf4j
public class AiContentService {

    private final DynamicConfigService configService;
    private final RestTemplate restTemplate;
    
    // Caminho físico onde o FileStorageService salva
    private final Path uploadRoot = Paths.get("./uploads");

    public AiContentService(DynamicConfigService configService, RestTemplate restTemplate) {
        this.configService = configService;
        this.restTemplate = restTemplate;
    }

    public String generateDescription(String productName, String context) {
        if (!configService.containsKey("AI_ENABLED") || !configService.requireBoolean("AI_ENABLED")) {
            return "Descrição automática (IA Desativada): " + productName;
        }

        String apiUrl = configService.getString("AI_API_URL");
        String apiKey = configService.getString("AI_API_KEY");
        String model = configService.getString("AI_MODEL");
        String promptTemplate = configService.getString("AI_PROMPT_TEMPLATE_DESC");
        
        if (apiUrl == null || apiKey == null) return "Erro de Configuração de IA";

        String finalPrompt = promptTemplate
                .replace("{product}", productName)
                .replace("{context}", context != null ? context : "");

        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.setBearerAuth(apiKey);

            Map<String, Object> message = Map.of("role", "user", "content", finalPrompt);
            Map<String, Object> body = Map.of(
                "model", model,
                "messages", new Object[]{ message },
                "temperature", 0.7
            );

            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(body, headers);
            Map response = restTemplate.postForObject(apiUrl, entity, Map.class);
            return extractContent(response);

        } catch (Exception e) {
            log.error("Erro ao chamar IA", e);
            return "Erro na geração: " + e.getMessage();
        }
    }

    public String removeImageBackground(String filename) {
        // 1. Verificação de Configuração
        if (!configService.containsKey("AI_REMOVE_BG_ENABLED") || !configService.requireBoolean("AI_REMOVE_BG_ENABLED")) {
            log.info("Remoção de fundo desativada no Dashboard.");
            return filename; // Retorna original
        }

        String apiKey = configService.getString("AI_REMOVE_BG_API_KEY");
        String apiUrl = configService.getString("AI_REMOVE_BG_URL");

        if (apiKey == null || apiKey.isBlank()) {
            log.error("API Key do Remove.bg não configurada.");
            return filename;
        }

        try {
            // 2. Localizar arquivo no disco
            Path sourcePath = uploadRoot.resolve(filename);
            if (!Files.exists(sourcePath)) {
                throw new RuntimeException("Arquivo original não encontrado: " + filename);
            }

            // 3. Preparar Multipart Request
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.MULTIPART_FORM_DATA);
            headers.set("X-Api-Key", apiKey);

            MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
            body.add("image_file", new FileSystemResource(sourcePath));
            body.add("size", "auto");

            HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

            // 4. Chamada Real à API
            log.info("Enviando imagem {} para Remove.bg...", filename);
            ResponseEntity<byte[]> response = restTemplate.exchange(
                    apiUrl,
                    HttpMethod.POST,
                    requestEntity,
                    byte[].class
            );

            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                // 5. Salvar Nova Imagem (No-BG)
                String newFilename = "no-bg-" + UUID.randomUUID() + ".png";
                Path destPath = uploadRoot.resolve(newFilename);
                Files.write(destPath, response.getBody());
                
                log.info("Fundo removido com sucesso. Salvo em: {}", newFilename);
                return newFilename;
            } else {
                log.error("Erro API Remove.bg: {}", response.getStatusCode());
                return filename; // Fallback
            }

        } catch (Exception e) {
            log.error("Falha crítica na remoção de fundo", e);
            return filename; // Fallback para não quebrar o fluxo
        }
    }

    private String extractContent(Map response) {
        try {
            java.util.List choices = (java.util.List) response.get("choices");
            Map first = (Map) choices.get(0);
            Map msg = (Map) first.get("message");
            return (String) msg.get("content");
        } catch (Exception e) {
            return "Conteúdo gerado, mas erro no parse.";
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/service/integration/N8nService.java ---
package com.atelie.ecommerce.application.service.integration;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import java.util.HashMap;
import java.util.Map;

@Service
@lombok.extern.slf4j.Slf4j
public class N8nService {

    private final RestTemplate restTemplate;
    private final DynamicConfigService configService;

    private static final String N8N_URL_KEY = "N8N_WEBHOOK_URL";
    private static final String N8N_ENABLED_KEY = "N8N_Automation_Enabled";

    public N8nService(RestTemplate restTemplate, DynamicConfigService configService) {
        this.restTemplate = restTemplate;
        this.configService = configService;
    }

    public boolean isAutomationEnabled() {
        if (!configService.containsKey(N8N_ENABLED_KEY)) return false;
        return configService.requireBoolean(N8N_ENABLED_KEY);
    }

    public void sendLowStockAlert(String productName, Integer currentStock, int threshold) {
        if (!isAutomationEnabled()) return;

        try {
            String url = configService.requireString(N8N_URL_KEY);
            Map<String, Object> payload = new HashMap<>();
            payload.put("event", "LOW_STOCK_ALERT");
            payload.put("product", productName);
            payload.put("stock", currentStock);
            payload.put("threshold", threshold);
            payload.put("message", "Produto " + productName + " crítico!");

            restTemplate.postForEntity(url, payload, String.class);
            log.info("N8N Alert Sent: Product={} Stock={}", productName, currentStock);
        } catch (Exception e) {
            log.error("Failed to send N8N alert", e);
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/listener/StockSyncListener.java ---
package com.atelie.ecommerce.application.listener;

import com.atelie.ecommerce.domain.inventory.event.InventoryChangedEvent;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductIntegrationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

@Component
public class StockSyncListener {

    private static final Logger log = LoggerFactory.getLogger(StockSyncListener.class);
    private final ProductIntegrationRepository integrationRepository;

    public StockSyncListener(ProductIntegrationRepository integrationRepository) {
        this.integrationRepository = integrationRepository;
    }

    // CORREÇÃO: TransactionalEventListener garante que só executamos se o banco confirmou a transação.
    // O @Async garante que não travamos a thread original após o commit.
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleInventoryChange(InventoryChangedEvent event) {
        var links = integrationRepository.findByProductId(event.productId());
        if (links.isEmpty()) {
            return;
        }

        links.forEach(link -> {
             log.info("SYNC [CONFIRMADO]: Enviando update para {}. Produto: {}, Novo Saldo: {}", 
                     link.getIntegrationType(), 
                     link.getExternalId(), 
                     event.newQuantity());
             // Lógica de envio HTTP
        });
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/listener/MultichannelSyncListener.java ---
package com.atelie.ecommerce.application.listener;

import com.atelie.ecommerce.application.integration.mercadolivre.MercadoLivreService;
import com.atelie.ecommerce.domain.catalog.event.ProductSavedEvent;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

@Component
@lombok.extern.slf4j.Slf4j
public class MultichannelSyncListener {

    private final ProductRepository productRepository;
    private final MercadoLivreService mercadoLivreService;

    public MultichannelSyncListener(ProductRepository productRepository, 
                                    MercadoLivreService mercadoLivreService) {
        this.productRepository = productRepository;
        this.mercadoLivreService = mercadoLivreService;
    }

    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void onProductSaved(ProductSavedEvent event) {
        productRepository.findById(event.productId()).ifPresent(product -> {
            // Lógica REAL de Sincronia
            if (event.isNew()) {
                log.info("MULTICHANNEL: Tentando criar anúncio no Mercado Livre para: {}", product.getName());
                // Chamada REAL (Controlada por flag no Dashboard dentro do Service)
                mercadoLivreService.createListing(product);
            } else {
                log.info("MULTICHANNEL: Produto atualizado (Sync de estoque/preço pendente em futura implementação).");
            }
        });
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/integration/MarketplaceIntegrationService.java ---
package com.atelie.ecommerce.application.integration;



import com.atelie.ecommerce.api.order.dto.CreateOrderRequest;

public interface MarketplaceIntegrationService {
    /**
     * Recebe um ID de notificação/recurso externo, busca os detalhes na loja
     * e converte para nosso formato de pedido interno.
     */
    CreateOrderRequest fetchAndConvertOrder(String resourceId);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/application/integration/mercadolivre/MercadoLivreService.java ---
package com.atelie.ecommerce.application.integration.mercadolivre;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.api.order.dto.CreateOrderItemRequest;
import com.atelie.ecommerce.api.order.dto.CreateOrderRequest;
import com.atelie.ecommerce.application.integration.MarketplaceIntegrationService;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductIntegrationEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductIntegrationRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.fasterxml.jackson.databind.JsonNode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.env.Environment;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@lombok.extern.slf4j.Slf4j
public class MercadoLivreService implements MarketplaceIntegrationService {

    private final ProductIntegrationRepository integrationRepository;
    private final DynamicConfigService configService;
    private final RestTemplate restTemplate;
    private final Environment env;

    public MercadoLivreService(ProductIntegrationRepository integrationRepository,
                               DynamicConfigService configService,
                               RestTemplate restTemplate,
                               Environment env) {
        this.integrationRepository = integrationRepository;
        this.configService = configService;
        this.restTemplate = restTemplate;
        this.env = env;
    }

    private String mlBaseUrl() {
        // CORREÇÃO: Removido fallback hardcoded. Deve estar no .env como ML_API_BASE_URL
        String url = env.getProperty("ML_API_BASE_URL");
        if (url == null || url.isBlank()) {
            throw new IllegalStateException("Configuração ML_API_BASE_URL ausente no ambiente!");
        }
        return url.trim();
    }

    private String mlDefaultCategory() {
        return env.getProperty("ML_CATEGORY_DEFAULT", "MLB3530").trim();
    }

    @Override
    @Transactional(readOnly = true)
    public CreateOrderRequest fetchAndConvertOrder(String resourceId) {
        if (!configService.containsKey("ML_SYNC_ENABLED") || !configService.requireBoolean("ML_SYNC_ENABLED")) {
            return null;
        }

        String token = configService.requireString("ML_ACCESS_TOKEN");
        String url = mlBaseUrl() + "/orders/" + resourceId;
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setBearerAuth(token);
            HttpEntity<String> entity = new HttpEntity<>(headers);

            ResponseEntity<JsonNode> response = restTemplate.exchange(url, HttpMethod.GET, entity, JsonNode.class);
            JsonNode orderJson = response.getBody();
            if (orderJson == null) throw new RuntimeException("Empty response from ML");

            JsonNode orderItems = orderJson.path("order_items");
            if (orderItems.isEmpty()) throw new IllegalStateException("ML Order without items: " + resourceId);

            JsonNode firstItem = orderItems.get(0);
            String mlItemId = firstItem.path("item").path("id").asText();
            int quantity = firstItem.path("quantity").asInt(1);

            var integration = integrationRepository
                .findByExternalIdAndIntegrationType(mlItemId, "MERCADO_LIVRE")
                .orElseThrow(() -> new IllegalArgumentException("Produto não vinculado para item ML: " + mlItemId));
            String customerName = orderJson.path("buyer").path("nickname").asText("Desconhecido");

            return new CreateOrderRequest(
                "MERCADO_LIVRE",
                resourceId,
                customerName,
                List.of(new CreateOrderItemRequest(integration.getProduct().getId(), null, quantity))
            );
        } catch (Exception e) {
            log.error("Erro integration fetch ML", e);
            throw new RuntimeException("Erro ML Fetch", e);
        }
    }

    public void createListing(ProductEntity product) {
        if (!configService.containsKey("ML_SYNC_ENABLED") || !configService.requireBoolean("ML_SYNC_ENABLED")) {
            log.info("Sync Mercado Livre desativado no Dashboard. Ignorando produto: {}", product.getName());
            return;
        }

        String token = configService.requireString("ML_ACCESS_TOKEN");
        String url = mlBaseUrl() + "/items";
        Map<String, Object> payload = new HashMap<>();
        payload.put("title", product.getName());
        payload.put("category_id", mlDefaultCategory());
        payload.put("price", product.getPrice());
        payload.put("currency_id", "BRL");
        payload.put("available_quantity", product.getStockQuantity());
        payload.put("buying_mode", "buy_it_now");
        payload.put("condition", "new");
        payload.put("listing_type_id", "gold_special");

        if (product.getImageUrl() != null && product.getImageUrl().startsWith("http")) {
            payload.put("pictures", List.of(Map.of("source", product.getImageUrl())));
        }

        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.setBearerAuth(token);

            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(payload, headers);
            ResponseEntity<JsonNode> response = restTemplate.postForEntity(url, entity, JsonNode.class);
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                String mlId = response.getBody().get("id").asText();
                String permalink = response.getBody().get("permalink").asText();
                log.info("Anúncio criado no ML com sucesso! ID: {}, Link: {}", mlId, permalink);
                saveIntegrationLink(product, mlId);
            }
        } catch (Exception e) {
            log.error("Falha ao criar anúncio no ML. Verifique Token/Permissões.", e);
        }
    }

    private void saveIntegrationLink(ProductEntity product, String externalId) {
        if (integrationRepository.findByExternalIdAndIntegrationType(externalId, "MERCADO_LIVRE").isEmpty()) {
            ProductIntegrationEntity link = new ProductIntegrationEntity(
                product, "MERCADO_LIVRE", externalId, null
            );
            integrationRepository.save(link);
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/auth/UserRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.auth;

import com.atelie.ecommerce.infrastructure.persistence.auth.entity.UserEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface UserRepository extends JpaRepository<UserEntity, UUID> {
    Optional<UserEntity> findByEmail(String email);
    boolean existsByEmail(String email);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/auth/entity/UserEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.auth.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "users")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {

    @Id
    private UUID id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;
    
    @Column(nullable = false)
    private String role; // USER, ADMIN

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "active")
    private Boolean active;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // --- CONSTRUTOR DE COMPATIBILIDADE (Resgate) ---
    // Necessário para AuthService e AdminBootstrap funcionarem sem refatoração profunda
    public UserEntity(String name, String email, String password, String role) {
        this.name = name;
        this.email = email;
        this.password = password;
        this.role = role;
    }

    @PrePersist
    protected void onCreate() {
        if (id == null) id = UUID.randomUUID();
        if (createdAt == null) createdAt = LocalDateTime.now();
        if (updatedAt == null) updatedAt = LocalDateTime.now();
        if (role == null) role = "USER";
        if (active == null) active = true;
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/service/model/ServiceRoutingRuleEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.service.model;

import com.atelie.ecommerce.domain.service.model.ServiceType;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "service_routing_rules")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceRoutingRuleEntity {

    @Id
    private UUID id;

    @Column(name = "service_type", nullable = false, length = 40)
    @Enumerated(EnumType.STRING)
    private ServiceType serviceType;

    @Column(name = "provider_code", nullable = false, length = 80)
    private String providerCode;

    @Column(name = "enabled", nullable = false)
    private boolean enabled;

    @Column(name = "priority", nullable = false)
    private int priority;

    @Column(name = "match_json", nullable = false, columnDefinition = "jsonb")
    private String matchJson;

    @Column(name = "behavior_json", columnDefinition = "jsonb")
    private String behaviorJson;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    // BLINDAGEM: Garante que tanto isEnabled() quanto getEnabled() existam
    public boolean isEnabled() { return enabled; }
    public boolean getEnabled() { return enabled; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/service/model/ServiceProviderConfigEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.service.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "service_provider_configs")
public class ServiceProviderConfigEntity {

    @Id
    private UUID id;

    @Column(name = "provider_id")
    private UUID providerId; // opcional (DB pode usar provider_id). Nosso teste usa providerCode.

    @Column(name = "environment", nullable = false, length = 20)
    private String environment;

    @Column(name = "secrets_ref", length = 200)
    private String secretsRef;

    @Column(name = "config_json", nullable = false, columnDefinition = "jsonb")
    private String configJson;

    @Column(name = "version", nullable = false)
    private int version;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // Campo auxiliar (não existe no schema original) -> não mapear.
    @jakarta.persistence.Transient
    private String providerCode;

    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public UUID getProviderId() { return providerId; }
    public void setProviderId(UUID providerId) { this.providerId = providerId; }

    public String getEnvironment() { return environment; }
    public void setEnvironment(String environment) { this.environment = environment; }

    public String getSecretsRef() { return secretsRef; }
    public void setSecretsRef(String secretsRef) { this.secretsRef = secretsRef; }

    public String getConfigJson() { return configJson; }
    public void setConfigJson(String configJson) { this.configJson = configJson; }

    public int getVersion() { return version; }
    public void setVersion(int version) { this.version = version; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    public String getProviderCode() { return providerCode; }
    public void setProviderCode(String providerCode) { this.providerCode = providerCode; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/service/model/ServiceProviderEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.service.model;

import com.atelie.ecommerce.domain.service.model.ServiceType;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "service_providers",
       uniqueConstraints = @UniqueConstraint(name = "ux_service_providers_type_code", columnNames = {"service_type", "code"}))
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceProviderEntity {

    @Id
    private UUID id;

    @Column(name = "service_type", nullable = false, length = 40)
    @Enumerated(EnumType.STRING)
    private ServiceType serviceType;

    @Column(name = "code", nullable = false, length = 80)
    private String code;

    @Column(name = "name", nullable = false, length = 160)
    private String name;

    @Column(name = "enabled", nullable = false)
    private boolean enabled;

    @Column(name = "priority", nullable = false)
    private int priority;

    @Column(name = "driver_key", nullable = false, length = 160)
    private String driverKey;

    @Column(name = "health_enabled", nullable = false)
    private boolean healthEnabled;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    // BLINDAGEM: Garante todos os padrões de getter possíveis
    public boolean isEnabled() { return enabled; }
    public boolean getEnabled() { return enabled; }
    
    public boolean isHealthEnabled() { return healthEnabled; }
    public boolean getHealthEnabled() { return healthEnabled; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/service/jpa/ServiceProviderJpaRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.service.jpa;

import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceProviderEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface ServiceProviderJpaRepository extends JpaRepository<ServiceProviderEntity, UUID> {

    List<ServiceProviderEntity> findByServiceTypeAndEnabledOrderByPriorityAsc(ServiceType serviceType, boolean enabled);

    // RESTAURADO: Necessário para o JpaServiceProviderConfigGateway
    Optional<ServiceProviderEntity> findByCode(String code);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/service/jpa/ServiceRoutingRuleJpaRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.service.jpa;

import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceRoutingRuleEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface ServiceRoutingRuleJpaRepository extends JpaRepository<ServiceRoutingRuleEntity, UUID> {
    
    // CORREÇÃO: Parâmetro atualizado de String para ServiceType para casar com a Entidade e Gateway
    List<ServiceRoutingRuleEntity> findByServiceTypeAndEnabledOrderByPriorityAsc(ServiceType serviceType, boolean enabled);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/service/jpa/ServiceProviderConfigJpaRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.service.jpa;

import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceProviderConfigEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;
import java.util.UUID;

public interface ServiceProviderConfigJpaRepository extends JpaRepository<ServiceProviderConfigEntity, UUID> {
    Optional<ServiceProviderConfigEntity> findTopByProviderIdAndEnvironmentOrderByVersionDesc(UUID providerId, String environment);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/media/MediaAssetEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.media;

import jakarta.persistence.*;
import java.time.Instant;

@Entity
@Table(name = "media_assets")
public class MediaAssetEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    private MediaAssetType type;

    @Column(name = "storage_key", nullable = false, unique = true, length = 512)
    private String storageKey;

    @Column(name = "original_filename", length = 255)
    private String originalFilename;

    @Column(name = "mime_type", nullable = false, length = 128)
    private String mimeType;

    @Column(name = "size_bytes", nullable = false)
    private long sizeBytes;

    @Column(name = "checksum_sha256", length = 64)
    private String checksumSha256;

    @Column(name = "is_public", nullable = false)
    private boolean isPublic = true;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt = Instant.now();

    public Long getId() { return id; }

    public MediaAssetType getType() { return type; }
    public void setType(MediaAssetType type) { this.type = type; }

    public String getStorageKey() { return storageKey; }
    public void setStorageKey(String storageKey) { this.storageKey = storageKey; }

    public String getOriginalFilename() { return originalFilename; }
    public void setOriginalFilename(String originalFilename) { this.originalFilename = originalFilename; }

    public String getMimeType() { return mimeType; }
    public void setMimeType(String mimeType) { this.mimeType = mimeType; }

    public long getSizeBytes() { return sizeBytes; }
    public void setSizeBytes(long sizeBytes) { this.sizeBytes = sizeBytes; }

    public String getChecksumSha256() { return checksumSha256; }
    public void setChecksumSha256(String checksumSha256) { this.checksumSha256 = checksumSha256; }

    public boolean isPublic() { return isPublic; }
    public void setPublic(boolean aPublic) { isPublic = aPublic; }

    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/media/MediaAssetRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.media;

import org.springframework.data.jpa.repository.JpaRepository;

public interface MediaAssetRepository extends JpaRepository<MediaAssetEntity, Long> {
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/media/MediaAssetType.java ---
package com.atelie.ecommerce.infrastructure.persistence.media;

public enum MediaAssetType {
    IMAGE,
    VIDEO
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/inventory/InventoryRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.inventory;

import com.atelie.ecommerce.infrastructure.persistence.inventory.entity.InventoryMovementEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface InventoryRepository extends JpaRepository<InventoryMovementEntity, UUID> {

    // --- CRITICAL FIX: Query Variant Table instead of Product Table ---
    // Counts variants with low stock, considering only active products that have alerts enabled.
    @Query("""
        SELECT COUNT(v) 
        FROM ProductVariantEntity v 
        JOIN v.product p 
        WHERE v.stockQuantity < :threshold 
          AND v.active = true 
          AND p.active = true 
          AND p.alertEnabled = true
    """)
    long countLowStockProducts(@Param("threshold") int threshold);

    @Query("SELECT COALESCE(SUM(CASE WHEN m.type = 'IN' THEN m.quantity WHEN m.type = 'OUT' THEN -m.quantity ELSE 0 END), 0) FROM InventoryMovementEntity m WHERE m.product.id = :productId")
    Integer auditCalculatedStock(@Param("productId") UUID productId);
}
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/inventory/entity/InventoryMovementEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.inventory.entity;

import com.atelie.ecommerce.domain.inventory.MovementType;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "inventory_movements")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class InventoryMovementEntity {

    @Id
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    @Column(name = "variant_id")
    private UUID variantId; // Nova coluna

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private MovementType type;

    @Column(nullable = false)
    private Integer quantity;

    private String reason;

    @Column(name = "reference_id")
    private String referenceId;

    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        if (id == null) id = UUID.randomUUID();
        if (createdAt == null) createdAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/config/SystemConfigRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.config;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface SystemConfigRepository extends JpaRepository<SystemConfigEntity, String> {
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/config/JpaSystemConfigGateway.java ---
package com.atelie.ecommerce.infrastructure.persistence.config;

import com.atelie.ecommerce.domain.config.SystemConfig;
import com.atelie.ecommerce.domain.config.SystemConfigGateway;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * JpaSystemConfigGateway.
 *
 * Adapter de infraestrutura que lê configs via JPA e expõe para o domínio
 * através do SystemConfigGateway.
 */
@Repository
public class JpaSystemConfigGateway implements SystemConfigGateway {

    private final SystemConfigRepository repository;

    public JpaSystemConfigGateway(SystemConfigRepository repository) {
        this.repository = repository;
    }

    @Override
    public List<SystemConfig> findAll() {
        return repository.findAll().stream()
                .filter(e -> e.getConfigKey() != null)
                .map(e -> new SystemConfig(e.getConfigKey(), e.getConfigValue()))
                .toList();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/config/SystemConfigEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.config;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name="system_config")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SystemConfigEntity {
    @Id
    private String configKey;
    
    @Column(columnDefinition = "TEXT")
    private String configValue;

    @Column(name = "config_json", columnDefinition = "jsonb")
    private String configJson;
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/category/CategoryEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.category;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "categories")
public class CategoryEntity {

    @Id
    private UUID id;

    private String name;
    
    private Boolean active;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public CategoryEntity() {}

    public CategoryEntity(String name, Boolean active) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.active = active;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // Getters e Setters manuais para garantir compatibilidade sem depender do Lombok agora
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public Boolean getActive() { return active; }
    public void setActive(Boolean active) { this.active = active; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) createdAt = LocalDateTime.now();
        if (updatedAt == null) updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/category/CategoryRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.category;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;

@Repository
public interface CategoryRepository extends JpaRepository<CategoryEntity, UUID> {
}
