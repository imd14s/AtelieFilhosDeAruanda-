
--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/domain/service/engine/DefaultServiceEngineTest.java ---
package com.atelie.ecommerce.domain.service.engine;

import com.atelie.ecommerce.domain.provider.RuleMatcher;
import com.atelie.ecommerce.domain.service.model.ServiceProvider;
import com.atelie.ecommerce.domain.service.model.ServiceRoutingRule;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

class DefaultServiceEngineTest {

    // Instância real do RuleMatcher (lógica pura, sem mock necessário)
    private final RuleMatcher ruleMatcher = new RuleMatcher();

    @Test
    void shouldPickHighestPriorityEnabledProvider_whenNoRulesMatch() {
        // providers: J3 prio=10, CORREIOS prio=20 (menor = mais prioritário)
        ServiceProvider j3 = new ServiceProvider(UUID.randomUUID(), ServiceType.SHIPPING, "J3", "J3", true, 10, "shipping.j3", true);
        ServiceProvider correios = new ServiceProvider(UUID.randomUUID(), ServiceType.SHIPPING, "CORREIOS", "Correios", true, 20, "shipping.correios", true);

        ServiceProviderGateway providerGateway = new InMemoryProviderGateway(List.of(j3, correios));
        ServiceRoutingRuleGateway ruleGateway = new InMemoryRuleGateway(List.of()); // sem regras

        // CORREÇÃO: Passando ruleMatcher (3º argumento)
        DefaultServiceEngine engine = new DefaultServiceEngine(providerGateway, ruleGateway, ruleMatcher);
        ServiceContext ctx = new ServiceContext("BR", BigDecimal.valueOf(100), Map.of());

        ResolvedProvider resolved = engine.resolve(ServiceType.SHIPPING, ctx);

        assertEquals("J3", resolved.provider().code());
        assertTrue(resolved.reason().toLowerCase().contains("default") || resolved.reason().toLowerCase().contains("priority"));
    }

    @Test
    void shouldPickProviderByRuleMatch_whenRuleIsEnabledAndMatches() {
        ServiceProvider j3 = new ServiceProvider(UUID.randomUUID(), ServiceType.SHIPPING, "J3", "J3", true, 10, "shipping.j3", true);
        ServiceProvider correios = new ServiceProvider(UUID.randomUUID(), ServiceType.SHIPPING, "CORREIOS", "Correios", true, 20, "shipping.correios", true);
        
        // regra manda usar CORREIOS quando country=BR
        ServiceRoutingRule rule = new ServiceRoutingRule(
                UUID.randomUUID(),
                ServiceType.SHIPPING,
                "CORREIOS",
                true,
                1,
                "{\"country\":\"BR\"}",
                "{}"
        );

        ServiceProviderGateway providerGateway = new InMemoryProviderGateway(List.of(j3, correios));
        ServiceRoutingRuleGateway ruleGateway = new InMemoryRuleGateway(List.of(rule));

        // CORREÇÃO: Passando ruleMatcher (3º argumento)
        DefaultServiceEngine engine = new DefaultServiceEngine(providerGateway, ruleGateway, ruleMatcher);
        ServiceContext ctx = new ServiceContext("BR", BigDecimal.valueOf(100), Map.of());

        ResolvedProvider resolved = engine.resolve(ServiceType.SHIPPING, ctx);

        assertEquals("CORREIOS", resolved.provider().code());
        assertTrue(resolved.reason().toLowerCase().contains("rule"));
    }

    @Test
    void shouldThrow_whenNoEnabledProvidersExist() {
        ServiceProviderGateway providerGateway = new InMemoryProviderGateway(List.of());
        // nenhum provider
        ServiceRoutingRuleGateway ruleGateway = new InMemoryRuleGateway(List.of());
        
        // CORREÇÃO: Passando ruleMatcher (3º argumento)
        DefaultServiceEngine engine = new DefaultServiceEngine(providerGateway, ruleGateway, ruleMatcher);

        ServiceContext ctx = new ServiceContext("BR", BigDecimal.valueOf(100), Map.of());

        assertThrows(IllegalStateException.class, () -> engine.resolve(ServiceType.SHIPPING, ctx));
    }

    // ===== fakes in-memory =====

    static class InMemoryProviderGateway implements ServiceProviderGateway {
        private final List<ServiceProvider> data;
        InMemoryProviderGateway(List<ServiceProvider> data) { this.data = data; }

        @Override
        public void refresh() {}

        @Override
        public List<ServiceProvider> findEnabledByTypeOrdered(ServiceType type) {
            return data.stream()
                    .filter(p -> p.serviceType() == type)
                    .filter(ServiceProvider::enabled)
                    .sorted(Comparator.comparingInt(ServiceProvider::priority))
                    .toList();
        }

        @Override
        public Optional<ServiceProvider> findByCode(ServiceType type, String code) {
            return data.stream()
                    .filter(p -> p.serviceType() == type)
                    .filter(p -> p.code().equalsIgnoreCase(code))
                    .findFirst();
        }
    }

    static class InMemoryRuleGateway implements ServiceRoutingRuleGateway {
        private final List<ServiceRoutingRule> data;
        InMemoryRuleGateway(List<ServiceRoutingRule> data) { this.data = data; }
        
        @Override
        public void refresh() {}

        @Override
        public List<ServiceRoutingRule> findEnabledByTypeOrdered(ServiceType type) {
            return data.stream()
                    .filter(r -> r.serviceType() == type)
                    .filter(ServiceRoutingRule::enabled)
                    .sorted(Comparator.comparingInt(ServiceRoutingRule::priority))
                    .toList();
        }
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/domain/provider/RuleMatcherTest.java ---
package com.atelie.ecommerce.domain.provider;

import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

class RuleMatcherTest {

    private final RuleMatcher matcher = new RuleMatcher();

    @Test
    void shouldMatchSpelExpression_whenExpressionIsTrue() {
        RouteContext ctx = new RouteContext("BR", "01001-000", BigDecimal.valueOf(100), Map.of());

        String ruleJson = """
                {"expression":"country == 'BR'"}
                """;

        RuleMatch result = matcher.matches(ctx, ruleJson);

        assertTrue(result.matched());
        assertEquals("spel_matched", result.reason());
    }

    @Test
    void shouldNotMatchSpelExpression_whenExpressionIsFalse() {
        RouteContext ctx = new RouteContext("BR", "01001-000", BigDecimal.valueOf(100), Map.of());

        String ruleJson = """
                {"expression":"country == 'US'"}
                """;

        RuleMatch result = matcher.matches(ctx, ruleJson);

        assertFalse(result.matched());
        assertEquals("spel_mismatch", result.reason());
    }

    @Test
    void shouldMatchLegacyCountryRule_whenCountryMatches() {
        RouteContext ctx = new RouteContext("BR", "01001-000", BigDecimal.valueOf(100), Map.of());

        String ruleJson = """
                {"country":"BR"}
                """;

        RuleMatch result = matcher.matches(ctx, ruleJson);

        assertTrue(result.matched());
        assertEquals("legacy_matched", result.reason());
    }

    @Test
    void shouldNotMatchLegacyRules_whenCepPrefixOrMinTotalMismatch() {
        RouteContext ctx = new RouteContext("BR", "99999-000", BigDecimal.valueOf(50), Map.of());

        // cep_prefix não bate (espera começar com 010 ou 011) e min_total exige >= 100
        String ruleJson = """
                {"country":"BR","cep_prefix":["010","011"],"min_total":100}
                """;

        RuleMatch result = matcher.matches(ctx, ruleJson);

        assertFalse(result.matched());
        // pode falhar primeiro por cep_prefix ou por min_total — ambos são válidos
        assertTrue(
                result.reason().equals("cep_prefix_mismatch") || result.reason().equals("min_total_mismatch"),
                "reason inesperado: " + result.reason()
        );
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/api/auth/dto/AuthDtoValidationTest.java ---
package com.atelie.ecommerce.api.auth.dto;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

class AuthDtoValidationTest {

    private static ValidatorFactory factory;
    private static Validator validator;

    @BeforeAll
    static void setUp() {
        factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @AfterAll
    static void tearDown() {
        factory.close();
    }

    private RegisterRequest buildRegister(String name, String email, String password) {
        RegisterRequest r = new RegisterRequest();
        r.setName(name);
        r.setEmail(email);
        r.setPassword(password);
        return r;
    }

    @Test
    void shouldValidateRegisterRequest_whenValid() {
        RegisterRequest req = buildRegister("User", "user@email.com", "123456");
        Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(req);
        assertTrue(violations.isEmpty());
    }

    @Test
    void shouldFailValidation_whenNameIsBlank() {
        RegisterRequest req = buildRegister("", "user@email.com", "123456");
        Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(req);
        assertFalse(violations.isEmpty());
    }

    @Test
    void shouldFailValidation_whenEmailIsInvalid() {
        RegisterRequest req = buildRegister("User", "invalid", "123456");
        Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(req);
        assertFalse(violations.isEmpty());
    }

    @Test
    void shouldFailValidation_whenPasswordIsBlank() {
        RegisterRequest req = buildRegister("User", "user@email.com", "");
        Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(req);
        assertFalse(violations.isEmpty());
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/api/auth/dto/AuthResponseDtoTest.java ---
package com.atelie.ecommerce.api.auth.dto;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class AuthResponseDtoTest {
    @Test
    void shouldCreateLoginResponse() {
        LoginResponse response = new LoginResponse("token-123", "User Test", "test@test.com");
        
        Assertions.assertEquals("token-123", response.getToken());
        Assertions.assertEquals("User Test", response.getName());
        Assertions.assertEquals("test@test.com", response.getEmail());
    }
}

--- ARQUIVO: ./src/test/java/com/atelie/ecommerce/api/common/error/ErrorResponseTest.java ---
package com.atelie.ecommerce.api.common.error;

import org.junit.jupiter.api.Test;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * ErrorResponseTest.
 */
class ErrorResponseTest {

    @Test
    void shouldExposeAllFields() {
        ErrorResponse response = new ErrorResponse(
                404,
                "Not Found",
                "Route not found",
                "/x",
                null
        );

        assertEquals(404, response.getStatus());
        assertEquals("Not Found", response.getError());
        assertEquals("Route not found", response.getMessage());
        assertEquals("/x", response.getPath());
        assertNotNull(response.getTimestamp());
    }

    @Test
    void shouldAllowNullFieldsInSkeletonPhase() {
        ErrorResponse response = ErrorResponse.badRequest("Validation error", "/x", null);

        assertEquals(400, response.getStatus());
        assertNotNull(response.getTimestamp());
        assertNull(response.getFields());
    }

    @Test
    void shouldAcceptFieldsMapWhenProvided() {
        ErrorResponse response = ErrorResponse.badRequest("Validation error", "/x", Map.of("email", "must not be blank"));

        assertEquals(400, response.getStatus());
        assertEquals("must not be blank", response.getFields().get("email"));
    }
}
