
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/JsonUtils.java ---
package com.atelie.ecommerce.api.serviceengine;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.Map;

public class JsonUtils {

    private static final ObjectMapper mapper = new ObjectMapper();

    @SuppressWarnings("unchecked")
    public static Map<String, Object> toMap(String json) {
        try {
            return mapper.readValue(json, Map.class);
        } catch (Exception e) {
            return Map.of();
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/DriverRegistry.java ---
package com.atelie.ecommerce.api.serviceengine;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Registry de drivers dispon√≠veis no c√≥digo.
 * Dashboard escolhe qual driverKey usar via DB.
 */
public class DriverRegistry {

    private final Map<String, ServiceDriver> driversByKey = new HashMap<>();

    public DriverRegistry(List<ServiceDriver> drivers) {
        for (ServiceDriver d : drivers) {
            driversByKey.put(d.driverKey(), d);
        }
    }

    public Optional<ServiceDriver> findByDriverKey(String driverKey) {
        return Optional.ofNullable(driversByKey.get(driverKey));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/util/DriverConfigReader.java ---
package com.atelie.ecommerce.api.serviceengine.util;

import java.math.BigDecimal;
import java.util.Map;

public final class DriverConfigReader {

    private DriverConfigReader() {}

    public static BigDecimal requireBigDecimal(Map<String, Object> config, String key) {
        Object v = config.get(key);
        if (v == null) {
            throw new IllegalArgumentException("Config obrigat√≥ria ausente: '" + key + "'");
        }
        try {
            return new BigDecimal(String.valueOf(v));
        } catch (Exception e) {
            throw new IllegalArgumentException("Config inv√°lida para '" + key + "': valor='" + v + "'");
        }
    }

    public static String optionalString(Map<String, Object> config, String key, String defaultValue) {
        Object v = config.get(key);
        if (v == null) return defaultValue;
        String s = String.valueOf(v);
        return s == null ? defaultValue : s;
    }

    public static String requireNonBlank(String value, String fieldName) {
        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("Campo obrigat√≥rio ausente: '" + fieldName + "'");
        }
        return value;
    }

    public static BigDecimal requireMoney(Object value, String fieldName) {
        if (value == null) {
            throw new IllegalArgumentException("Campo obrigat√≥rio ausente: '" + fieldName + "'");
        }
        if (value instanceof BigDecimal bd) return bd;
        try {
            return new BigDecimal(String.valueOf(value));
        } catch (Exception e) {
            throw new IllegalArgumentException("Campo inv√°lido '" + fieldName + "': valor='" + value + "'");
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/ServiceOrchestrator.java ---
package com.atelie.ecommerce.api.serviceengine;

import com.atelie.ecommerce.domain.service.engine.ResolvedProvider;
import com.atelie.ecommerce.domain.service.engine.ServiceContext;
import com.atelie.ecommerce.domain.service.engine.ServiceEngine;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;

public class ServiceOrchestrator {

    private final ServiceEngine engine;
    private final ServiceProviderConfigGateway configGateway;
    private final DriverRegistry driverRegistry;

    public ServiceOrchestrator(
            ServiceEngine engine,
            ServiceProviderConfigGateway configGateway,
            DriverRegistry driverRegistry
    ) {
        this.engine = engine;
        this.configGateway = configGateway;
        this.driverRegistry = driverRegistry;
    }

    public ServiceResult execute(
            ServiceType type,
            Map<String, Object> request,
            String environment
    ) {
        BigDecimal value = BigDecimal.ZERO;
        if (request.containsKey("amount")) value = toBigDecimal(request.get("amount"));
        else if (request.containsKey("subtotal")) value = toBigDecimal(request.get("subtotal"));
        else if (request.containsKey("total")) value = toBigDecimal(request.get("total"));

        Map<String, Object> attributes = new HashMap<>(request);
        
        // Usa o pa√≠s do request se existir, sen√£o default BR
        String country = (String) attributes.getOrDefault("country", "BR");
        
        ServiceContext ctx = new ServiceContext(country, value, attributes);

        ResolvedProvider resolved = engine.resolve(type, ctx);

        if (resolved == null || resolved.provider() == null) {
            return new ServiceResult(false, null, Map.of("error", "NO_PROVIDER_AVAILABLE"));
        }

        var provider = resolved.provider();
        String configJson = configGateway
                .findConfigJson(provider.code(), environment)
                .orElse("{}");
        
        var driver = driverRegistry
                .findByDriverKey(provider.driverKey())
                .orElse(null);
        
        if (driver == null) {
            return new ServiceResult(false, provider.code(), Map.of("error", "DRIVER_NOT_FOUND"));
        }

        Map<String, Object> config = JsonUtils.toMap(configJson);
        Map<String, Object> payload = driver.execute(request, config);
        
        // Se o driver reportar erro no payload (ex: timeout, recusado), propagamos como falha.
        boolean driverSuccess = !Boolean.TRUE.equals(payload.get("error"));

        return new ServiceResult(driverSuccess, provider.code(), payload);
    }

    private BigDecimal toBigDecimal(Object val) {
        if (val == null) return BigDecimal.ZERO;
        if (val instanceof BigDecimal) return (BigDecimal) val;
        try { return new BigDecimal(val.toString()); } catch (Exception e) { return BigDecimal.ZERO; }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/ServiceResult.java ---
package com.atelie.ecommerce.api.serviceengine;

import java.util.Map;

public record ServiceResult(
        boolean success,
        String providerCode,
        Map<String, Object> payload
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/ServiceDriver.java ---
package com.atelie.ecommerce.api.serviceengine;

import com.atelie.ecommerce.domain.service.model.ServiceType;

import java.util.Map;

/**
 * Contrato de driver execut√°vel (implementa√ß√£o em c√≥digo).
 * O driver √© selecionado via driverKey armazenada no banco.
 */
public interface ServiceDriver {

    String driverKey();

    ServiceType serviceType();

    Map<String, Object> execute(Map<String, Object> request, Map<String, Object> config);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/media/MediaController.java ---
package com.atelie.ecommerce.api.media;

import com.atelie.ecommerce.infrastructure.service.media.MediaStorageService;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/api/media")
public class MediaController {

    private final MediaStorageService media;

    public MediaController(MediaStorageService media) {
        this.media = media;
    }

    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> upload(
        @RequestParam("file") MultipartFile file,
        @RequestParam("type") String type,
        @RequestParam(value = "public", defaultValue = "true") boolean isPublic
    ) {
        var saved = media.upload(file, type, isPublic);
        return ResponseEntity.ok(java.util.Map.of(
            "id", saved.getId(),
            "type", saved.getType().name(),
            "mimeType", saved.getMimeType(),
            "sizeBytes", saved.getSizeBytes(),
            "isPublic", saved.isPublic(),
            "publicUrl", "/api/media/public/" + saved.getId()
        ));
    }

    @GetMapping("/public/{id}")
    public ResponseEntity<FileSystemResource> getPublic(@PathVariable("id") long id) {
        var opt = media.loadPublic(id);
        if (opt.isEmpty()) return ResponseEntity.status(HttpStatus.NOT_FOUND).build();

        var dl = opt.get();
        FileSystemResource res = new FileSystemResource(dl.path().toFile());

        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(dl.mimeType()))
            .contentLength(dl.sizeBytes())
            .header(HttpHeaders.CACHE_CONTROL, "public, max-age=31536000, immutable")
            .body(res);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/inventory/dto/InventoryBalanceResponse.java ---
package com.atelie.ecommerce.api.inventory.dto;

import java.util.UUID;

public record InventoryBalanceResponse(
    UUID productId,
    Integer currentStock
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/inventory/dto/InventoryAdjustmentRequest.java ---
package com.atelie.ecommerce.api.inventory.dto;

import com.atelie.ecommerce.domain.inventory.MovementType;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public record InventoryAdjustmentRequest(
    @NotNull(message = "Type is required (IN/OUT)")
    MovementType type,
    
    @NotNull(message = "Quantity is required")
    @Positive(message = "Quantity must be positive")
    Integer quantity,
    
    String reason,
    String referenceId
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/inventory/InventoryController.java ---
package com.atelie.ecommerce.api.inventory;

import com.atelie.ecommerce.api.inventory.dto.InventoryAdjustmentRequest;
import com.atelie.ecommerce.api.inventory.dto.InventoryBalanceResponse;
import com.atelie.ecommerce.application.service.inventory.InventoryService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/inventory")
public class InventoryController {

    private final InventoryService inventoryService;

    public InventoryController(InventoryService inventoryService) {
        this.inventoryService = inventoryService;
    }

    @GetMapping("/{variantId}")
    public ResponseEntity<InventoryBalanceResponse> getBalance(@PathVariable UUID variantId) {
        // Corre√ß√£o: Chama o servi√ßo usando o ID da Variante [cite: 281]
        Integer stock = inventoryService.getStock(variantId);
        return ResponseEntity.ok(new InventoryBalanceResponse(variantId, stock));
    }

    @PostMapping("/{variantId}")
    public ResponseEntity<Void> adjustStock(
            @PathVariable UUID variantId,
            @RequestBody @Valid InventoryAdjustmentRequest request) {
        
        inventoryService.addMovement(
                variantId, 
                request.type(), 
                request.quantity(), 
                request.reason(), 
                request.referenceId()
        );
        return ResponseEntity.ok().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/shipping/service/ShippingService.java ---
package com.atelie.ecommerce.api.shipping.service;

import com.atelie.ecommerce.api.serviceengine.ServiceOrchestrator;
import com.atelie.ecommerce.api.serviceengine.ServiceResult;
import com.atelie.ecommerce.api.shipping.dto.ShippingQuoteResponse;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;

@Service
public class ShippingService {

    private final ServiceOrchestrator orchestrator;
    @Value("${spring.profiles.active:prod}")
    private String activeProfile;

    public ShippingService(ServiceOrchestrator orchestrator) {
        this.orchestrator = orchestrator;
    }

    public ShippingQuoteResponse quote(String rawCep, BigDecimal subtotal, String forcedProvider) {
        Map<String, Object> request = new HashMap<>();
        request.put("cep", rawCep);
        request.put("subtotal", subtotal);
        if (forcedProvider != null) request.put("forced_provider", forcedProvider); // Suporte futuro

        ServiceResult result = orchestrator.execute(ServiceType.SHIPPING, request, activeProfile);
        
        if (!result.success()) {
            return new ShippingQuoteResponse("ERROR", false, false, BigDecimal.ZERO, BigDecimal.ZERO);
        }

        Map<String, Object> payload = result.payload();
        
        // CORRE√á√ÉO: Usa o providerCode do orquestrador ("LOGGI", "J3") como fonte da verdade.
        // O fallback √© o payload do driver.
        String providerName = result.providerCode() != null ? result.providerCode() : (String) payload.getOrDefault("provider", "UNKNOWN");

        return new ShippingQuoteResponse(
            providerName,
            (Boolean) payload.getOrDefault("eligible", false),
            (Boolean) payload.getOrDefault("free_shipping", false),
            toBigDecimal(payload.get("cost")),
            toBigDecimal(payload.get("threshold"))
        );
    }

    private BigDecimal toBigDecimal(Object val) {
        if (val == null) return BigDecimal.ZERO;
        if (val instanceof BigDecimal) return (BigDecimal) val;
        try { return new BigDecimal(val.toString()); } catch (Exception e) { return BigDecimal.ZERO; }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/shipping/controller/ShippingController.java ---
package com.atelie.ecommerce.api.shipping.controller;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.api.shipping.dto.ShippingQuoteRequest;
import com.atelie.ecommerce.api.shipping.dto.ShippingQuoteResponse;
import com.atelie.ecommerce.api.shipping.service.ShippingService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/shipping")
public class ShippingController {

    private final ShippingService shippingService;
    private final DynamicConfigService dynamicConfigService;

    public ShippingController(ShippingService shippingService, DynamicConfigService dynamicConfigService) {
        this.shippingService = shippingService;
        this.dynamicConfigService = dynamicConfigService;
    }

    @PostMapping("/quote")
    public ResponseEntity<ShippingQuoteResponse> quote(@Valid @RequestBody ShippingQuoteRequest req) {
        return ResponseEntity.ok(shippingService.quote(req.getCep(), req.getSubtotal(), req.getProvider()));
    }

    // Endpoint operacional: recarrega cache sem restart (pode depois proteger via auth/admin)
    @PostMapping("/configs/refresh")
    public ResponseEntity<Void> refreshConfigs() {
        dynamicConfigService.refresh();
        return ResponseEntity.noContent().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/shipping/dto/ShippingQuoteRequest.java ---
package com.atelie.ecommerce.api.shipping.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public class ShippingQuoteRequest {

    @NotBlank
    private String cep;

    @NotNull
    private BigDecimal subtotal;

    // opcional: for√ßa provedor ("J3" ou "FLAT_RATE"). Se null, usa SHIPPING_PROVIDER_MODE.
    private String provider;

    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }

    public BigDecimal getSubtotal() { return subtotal; }
    public void setSubtotal(BigDecimal subtotal) { this.subtotal = subtotal; }

    public String getProvider() { return provider; }
    public void setProvider(String provider) { this.provider = provider; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/shipping/dto/ShippingQuoteResponse.java ---
package com.atelie.ecommerce.api.shipping.dto;

import java.math.BigDecimal;

public class ShippingQuoteResponse {

    private String provider;
    private boolean eligible;
    private boolean freeShippingApplied;
    private BigDecimal shippingCost;
    private BigDecimal freeShippingThreshold;

    public ShippingQuoteResponse() {}

    public ShippingQuoteResponse(String provider, boolean eligible, boolean freeShippingApplied, BigDecimal shippingCost, BigDecimal freeShippingThreshold) {
        this.provider = provider;
        this.eligible = eligible;
        this.freeShippingApplied = freeShippingApplied;
        this.shippingCost = shippingCost;
        this.freeShippingThreshold = freeShippingThreshold;
    }

    public String getProvider() { return provider; }
    public void setProvider(String provider) { this.provider = provider; }

    public boolean isEligible() { return eligible; }
    public void setEligible(boolean eligible) { this.eligible = eligible; }

    public boolean isFreeShippingApplied() { return freeShippingApplied; }
    public void setFreeShippingApplied(boolean freeShippingApplied) { this.freeShippingApplied = freeShippingApplied; }

    public BigDecimal getShippingCost() { return shippingCost; }
    public void setShippingCost(BigDecimal shippingCost) { this.shippingCost = shippingCost; }

    public BigDecimal getFreeShippingThreshold() { return freeShippingThreshold; }
    public void setFreeShippingThreshold(BigDecimal freeShippingThreshold) { this.freeShippingThreshold = freeShippingThreshold; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/ConfigBootstrap.java ---
package com.atelie.ecommerce.api.config;

import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class ConfigBootstrap implements ApplicationRunner {

    private final DynamicConfigService dynamicConfigService;

    public ConfigBootstrap(DynamicConfigService dynamicConfigService) {
        this.dynamicConfigService = dynamicConfigService;
    }

    @Override
    public void run(ApplicationArguments args) {
        // Cache inicial do motor din√¢mico
        dynamicConfigService.refresh();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/AdminBootstrap.java ---
package com.atelie.ecommerce.api.config;

import com.atelie.ecommerce.infrastructure.persistence.auth.UserRepository;
import com.atelie.ecommerce.infrastructure.persistence.auth.entity.UserEntity;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * AdminBootstrap
 * Garante que o usu√°rio Admin exista e esteja com a senha sincronizada com o .env.
 * Isso permite rota√ß√£o de senhas sem tocar no banco de dados manualmente.
 */
@Component
public class AdminBootstrap implements CommandLineRunner {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    @Value("${ADMIN_EMAIL:admin@atelie.com}")
    private String adminEmail;

    @Value("${ADMIN_PASSWORD:}")
    private String adminPassword;

    public AdminBootstrap(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    @Transactional
    public void run(String... args) {
        if (adminPassword == null || adminPassword.isBlank()) {
            System.out.println("‚ö†Ô∏è ADMIN_PASSWORD n√£o configurada. Pulando bootstrap de admin.");
            return;
        }

        userRepository.findByEmail(adminEmail).ifPresentOrElse(
            existingUser -> {
                // Usu√°rio j√° existe? Atualiza a senha para garantir sincronia com .env
                // S√≥ atualiza se o hash for diferente (evita update desnecess√°rio, mas aqui for√ßamos por seguran√ßa)
                existingUser.setPassword(passwordEncoder.encode(adminPassword));
                existingUser.setRole("ADMIN"); // Garante permiss√£o
                userRepository.save(existingUser);
                System.out.println("üîí Admin User ('" + adminEmail + "') atualizado com a senha do ambiente.");
            },
            () -> {
                // N√£o existe? Cria novo.
                UserEntity newAdmin = UserEntity.builder()
                        .id(UUID.randomUUID())
                        .name("Admin Master")
                        .email(adminEmail)
                        .password(passwordEncoder.encode(adminPassword))
                        .role("ADMIN")
                        .createdAt(LocalDateTime.now())
                        .build(); // Usando Builder do Lombok se dispon√≠vel, ou construtor padr√£o
                
                // Fallback se o Builder n√£o estiver ativo no Entity
                if (newAdmin.getName() == null) {
                    newAdmin = new UserEntity("Admin Master", adminEmail, passwordEncoder.encode(adminPassword), "ADMIN");
                }
                
                userRepository.save(newAdmin);
                System.out.println("‚ú® Admin User ('" + adminEmail + "') criado com sucesso.");
            }
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/StaticResourceConfig.java ---
package com.atelie.ecommerce.api.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.nio.file.Path;
import java.nio.file.Paths;

@Configuration
public class StaticResourceConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        Path uploadDir = Paths.get("./uploads");
        String uploadPath = uploadDir.toFile().getAbsolutePath();
        registry.addResourceHandler("/uploads/**").addResourceLocations("file:" + uploadPath + "/");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/exception/MissingConfigException.java ---
package com.atelie.ecommerce.api.config.exception;

public class MissingConfigException extends RuntimeException {
    public MissingConfigException(String key) {
        super("Config obrigat√≥ria ausente no banco: " + key);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/DynamicConfigService.java ---
package com.atelie.ecommerce.api.config;

import com.atelie.ecommerce.domain.common.event.EntityChangedEvent;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Service
public class DynamicConfigService {
    
    public static final String CACHE_TTL_SECONDS_KEY = "CACHE_TTL_SECONDS";
    
    private final SystemConfigRepository repository;
    private final Map<String, String> cache = new ConcurrentHashMap<>();

    public DynamicConfigService(SystemConfigRepository repository) {
        this.repository = repository;
        refresh();
    }

    public void refresh() {
        try {
            var configs = repository.findAll();
            cache.clear();
            configs.forEach(c -> cache.put(c.getConfigKey(), c.getConfigValue()));
            log.info("Cache de configura√ß√µes atualizado: {} itens", cache.size());
        } catch (Exception e) {
            log.warn("N√£o foi poss√≠vel carregar configura√ß√µes iniciais (pode ser a primeira execu√ß√£o): {}", e.getMessage());
        }
    }

    @EventListener
    public void onEntityChanged(EntityChangedEvent event) {
        if ("SYSTEM_CONFIG".equals(event.getEntityType())) refresh();
    }

    public String getString(String key) { return cache.get(key); }
    
    public String requireString(String key) {
        String v = getString(key);
        if (v == null) throw new IllegalStateException("Config ausente: " + key);
        return v;
    }
    
    public boolean requireBoolean(String key) {
        return Boolean.parseBoolean(requireString(key));
    }
    
    public boolean containsKey(String key) {
        return cache.containsKey(key);
    }

    public long getLong(String key, int defaultValue) {
        String val = getString(key);
        if (val == null) return defaultValue;
        try {
            return Long.parseLong(val);
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/OrderResponse.java ---
package com.atelie.ecommerce.api.order.dto;

import com.atelie.ecommerce.domain.order.OrderStatus;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

public record OrderResponse(
    UUID id,
    OrderStatus status,
    String source,
    String externalId,
    String customerName,
    BigDecimal totalAmount,
    LocalDateTime createdAt,
    List<OrderItemResponse> items
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/OrderItemResponse.java ---
package com.atelie.ecommerce.api.order.dto;

import java.math.BigDecimal;
import java.util.UUID;

public record OrderItemResponse(
    UUID productId,
    String productName,
    Integer quantity,
    BigDecimal unitPrice,
    BigDecimal totalPrice
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/CreateOrderRequest.java ---
package com.atelie.ecommerce.api.order.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank; // Importante!
import jakarta.validation.constraints.NotEmpty;
import java.util.List;

public record CreateOrderRequest(
    @NotBlank(message = "Source √© obrigat√≥rio") 
    String source,
    
    @NotBlank(message = "External ID √© obrigat√≥rio") 
    String externalId,
    
    @NotBlank(message = "Nome do cliente √© obrigat√≥rio") 
    String customerName,
    
    @NotEmpty(message = "Lista de itens n√£o pode ser vazia") 
    @Valid 
    List<CreateOrderItemRequest> items
) {}
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/CreateOrderItemRequest.java ---
package com.atelie.ecommerce.api.order.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import java.util.UUID;

public record CreateOrderItemRequest(
    @NotNull UUID productId,
    UUID variantId, // Novo campo opcional (se produto tiver varia√ß√£o, √© obrigat√≥rio na l√≥gica)
    @NotNull @Min(1) Integer quantity
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/OrderController.java ---
package com.atelie.ecommerce.api.order;

import com.atelie.ecommerce.api.order.dto.CreateOrderRequest;
import com.atelie.ecommerce.api.order.dto.OrderResponse;
import com.atelie.ecommerce.api.order.dto.OrderItemResponse;
import com.atelie.ecommerce.application.service.order.OrderService;
import com.atelie.ecommerce.domain.order.OrderStatus;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderEntity;
import jakarta.validation.Valid;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private final OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @PostMapping
    public ResponseEntity<OrderResponse> createOrder(@Valid @RequestBody CreateOrderRequest request) {
        OrderEntity created = orderService.createOrder(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(toResponse(created));
    }

    @GetMapping
    public Page<OrderResponse> getAllOrders(
            @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable
    ) {
        return orderService.getAllOrders(pageable).map(this::toResponse);
    }

    // Mapper Simples
    private OrderResponse toResponse(OrderEntity entity) {
        var items = entity.getItems().stream()
                .map(i -> new OrderItemResponse(
                        i.getProduct().getId(),
                        i.getProduct().getName(),
                        i.getQuantity(),
                        i.getUnitPrice(),
                        i.getTotalPrice()
                )).collect(Collectors.toList());

        return new OrderResponse(
                entity.getId(),
                OrderStatus.valueOf(entity.getStatus()),
                entity.getSource(),
                entity.getExternalId(),
                entity.getCustomerName(),
                entity.getTotalAmount(),
                entity.getCreatedAt().atZone(java.time.ZoneId.of("UTC")).toLocalDateTime(),
                items
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/payment/dto/PaymentResponse.java ---
package com.atelie.ecommerce.api.payment.dto;

import java.math.BigDecimal;
import java.util.Map;

public record PaymentResponse(
    String status,
    String provider,
    BigDecimal amount,
    boolean sandbox,
    Map<String, Object> metadata
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/dto/DashboardSummary.java ---
package com.atelie.ecommerce.api.dashboard.dto;

import java.math.BigDecimal;

public record DashboardSummary(
    BigDecimal totalSales,
    long pendingOrders,
    long lowStockAlerts
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/ProductManagementController.java ---
package com.atelie.ecommerce.api.dashboard;

import com.atelie.ecommerce.api.catalog.product.dto.ProductResponse;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/dashboard/products")
public class ProductManagementController {

    private final ProductRepository productRepository;

    public ProductManagementController(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @GetMapping
    public List<ProductResponse> listAll() {
        // Converte Entity para DTO antes de retornar
        return productRepository.findAll().stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    // Simplificado para Dashboard (admin v√™ tudo)
    private ProductResponse toResponse(ProductEntity entity) {
        var response = new ProductResponse(
                entity.getId(),
                entity.getName(),
                entity.getDescription(),
                entity.getPrice(),
                entity.getCategoryId(),
                entity.getActive()
        );
        response.setImageUrl(entity.getImageUrl());
        return response;
    }

    @PutMapping("/{id}/toggle-alert")
    public ResponseEntity<ProductResponse> toggleAlert(@PathVariable UUID id) {
        ProductEntity product = productRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Produto n√£o encontrado"));
        product.setAlertEnabled(!Boolean.TRUE.equals(product.getAlertEnabled()));
        ProductEntity saved = productRepository.save(product);
        return ResponseEntity.ok(toResponse(saved));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/DashboardController.java ---
package com.atelie.ecommerce.api.dashboard;

import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/dashboard")
public class DashboardController {

    private final ProductRepository productRepository;

    public DashboardController(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @GetMapping("/summary")
    public ResponseEntity<Map<String, Object>> getSummary() {
        // Usa o reposit√≥rio existente para contar produtos reais
        long totalProducts = productRepository.count();
        
        // Mock para Vendas (pois a estrutura de Order √© complexa no seu projeto original)
        Map<String, Object> summary = new HashMap<>();
        summary.put("totalProducts", totalProducts);
        summary.put("totalSales", new BigDecimal("1500.00")); 
        summary.put("pendingOrders", 3);
        summary.put("lowStockAlerts", 0);
        
        return ResponseEntity.ok(summary);
    }

    @GetMapping("/automation/status")
    public ResponseEntity<Map<String, Boolean>> getAutomationStatus() {
        return ResponseEntity.ok(Map.of("enabled", true));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminOrderController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.application.service.order.OrderService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;
import java.util.Map;

@RestController
@RequestMapping("/api/admin/orders")
public class AdminOrderController {

    private final OrderService orderService;

    public AdminOrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @PostMapping("/{id}/cancel")
    public ResponseEntity<Void> cancel(@PathVariable UUID id, @RequestBody(required = false) Map<String, String> body) {
        String reason = (body != null && body.containsKey("reason")) ? body.get("reason") : "Admin request";
        orderService.cancelOrder(id, reason);
        return ResponseEntity.ok().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminFeatureFlagController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.infrastructure.persistence.feature.FeatureFlagEntity;
import com.atelie.ecommerce.infrastructure.persistence.feature.FeatureFlagRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/features")
public class AdminFeatureFlagController {

    private final FeatureFlagRepository repository;

    public AdminFeatureFlagController(FeatureFlagRepository repository) {
        this.repository = repository;
    }

    @GetMapping
    public List<FeatureFlagEntity> list() {
        return repository.findAll();
    }

    @PostMapping
    public FeatureFlagEntity createOrUpdate(@RequestBody FeatureFlagEntity dto) {
        return repository.findByFlagKey(dto.getFlagKey())
                .map(existing -> {
                    existing.setEnabled(dto.isEnabled());
                    existing.setValueJson(dto.getValueJson());
                    return repository.save(existing);
                })
                .orElseGet(() -> repository.save(dto));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminCacheController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.domain.common.event.EntityChangedEvent;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/admin/cache")
public class AdminCacheController {

    private final ApplicationEventPublisher eventPublisher;

    public AdminCacheController(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    @PostMapping("/refresh")
    public ResponseEntity<Map<String, Object>> refreshAll() {
        // Dispara um evento global que todos os Gateways e o ConfigService ouvem
        eventPublisher.publishEvent(new EntityChangedEvent(this, "MANUAL_GLOBAL_REFRESH"));

        return ResponseEntity.ok(Map.of(
                "ok", true,
                "message", "Evento de atualiza√ß√£o disparado para todos os listeners de cache."
        ));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminConfigController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.domain.common.event.EntityChangedEvent;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigEntity;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigRepository;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/configs")
public class AdminConfigController {

    private final SystemConfigRepository repository;
    private final ApplicationEventPublisher eventPublisher;

    public AdminConfigController(SystemConfigRepository repository, ApplicationEventPublisher eventPublisher) {
        this.repository = repository;
        this.eventPublisher = eventPublisher;
    }

    @GetMapping
    public List<SystemConfigEntity> listAll() {
        return repository.findAll();
    }

    @PostMapping
    public ResponseEntity<SystemConfigEntity> upsert(@RequestBody SystemConfigEntity dto) {
        SystemConfigEntity saved = repository.save(dto);
        eventPublisher.publishEvent(new EntityChangedEvent(this, "SYSTEM_CONFIG"));
        return ResponseEntity.ok(saved);
    }

    @DeleteMapping("/{key}")
    public ResponseEntity<Void> delete(@PathVariable String key) {
        repository.deleteById(key);
        eventPublisher.publishEvent(new EntityChangedEvent(this, "SYSTEM_CONFIG"));
        return ResponseEntity.noContent().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminRuleController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.domain.service.model.ServiceType; // IMPORT ADICIONADO
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceRoutingRuleJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceRoutingRuleEntity;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/admin/rules")
public class AdminRuleController {

    private final ServiceRoutingRuleJpaRepository repository;
    private final ServiceRoutingRuleGateway gateway;
    private final ExpressionParser parser = new SpelExpressionParser();
    private final ObjectMapper mapper = new ObjectMapper();

    public AdminRuleController(ServiceRoutingRuleJpaRepository repository, ServiceRoutingRuleGateway gateway) {
        this.repository = repository;
        this.gateway = gateway;
    }

    @GetMapping
    // CORRE√á√ÉO: @RequestParam ServiceType type (Spring converte String->Enum auto)
    public List<ServiceRoutingRuleEntity> list(@RequestParam(required = false) ServiceType type) {
        if (type != null) {
            return repository.findByServiceTypeAndEnabledOrderByPriorityAsc(type, true);
        }
        return repository.findAll();
    }

    @PostMapping
    public ResponseEntity<?> create(@RequestBody ServiceRoutingRuleEntity entity) {
        try { validateSpel(entity.getMatchJson()); } 
        catch (IllegalArgumentException e) { return ResponseEntity.badRequest().body("Regra Inv√°lida: " + e.getMessage()); }

        if (entity.getId() == null) entity.setId(UUID.randomUUID());
        entity.setUpdatedAt(LocalDateTime.now());
        
        ServiceRoutingRuleEntity saved = repository.save(entity);
        gateway.refresh();
        return ResponseEntity.ok(saved);
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> update(@PathVariable UUID id, @RequestBody ServiceRoutingRuleEntity entity) {
        if (!repository.existsById(id)) return ResponseEntity.notFound().build();
        try { validateSpel(entity.getMatchJson()); } 
        catch (IllegalArgumentException e) { return ResponseEntity.badRequest().body("Regra Inv√°lida: " + e.getMessage()); }

        entity.setId(id);
        entity.setUpdatedAt(LocalDateTime.now());
        
        ServiceRoutingRuleEntity saved = repository.save(entity);
        gateway.refresh();
        return ResponseEntity.ok(saved);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable UUID id) {
        repository.deleteById(id);
        gateway.refresh();
        return ResponseEntity.noContent().build();
    }

    private void validateSpel(String json) {
        try {
            if (json == null || json.isBlank()) return;
            JsonNode root = mapper.readTree(json);
            if (root.hasNonNull("expression")) {
                String expr = root.get("expression").asText();
                parser.parseExpression(expr);
            }
        } catch (Exception e) {
            throw new IllegalArgumentException("Erro de Sintaxe SpEL ou JSON: " + e.getMessage());
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminProviderConfigController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderConfigJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceProviderConfigEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api/admin/provider-configs")
public class AdminProviderConfigController {

    private final ServiceProviderConfigJpaRepository repository;
    private final ServiceProviderConfigGateway gateway; // Injeta o gateway para limpar cache

    public AdminProviderConfigController(ServiceProviderConfigJpaRepository repository,
                                         ServiceProviderConfigGateway gateway) {
        this.repository = repository;
        this.gateway = gateway;
    }

    @GetMapping("/{providerId}/{env}")
    public ResponseEntity<ServiceProviderConfigEntity> get(@PathVariable UUID providerId, @PathVariable String env) {
        return repository.findTopByProviderIdAndEnvironmentOrderByVersionDesc(providerId, env)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<ServiceProviderConfigEntity> upsert(@RequestBody ServiceProviderConfigEntity config) {
        if (config.getId() == null) config.setId(UUID.randomUUID());
        
        Optional<ServiceProviderConfigEntity> current = repository
            .findTopByProviderIdAndEnvironmentOrderByVersionDesc(config.getProviderId(), config.getEnvironment());
            
        config.setVersion(current.map(c -> c.getVersion() + 1).orElse(1));
        config.setUpdatedAt(LocalDateTime.now());
        
        ServiceProviderConfigEntity saved = repository.save(config);
        
        // --- LIMPEZA DE CACHE IMEDIATA ---
        gateway.refresh();
        
        return ResponseEntity.ok(saved);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminProviderController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceProviderEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/admin/providers")
public class AdminProviderController {

    private final ServiceProviderJpaRepository repository;
    private final ServiceProviderGateway gateway; // Injeta o gateway para chamar o refresh

    public AdminProviderController(ServiceProviderJpaRepository repository, ServiceProviderGateway gateway) {
        this.repository = repository;
        this.gateway = gateway;
    }

    @GetMapping
    public List<ServiceProviderEntity> list() {
        return repository.findAll();
    }

    @PostMapping
    public ResponseEntity<ServiceProviderEntity> create(@RequestBody ServiceProviderEntity entity) {
        if (entity.getId() == null) entity.setId(UUID.randomUUID());
        entity.setCreatedAt(LocalDateTime.now());
        entity.setUpdatedAt(LocalDateTime.now());
        
        ServiceProviderEntity saved = repository.save(entity);
        gateway.refresh(); // Limpa cache
        return ResponseEntity.ok(saved);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ServiceProviderEntity> update(@PathVariable UUID id, @RequestBody ServiceProviderEntity dto) {
        return repository.findById(id)
            .map(existing -> {
                existing.setName(dto.getName());
                existing.setServiceType(dto.getServiceType());
                existing.setCode(dto.getCode());
                existing.setPriority(dto.getPriority());
                existing.setDriverKey(dto.getDriverKey());
                existing.setHealthEnabled(dto.isHealthEnabled());
                existing.setEnabled(dto.isEnabled());
                existing.setUpdatedAt(LocalDateTime.now());
                
                ServiceProviderEntity saved = repository.save(existing);
                gateway.refresh(); // Limpa cache
                return ResponseEntity.ok(saved);
            })
            .orElse(ResponseEntity.notFound().build());
    }

    @PatchMapping("/{id}/toggle")
    public ResponseEntity<ServiceProviderEntity> toggle(@PathVariable UUID id, @RequestBody Boolean enabled) {
        return repository.findById(id)
                .map(provider -> {
                    provider.setEnabled(enabled);
                    provider.setUpdatedAt(LocalDateTime.now());
                    
                    ServiceProviderEntity saved = repository.save(provider);
                    gateway.refresh(); // Limpa cache
                    return ResponseEntity.ok(saved);
                })
                .orElse(ResponseEntity.notFound().build());
    }
}
