
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/driver/payment/MercadoPagoPaymentDriver.java ---
package com.atelie.ecommerce.api.serviceengine.driver.payment;

import com.atelie.ecommerce.api.serviceengine.ServiceDriver;
import com.atelie.ecommerce.api.serviceengine.util.DriverConfigReader;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Component
public class MercadoPagoPaymentDriver implements ServiceDriver {

    private final RestTemplate restTemplate;
    private final Environment env;

    public MercadoPagoPaymentDriver(RestTemplate restTemplate, Environment env) {
        this.restTemplate = restTemplate;
        this.env = env;
    }

    @Override
    public String driverKey() { return "payment.mercadopago"; }

    @Override
    public ServiceType serviceType() { return ServiceType.PAYMENT; }

    @Override
    public Map<String, Object> execute(Map<String, Object> request, Map<String, Object> config) {
        String accessToken = DriverConfigReader.requireNonBlank(
            (String) config.get("access_token"), "access_token (Config MP)"
        );

        // (opcional) pode manter vindo do config JSON
        String notificationUrl = (String) config.get("notification_url");

        BigDecimal amount = (BigDecimal) request.get("amount");
        String email = (String) request.get("email");
        String externalRef = (String) request.get("orderId");

        Map<String, Object> mpRequest = new HashMap<>();
        mpRequest.put("transaction_amount", amount);
        mpRequest.put("description", "Pedido " + externalRef);
        mpRequest.put("payment_method_id", "pix");

        Map<String, Object> payer = new HashMap<>();
        payer.put("email", email);
        mpRequest.put("payer", payer);

        if (notificationUrl != null && !notificationUrl.isBlank()) {
            mpRequest.put("notification_url", notificationUrl);
        }

        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.setBearerAuth(accessToken);
            headers.set("X-Idempotency-Key", UUID.randomUUID().toString());

            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(mpRequest, headers);

            // ENV: MP_API_URL (default antigo)
            String apiUrl = env.getProperty("MP_API_URL", "https://api.mercadopago.com/v1/payments").trim();

            Map response = restTemplate.postForObject(apiUrl, entity, Map.class);

            Map<String, Object> result = new HashMap<>();
            result.put("provider", "MERCADO_PAGO");
            result.put("status", "pending");

            if (response != null) {
                result.put("external_id", response.get("id"));

                Map poi = (Map) response.get("point_of_interaction");
                if (poi != null) {
                    Map transData = (Map) poi.get("transaction_data");
                    if (transData != null) {
                        result.put("qr_code", transData.get("qr_code"));
                        result.put("qr_code_base64", transData.get("qr_code_base64"));
                    }
                }
            }
            return result;

        } catch (Exception e) {
            return Map.of("error", true, "message", "Erro MP: " + e.getMessage());
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/JsonUtils.java ---
package com.atelie.ecommerce.api.serviceengine;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.Map;

public class JsonUtils {

    private static final ObjectMapper mapper = new ObjectMapper();

    @SuppressWarnings("unchecked")
    public static Map<String, Object> toMap(String json) {
        try {
            return mapper.readValue(json, Map.class);
        } catch (Exception e) {
            return Map.of();
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/DriverRegistry.java ---
package com.atelie.ecommerce.api.serviceengine;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Registry de drivers dispon√≠veis no c√≥digo.
 * Dashboard escolhe qual driverKey usar via DB.
 */
public class DriverRegistry {

    private final Map<String, ServiceDriver> driversByKey = new HashMap<>();

    public DriverRegistry(List<ServiceDriver> drivers) {
        for (ServiceDriver d : drivers) {
            driversByKey.put(d.driverKey(), d);
        }
    }

    public Optional<ServiceDriver> findByDriverKey(String driverKey) {
        return Optional.ofNullable(driversByKey.get(driverKey));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/util/DriverConfigReader.java ---
package com.atelie.ecommerce.api.serviceengine.util;

import java.math.BigDecimal;
import java.util.Map;

public final class DriverConfigReader {

    private DriverConfigReader() {}

    public static BigDecimal requireBigDecimal(Map<String, Object> config, String key) {
        Object v = config.get(key);
        if (v == null) {
            throw new IllegalArgumentException("Config obrigat√≥ria ausente: '" + key + "'");
        }
        try {
            return new BigDecimal(String.valueOf(v));
        } catch (Exception e) {
            throw new IllegalArgumentException("Config inv√°lida para '" + key + "': valor='" + v + "'");
        }
    }

    public static String optionalString(Map<String, Object> config, String key, String defaultValue) {
        Object v = config.get(key);
        if (v == null) return defaultValue;
        String s = String.valueOf(v);
        return s == null ? defaultValue : s;
    }

    public static String requireNonBlank(String value, String fieldName) {
        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("Campo obrigat√≥rio ausente: '" + fieldName + "'");
        }
        return value;
    }

    public static BigDecimal requireMoney(Object value, String fieldName) {
        if (value == null) {
            throw new IllegalArgumentException("Campo obrigat√≥rio ausente: '" + fieldName + "'");
        }
        if (value instanceof BigDecimal bd) return bd;
        try {
            return new BigDecimal(String.valueOf(value));
        } catch (Exception e) {
            throw new IllegalArgumentException("Campo inv√°lido '" + fieldName + "': valor='" + value + "'");
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/ServiceOrchestrator.java ---
package com.atelie.ecommerce.api.serviceengine;

import com.atelie.ecommerce.domain.service.engine.ResolvedProvider;
import com.atelie.ecommerce.domain.service.engine.ServiceContext;
import com.atelie.ecommerce.domain.service.engine.ServiceEngine;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;

public class ServiceOrchestrator {

    private final ServiceEngine engine;
    private final ServiceProviderConfigGateway configGateway;
    private final DriverRegistry driverRegistry;

    public ServiceOrchestrator(
            ServiceEngine engine,
            ServiceProviderConfigGateway configGateway,
            DriverRegistry driverRegistry
    ) {
        this.engine = engine;
        this.configGateway = configGateway;
        this.driverRegistry = driverRegistry;
    }

    public ServiceResult execute(
            ServiceType type,
            Map<String, Object> request,
            String environment
    ) {
        BigDecimal value = BigDecimal.ZERO;
        if (request.containsKey("amount")) value = toBigDecimal(request.get("amount"));
        else if (request.containsKey("subtotal")) value = toBigDecimal(request.get("subtotal"));
        else if (request.containsKey("total")) value = toBigDecimal(request.get("total"));

        Map<String, Object> attributes = new HashMap<>(request);
        
        // Usa o pa√≠s do request se existir, sen√£o default BR
        String country = (String) attributes.getOrDefault("country", "BR");
        
        ServiceContext ctx = new ServiceContext(country, value, attributes);

        ResolvedProvider resolved = engine.resolve(type, ctx);

        if (resolved == null || resolved.provider() == null) {
            return new ServiceResult(false, null, Map.of("error", "NO_PROVIDER_AVAILABLE"));
        }

        var provider = resolved.provider();
        String configJson = configGateway
                .findConfigJson(provider.code(), environment)
                .orElse("{}");
        
        var driver = driverRegistry
                .findByDriverKey(provider.driverKey())
                .orElse(null);
        
        if (driver == null) {
            return new ServiceResult(false, provider.code(), Map.of("error", "DRIVER_NOT_FOUND"));
        }

        Map<String, Object> config = JsonUtils.toMap(configJson);
        Map<String, Object> payload = driver.execute(request, config);
        
        // Se o driver reportar erro no payload (ex: timeout, recusado), propagamos como falha.
        boolean driverSuccess = !Boolean.TRUE.equals(payload.get("error"));

        return new ServiceResult(driverSuccess, provider.code(), payload);
    }

    private BigDecimal toBigDecimal(Object val) {
        if (val == null) return BigDecimal.ZERO;
        if (val instanceof BigDecimal) return (BigDecimal) val;
        try { return new BigDecimal(val.toString()); } catch (Exception e) { return BigDecimal.ZERO; }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/ServiceResult.java ---
package com.atelie.ecommerce.api.serviceengine;

import java.util.Map;

public record ServiceResult(
        boolean success,
        String providerCode,
        Map<String, Object> payload
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/ServiceDriver.java ---
package com.atelie.ecommerce.api.serviceengine;

import com.atelie.ecommerce.domain.service.model.ServiceType;

import java.util.Map;

/**
 * Contrato de driver execut√°vel (implementa√ß√£o em c√≥digo).
 * O driver √© selecionado via driverKey armazenada no banco.
 */
public interface ServiceDriver {

    String driverKey();

    ServiceType serviceType();

    Map<String, Object> execute(Map<String, Object> request, Map<String, Object> config);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/media/MediaController.java ---
package com.atelie.ecommerce.api.media;

import com.atelie.ecommerce.infrastructure.service.media.MediaStorageService;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/api/media")
public class MediaController {

    private final MediaStorageService media;

    public MediaController(MediaStorageService media) {
        this.media = media;
    }

    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> upload(
        @RequestParam("file") MultipartFile file,
        @RequestParam("type") String type,
        @RequestParam(value = "public", defaultValue = "true") boolean isPublic
    ) {
        var saved = media.upload(file, type, isPublic);
        return ResponseEntity.ok(java.util.Map.of(
            "id", saved.getId(),
            "type", saved.getType().name(),
            "mimeType", saved.getMimeType(),
            "sizeBytes", saved.getSizeBytes(),
            "isPublic", saved.isPublic(),
            "publicUrl", "/api/media/public/" + saved.getId()
        ));
    }

    @GetMapping("/public/{id}")
    public ResponseEntity<FileSystemResource> getPublic(@PathVariable("id") long id) {
        var opt = media.loadPublic(id);
        if (opt.isEmpty()) return ResponseEntity.status(HttpStatus.NOT_FOUND).build();

        var dl = opt.get();
        FileSystemResource res = new FileSystemResource(dl.path().toFile());

        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(dl.mimeType()))
            .contentLength(dl.sizeBytes())
            .header(HttpHeaders.CACHE_CONTROL, "public, max-age=31536000, immutable")
            .body(res);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/inventory/dto/InventoryBalanceResponse.java ---
package com.atelie.ecommerce.api.inventory.dto;

import java.util.UUID;

public record InventoryBalanceResponse(
    UUID productId,
    Integer currentStock
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/inventory/dto/InventoryAdjustmentRequest.java ---
package com.atelie.ecommerce.api.inventory.dto;

import com.atelie.ecommerce.domain.inventory.MovementType;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public record InventoryAdjustmentRequest(
    @NotNull(message = "Type is required (IN/OUT)")
    MovementType type,
    
    @NotNull(message = "Quantity is required")
    @Positive(message = "Quantity must be positive")
    Integer quantity,
    
    String reason,
    String referenceId
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/inventory/InventoryController.java ---
package com.atelie.ecommerce.api.inventory;

import com.atelie.ecommerce.api.inventory.dto.InventoryAdjustmentRequest;
import com.atelie.ecommerce.api.inventory.dto.InventoryBalanceResponse;
import com.atelie.ecommerce.application.service.inventory.InventoryService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/inventory")
public class InventoryController {

    private final InventoryService inventoryService;

    public InventoryController(InventoryService inventoryService) {
        this.inventoryService = inventoryService;
    }

    @GetMapping("/{variantId}")
    public ResponseEntity<InventoryBalanceResponse> getBalance(@PathVariable UUID variantId) {
        // Corre√ß√£o: Chama o servi√ßo usando o ID da Variante [cite: 281]
        Integer stock = inventoryService.getStock(variantId);
        return ResponseEntity.ok(new InventoryBalanceResponse(variantId, stock));
    }

    @PostMapping("/{variantId}")
    public ResponseEntity<Void> adjustStock(
            @PathVariable UUID variantId,
            @RequestBody @Valid InventoryAdjustmentRequest request) {
        
        inventoryService.addMovement(
                variantId, 
                request.type(), 
                request.quantity(), 
                request.reason(), 
                request.referenceId()
        );
        return ResponseEntity.ok().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/controller/FileController.java ---
package com.atelie.ecommerce.api.controller;

import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.UUID;

@RestController
@RequestMapping("/api/files")
public class FileController {

    // Caminho onde as imagens ser√£o salvas (volume docker)
    private final Path fileStorageLocation;

    public FileController() {
        this.fileStorageLocation = Paths.get("uploads").toAbsolutePath().normalize();
        try {
            Files.createDirectories(this.fileStorageLocation);
        } catch (Exception ex) {
            throw new RuntimeException("N√£o foi poss√≠vel criar o diret√≥rio de uploads.", ex);
        }
    }

    @PostMapping("/upload")
    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
        try {
            // Normaliza o nome do arquivo e gera UUID para evitar colis√£o
            String originalFileName = file.getOriginalFilename();
            String fileExtension = "";
            if (originalFileName != null && originalFileName.contains(".")) {
                fileExtension = originalFileName.substring(originalFileName.lastIndexOf("."));
            }
            String fileName = UUID.randomUUID().toString() + fileExtension;

            // Salva no disco
            Path targetLocation = this.fileStorageLocation.resolve(fileName);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);

            // Retorna a URL p√∫blica (ajustar conforme seu dom√≠nio em prod)
            String fileDownloadUri = "/api/files/view/" + fileName;

            return ResponseEntity.ok(fileDownloadUri);
        } catch (IOException ex) {
            return ResponseEntity.internalServerError().body("Falha no upload: " + ex.getMessage());
        }
    }

    @GetMapping("/view/{fileName:.+}")
    public ResponseEntity<Resource> downloadFile(@PathVariable String fileName) {
        try {
            Path filePath = this.fileStorageLocation.resolve(fileName).normalize();
            Resource resource = new UrlResource(filePath.toUri());

            if (resource.exists()) {
                // Tenta determinar o tipo de conte√∫do
                String contentType = "application/octet-stream";
                try {
                   contentType = Files.probeContentType(filePath);
                } catch (IOException ex) {
                   // fallback
                }

                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(contentType))
                        .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                        .body(resource);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (MalformedURLException ex) {
            return ResponseEntity.notFound().build();
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/shipping/service/ShippingService.java ---
package com.atelie.ecommerce.api.shipping.service;

import com.atelie.ecommerce.api.serviceengine.ServiceOrchestrator;
import com.atelie.ecommerce.api.serviceengine.ServiceResult;
import com.atelie.ecommerce.api.shipping.dto.ShippingQuoteResponse;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;

@Service
public class ShippingService {

    private final ServiceOrchestrator orchestrator;
    @Value("${spring.profiles.active:prod}")
    private String activeProfile;

    public ShippingService(ServiceOrchestrator orchestrator) {
        this.orchestrator = orchestrator;
    }

    public ShippingQuoteResponse quote(String rawCep, BigDecimal subtotal, String forcedProvider) {
        Map<String, Object> request = new HashMap<>();
        request.put("cep", rawCep);
        request.put("subtotal", subtotal);
        if (forcedProvider != null) request.put("forced_provider", forcedProvider); // Suporte futuro

        ServiceResult result = orchestrator.execute(ServiceType.SHIPPING, request, activeProfile);
        
        if (!result.success()) {
            return new ShippingQuoteResponse("ERROR", false, false, BigDecimal.ZERO, BigDecimal.ZERO);
        }

        Map<String, Object> payload = result.payload();
        
        // CORRE√á√ÉO: Usa o providerCode do orquestrador ("LOGGI", "J3") como fonte da verdade.
        // O fallback √© o payload do driver.
        String providerName = result.providerCode() != null ? result.providerCode() : (String) payload.getOrDefault("provider", "UNKNOWN");

        return new ShippingQuoteResponse(
            providerName,
            (Boolean) payload.getOrDefault("eligible", false),
            (Boolean) payload.getOrDefault("free_shipping", false),
            toBigDecimal(payload.get("cost")),
            toBigDecimal(payload.get("threshold"))
        );
    }

    private BigDecimal toBigDecimal(Object val) {
        if (val == null) return BigDecimal.ZERO;
        if (val instanceof BigDecimal) return (BigDecimal) val;
        try { return new BigDecimal(val.toString()); } catch (Exception e) { return BigDecimal.ZERO; }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/shipping/controller/ShippingController.java ---
package com.atelie.ecommerce.api.shipping.controller;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.api.shipping.dto.ShippingQuoteRequest;
import com.atelie.ecommerce.api.shipping.dto.ShippingQuoteResponse;
import com.atelie.ecommerce.api.shipping.service.ShippingService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/shipping")
public class ShippingController {

    private final ShippingService shippingService;
    private final DynamicConfigService dynamicConfigService;

    public ShippingController(ShippingService shippingService, DynamicConfigService dynamicConfigService) {
        this.shippingService = shippingService;
        this.dynamicConfigService = dynamicConfigService;
    }

    @PostMapping("/quote")
    public ResponseEntity<ShippingQuoteResponse> quote(@Valid @RequestBody ShippingQuoteRequest req) {
        return ResponseEntity.ok(shippingService.quote(req.getCep(), req.getSubtotal(), req.getProvider()));
    }

    // Endpoint operacional: recarrega cache sem restart (pode depois proteger via auth/admin)
    @PostMapping("/configs/refresh")
    public ResponseEntity<Void> refreshConfigs() {
        dynamicConfigService.refresh();
        return ResponseEntity.noContent().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/shipping/dto/ShippingQuoteRequest.java ---
package com.atelie.ecommerce.api.shipping.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public class ShippingQuoteRequest {

    @NotBlank
    private String cep;

    @NotNull
    private BigDecimal subtotal;

    // opcional: for√ßa provedor ("J3" ou "FLAT_RATE"). Se null, usa SHIPPING_PROVIDER_MODE.
    private String provider;

    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }

    public BigDecimal getSubtotal() { return subtotal; }
    public void setSubtotal(BigDecimal subtotal) { this.subtotal = subtotal; }

    public String getProvider() { return provider; }
    public void setProvider(String provider) { this.provider = provider; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/shipping/dto/ShippingQuoteResponse.java ---
package com.atelie.ecommerce.api.shipping.dto;

import java.math.BigDecimal;

public class ShippingQuoteResponse {

    private String provider;
    private boolean eligible;
    private boolean freeShippingApplied;
    private BigDecimal shippingCost;
    private BigDecimal freeShippingThreshold;

    public ShippingQuoteResponse() {}

    public ShippingQuoteResponse(String provider, boolean eligible, boolean freeShippingApplied, BigDecimal shippingCost, BigDecimal freeShippingThreshold) {
        this.provider = provider;
        this.eligible = eligible;
        this.freeShippingApplied = freeShippingApplied;
        this.shippingCost = shippingCost;
        this.freeShippingThreshold = freeShippingThreshold;
    }

    public String getProvider() { return provider; }
    public void setProvider(String provider) { this.provider = provider; }

    public boolean isEligible() { return eligible; }
    public void setEligible(boolean eligible) { this.eligible = eligible; }

    public boolean isFreeShippingApplied() { return freeShippingApplied; }
    public void setFreeShippingApplied(boolean freeShippingApplied) { this.freeShippingApplied = freeShippingApplied; }

    public BigDecimal getShippingCost() { return shippingCost; }
    public void setShippingCost(BigDecimal shippingCost) { this.shippingCost = shippingCost; }

    public BigDecimal getFreeShippingThreshold() { return freeShippingThreshold; }
    public void setFreeShippingThreshold(BigDecimal freeShippingThreshold) { this.freeShippingThreshold = freeShippingThreshold; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/ConfigBootstrap.java ---
package com.atelie.ecommerce.api.config;

import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class ConfigBootstrap implements ApplicationRunner {

    private final DynamicConfigService dynamicConfigService;

    public ConfigBootstrap(DynamicConfigService dynamicConfigService) {
        this.dynamicConfigService = dynamicConfigService;
    }

    @Override
    public void run(ApplicationArguments args) {
        // Cache inicial do motor din√¢mico
        dynamicConfigService.refresh();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/AdminBootstrap.java ---
package com.atelie.ecommerce.api.config;

import com.atelie.ecommerce.infrastructure.persistence.auth.UserRepository;
import com.atelie.ecommerce.infrastructure.persistence.auth.entity.UserEntity;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * AdminBootstrap
 * Garante que o usu√°rio Admin exista e esteja com a senha sincronizada com o .env.
 * Isso permite rota√ß√£o de senhas sem tocar no banco de dados manualmente.
 */
@Component
public class AdminBootstrap implements CommandLineRunner {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    @Value("${ADMIN_EMAIL:admin@atelie.com}")
    private String adminEmail;

    @Value("${ADMIN_PASSWORD:}")
    private String adminPassword;

    public AdminBootstrap(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    @Transactional
    public void run(String... args) {
        if (adminPassword == null || adminPassword.isBlank()) {
            System.out.println("‚ö†Ô∏è ADMIN_PASSWORD n√£o configurada. Pulando bootstrap de admin.");
            return;
        }

        userRepository.findByEmail(adminEmail).ifPresentOrElse(
            existingUser -> {
                // Usu√°rio j√° existe? Atualiza a senha para garantir sincronia com .env
                // S√≥ atualiza se o hash for diferente (evita update desnecess√°rio, mas aqui for√ßamos por seguran√ßa)
                existingUser.setPassword(passwordEncoder.encode(adminPassword));
                existingUser.setRole("ADMIN"); // Garante permiss√£o
                userRepository.save(existingUser);
                System.out.println("üîí Admin User ('" + adminEmail + "') atualizado com a senha do ambiente.");
            },
            () -> {
                // N√£o existe? Cria novo.
                UserEntity newAdmin = UserEntity.builder()
                        .id(UUID.randomUUID())
                        .name("Admin Master")
                        .email(adminEmail)
                        .password(passwordEncoder.encode(adminPassword))
                        .role("ADMIN")
                        .createdAt(LocalDateTime.now())
                        .build(); // Usando Builder do Lombok se dispon√≠vel, ou construtor padr√£o
                
                // Fallback se o Builder n√£o estiver ativo no Entity
                if (newAdmin.getName() == null) {
                    newAdmin = new UserEntity("Admin Master", adminEmail, passwordEncoder.encode(adminPassword), "ADMIN");
                }
                
                userRepository.save(newAdmin);
                System.out.println("‚ú® Admin User ('" + adminEmail + "') criado com sucesso.");
            }
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/StaticResourceConfig.java ---
package com.atelie.ecommerce.api.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.nio.file.Path;
import java.nio.file.Paths;

@Configuration
public class StaticResourceConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        Path uploadDir = Paths.get("./uploads");
        String uploadPath = uploadDir.toFile().getAbsolutePath();
        registry.addResourceHandler("/uploads/**").addResourceLocations("file:" + uploadPath + "/");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/exception/MissingConfigException.java ---
package com.atelie.ecommerce.api.config.exception;

public class MissingConfigException extends RuntimeException {
    public MissingConfigException(String key) {
        super("Config obrigat√≥ria ausente no banco: " + key);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/config/DynamicConfigService.java ---
package com.atelie.ecommerce.api.config;

import com.atelie.ecommerce.api.config.exception.MissingConfigException;
import com.atelie.ecommerce.domain.config.SystemConfig;
import com.atelie.ecommerce.domain.config.SystemConfigGateway;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.time.Clock;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class DynamicConfigService {

    private static final Logger log = LoggerFactory.getLogger(DynamicConfigService.class);
    public static final String CACHE_TTL_SECONDS_KEY = "CACHE_TTL_SECONDS";
    private static final long DEFAULT_CACHE_TTL_SECONDS = 300;

    private final SystemConfigGateway gateway;
    private final Clock clock;
    
    // Cache final e thread-safe
    private final Map<String, String> cache = new ConcurrentHashMap<>();
    
    // Volatile para garantir visibilidade
    private volatile LocalDateTime lastUpdate = LocalDateTime.MIN;

    public DynamicConfigService(SystemConfigGateway gateway, Clock clock) {
        this.gateway = gateway;
        this.clock = clock;
    }

    // M√©todo sincronizado para evitar m√∫ltiplas queries ao banco simultaneamente
    public synchronized void refresh() {
        log.info("DynamicConfigService: Recarregando configura√ß√µes...");
        cache.clear();
        for (SystemConfig c : gateway.findAll()) {
            if (c != null && c.key() != null) {
                cache.put(c.key(), c.value());
            }
        }
        lastUpdate = LocalDateTime.now(clock);
        log.info("DynamicConfigService: cache atualizado. Total chaves={}", cache.size());
    }

    private void checkCacheExpiration() {
        if (isCacheExpired()) {
            synchronized (this) {
                if (isCacheExpired()) { // Double check
                    refresh();
                }
            }
        }
    }

    private boolean isCacheExpired() {
        if (lastUpdate.equals(LocalDateTime.MIN)) return true;
        long ttlSeconds = getLongInternal(CACHE_TTL_SECONDS_KEY, DEFAULT_CACHE_TTL_SECONDS);
        return LocalDateTime.now(clock).isAfter(lastUpdate.plusSeconds(ttlSeconds));
    }

    // Helper interno que n√£o dispara refresh recursivo
    private long getLongInternal(String key, long defaultValue) {
        String val = cache.get(key);
        if (val == null) return defaultValue;
        try { return Long.parseLong(val); } catch (Exception e) { return defaultValue; }
    }

    // M√©todos p√∫blicos
    public boolean containsKey(String key) {
        checkCacheExpiration();
        return cache.containsKey(key);
    }

    public String getString(String key) {
        checkCacheExpiration();
        return cache.get(key);
    }

    public String requireString(String key) {
        String value = getString(key);
        if (value == null) throw new MissingConfigException(key);
        return value;
    }

    public BigDecimal requireBigDecimal(String key) {
        String v = requireString(key);
        try { return new BigDecimal(v.trim()); } 
        catch (Exception e) { throw new IllegalStateException("Config inv√°lida (BigDecimal) para " + key); }
    }

    public long getLong(String key, long defaultValue) {
        String v = getString(key);
        if (v == null) return defaultValue;
        try { return Long.parseLong(v.trim()); } 
        catch (Exception e) { throw new IllegalStateException("Config inv√°lida (long) para " + key); }
    }

    public boolean requireBoolean(String key) {
        String v = getString(key);
        if (v == null) throw new MissingConfigException(key);
        return Boolean.parseBoolean(v.trim());
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/OrderResponse.java ---
package com.atelie.ecommerce.api.order.dto;

import com.atelie.ecommerce.domain.order.OrderStatus;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

public record OrderResponse(
    UUID id,
    OrderStatus status,
    String source,
    String externalId,
    String customerName,
    BigDecimal totalAmount,
    LocalDateTime createdAt,
    List<OrderItemResponse> items
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/OrderItemResponse.java ---
package com.atelie.ecommerce.api.order.dto;

import java.math.BigDecimal;
import java.util.UUID;

public record OrderItemResponse(
    UUID productId,
    String productName,
    Integer quantity,
    BigDecimal unitPrice,
    BigDecimal totalPrice
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/CreateOrderRequest.java ---
package com.atelie.ecommerce.api.order.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank; // Importante!
import jakarta.validation.constraints.NotEmpty;
import java.util.List;

public record CreateOrderRequest(
    @NotBlank(message = "Source √© obrigat√≥rio") 
    String source,
    
    @NotBlank(message = "External ID √© obrigat√≥rio") 
    String externalId,
    
    @NotBlank(message = "Nome do cliente √© obrigat√≥rio") 
    String customerName,
    
    @NotEmpty(message = "Lista de itens n√£o pode ser vazia") 
    @Valid 
    List<CreateOrderItemRequest> items
) {}
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/dto/CreateOrderItemRequest.java ---
package com.atelie.ecommerce.api.order.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import java.util.UUID;

public record CreateOrderItemRequest(
    @NotNull UUID productId,
    UUID variantId, // Novo campo opcional (se produto tiver varia√ß√£o, √© obrigat√≥rio na l√≥gica)
    @NotNull @Min(1) Integer quantity
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/order/OrderController.java ---
package com.atelie.ecommerce.api.order;

import com.atelie.ecommerce.api.order.dto.CreateOrderRequest;
import com.atelie.ecommerce.api.order.dto.OrderResponse;
import com.atelie.ecommerce.api.order.dto.OrderItemResponse;
import com.atelie.ecommerce.application.service.order.OrderService;
import com.atelie.ecommerce.domain.order.OrderStatus;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderEntity;
import jakarta.validation.Valid;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private final OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @PostMapping
    public ResponseEntity<OrderResponse> createOrder(@Valid @RequestBody CreateOrderRequest request) {
        OrderEntity created = orderService.createOrder(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(toResponse(created));
    }

    @GetMapping
    public Page<OrderResponse> getAllOrders(
            @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable
    ) {
        return orderService.getAllOrders(pageable).map(this::toResponse);
    }

    // Mapper Simples
    private OrderResponse toResponse(OrderEntity entity) {
        var items = entity.getItems().stream()
                .map(i -> new OrderItemResponse(
                        i.getProduct().getId(),
                        i.getProduct().getName(),
                        i.getQuantity(),
                        i.getUnitPrice(),
                        i.getTotalPrice()
                )).collect(Collectors.toList());

        return new OrderResponse(
                entity.getId(),
                OrderStatus.valueOf(entity.getStatus()),
                entity.getSource(),
                entity.getExternalId(),
                entity.getCustomerName(),
                entity.getTotalAmount(),
                entity.getCreatedAt().atZone(java.time.ZoneId.of("UTC")).toLocalDateTime(),
                items
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/payment/dto/PaymentResponse.java ---
package com.atelie.ecommerce.api.payment.dto;

import java.math.BigDecimal;
import java.util.Map;

public record PaymentResponse(
    String status,
    String provider,
    BigDecimal amount,
    boolean sandbox,
    Map<String, Object> metadata
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/dto/DashboardSummary.java ---
package com.atelie.ecommerce.api.dashboard.dto;

import java.math.BigDecimal;

public record DashboardSummary(
    BigDecimal totalSales,
    long pendingOrders,
    long lowStockAlerts
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/ProductManagementController.java ---
package com.atelie.ecommerce.api.dashboard;

import com.atelie.ecommerce.api.catalog.product.dto.ProductResponse;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/dashboard/products")
public class ProductManagementController {

    private final ProductRepository productRepository;

    public ProductManagementController(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @GetMapping
    public List<ProductResponse> listAll() {
        // Converte Entity para DTO antes de retornar
        return productRepository.findAll().stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    // Simplificado para Dashboard (admin v√™ tudo)
    private ProductResponse toResponse(ProductEntity entity) {
        var response = new ProductResponse(
                entity.getId(),
                entity.getName(),
                entity.getDescription(),
                entity.getPrice(),
                entity.getCategoryId(),
                entity.getActive()
        );
        response.setImageUrl(entity.getImageUrl());
        return response;
    }

    @PutMapping("/{id}/toggle-alert")
    public ResponseEntity<ProductResponse> toggleAlert(@PathVariable UUID id) {
        ProductEntity product = productRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Produto n√£o encontrado"));
        product.setAlertEnabled(!Boolean.TRUE.equals(product.getAlertEnabled()));
        ProductEntity saved = productRepository.save(product);
        return ResponseEntity.ok(toResponse(saved));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/dashboard/DashboardController.java ---
package com.atelie.ecommerce.api.dashboard;

import com.atelie.ecommerce.api.dashboard.dto.DashboardSummary;
import com.atelie.ecommerce.application.service.integration.N8nService;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderRepository;
import com.atelie.ecommerce.infrastructure.persistence.inventory.InventoryRepository;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigRepository;
import com.atelie.ecommerce.infrastructure.persistence.config.SystemConfigEntity;
import com.atelie.ecommerce.api.config.DynamicConfigService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.math.BigDecimal;
import java.util.Map;

@RestController
@RequestMapping("/api/dashboard")
public class DashboardController {

    private final OrderRepository orderRepository;
    private final InventoryRepository inventoryRepository;
    private final N8nService n8nService;
    private final SystemConfigRepository configRepository;
    private final DynamicConfigService dynamicConfigService;

    public DashboardController(OrderRepository orderRepository, 
                               InventoryRepository inventoryRepository,
                               N8nService n8nService,
                               SystemConfigRepository configRepository,
                               DynamicConfigService dynamicConfigService) {
        this.orderRepository = orderRepository;
        this.inventoryRepository = inventoryRepository;
        this.n8nService = n8nService;
        this.configRepository = configRepository;
        this.dynamicConfigService = dynamicConfigService;
    }

    @GetMapping("/summary")
    public ResponseEntity<DashboardSummary> getSummary() {
        var totalSales = orderRepository.totalSalesPaid();
        if (totalSales == null) totalSales = BigDecimal.ZERO;
        
        long pending = orderRepository.countPendingOrders();
        long lowStock = inventoryRepository.countLowStockProducts(10); 

        return ResponseEntity.ok(new DashboardSummary(totalSales, pending, lowStock));
    }

    @GetMapping("/automation/status")
    public ResponseEntity<Map<String, Boolean>> getAutomationStatus() {
        return ResponseEntity.ok(Map.of("enabled", n8nService.isAutomationEnabled()));
    }

    @PostMapping("/automation/toggle")
    public ResponseEntity<Map<String, String>> toggleAutomation(@RequestBody Map<String, Boolean> body) {
        boolean enable = Boolean.TRUE.equals(body.get("enabled"));
        
        // Persiste a configura√ß√£o no banco
        SystemConfigEntity config = new SystemConfigEntity();
        config.setConfigKey("N8N_Automation_Enabled");
        config.setConfigValue(String.valueOf(enable));
        configRepository.save(config);
        
        // Atualiza cache em mem√≥ria
        dynamicConfigService.refresh();

        String status = enable ? "ATIVADA" : "DESATIVADA";
        return ResponseEntity.ok(Map.of("message", "Automa√ß√£o n8n " + status));
    }

    @PostMapping("/automation/test-trigger")
    public ResponseEntity<String> testTrigger() {
        n8nService.sendLowStockAlert("PRODUTO TESTE DASHBOARD", 5, 10);
        return ResponseEntity.ok("Disparo de teste enviado (Verifique os logs ou o n8n)");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminOrderController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.application.service.order.OrderService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;
import java.util.Map;

@RestController
@RequestMapping("/api/admin/orders")
public class AdminOrderController {

    private final OrderService orderService;

    public AdminOrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @PostMapping("/{id}/cancel")
    public ResponseEntity<Void> cancel(@PathVariable UUID id, @RequestBody(required = false) Map<String, String> body) {
        String reason = (body != null && body.containsKey("reason")) ? body.get("reason") : "Admin request";
        orderService.cancelOrder(id, reason);
        return ResponseEntity.ok().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminFeatureFlagController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.infrastructure.persistence.feature.FeatureFlagEntity;
import com.atelie.ecommerce.infrastructure.persistence.feature.FeatureFlagRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/features")
public class AdminFeatureFlagController {

    private final FeatureFlagRepository repository;

    public AdminFeatureFlagController(FeatureFlagRepository repository) {
        this.repository = repository;
    }

    @GetMapping
    public List<FeatureFlagEntity> list() {
        return repository.findAll();
    }

    @PostMapping
    public FeatureFlagEntity createOrUpdate(@RequestBody FeatureFlagEntity dto) {
        return repository.findByFlagKey(dto.getFlagKey())
                .map(existing -> {
                    existing.setEnabled(dto.isEnabled());
                    existing.setValueJson(dto.getValueJson());
                    return repository.save(existing);
                })
                .orElseGet(() -> repository.save(dto));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/admin/AdminCacheController.java ---
package com.atelie.ecommerce.api.admin;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/admin/cache")
public class AdminCacheController {

    private final DynamicConfigService dynamicConfigService;
    private final ServiceProviderGateway providerGateway;
    private final ServiceRoutingRuleGateway routingRuleGateway;
    private final ServiceProviderConfigGateway providerConfigGateway;

    public AdminCacheController(
            DynamicConfigService dynamicConfigService,
            ServiceProviderGateway providerGateway,
            ServiceRoutingRuleGateway routingRuleGateway,
            ServiceProviderConfigGateway providerConfigGateway
    ) {
        this.dynamicConfigService = dynamicConfigService;
        this.providerGateway = providerGateway;
        this.routingRuleGateway = routingRuleGateway;
        this.providerConfigGateway = providerConfigGateway;
    }

    @PostMapping("/refresh")
    public ResponseEntity<Map<String, Object>> refreshAll() {
        dynamicConfigService.refresh();
        providerGateway.refresh();
        routingRuleGateway.refresh();
        providerConfigGateway.refresh();

        return ResponseEntity.ok(Map.of(
                "ok", true,
                "message", "Caches refreshed: dynamic-config + service-engine gateways"
        ));
    }
}
