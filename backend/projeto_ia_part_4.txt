
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/engine/ServiceEngine.java ---
package com.atelie.ecommerce.domain.service.engine;

import com.atelie.ecommerce.domain.service.model.ServiceType;

/**
 * Interface Core para Motores de Serviço.
 * Define o contrato para resolução de provedores baseado em regras.
 */
public interface ServiceEngine {
    
    /**
     * Resolve qual provedor deve processar a requisição baseada no contexto.
     *
     * @param type Tipo do serviço (ex: PAYMENT, SHIPPING)
     * @param ctx Contexto da execução (dados variáveis)
     * @return O provedor resolvido e a estratégia utilizada
     */
    ResolvedProvider resolve(ServiceType type, ServiceContext ctx);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/engine/DefaultServiceEngine.java ---
package com.atelie.ecommerce.domain.service.engine;

import com.atelie.ecommerce.domain.provider.RouteContext;
import com.atelie.ecommerce.domain.provider.RuleMatch;
import com.atelie.ecommerce.domain.provider.RuleMatcher;
import com.atelie.ecommerce.domain.service.model.ServiceProvider;
import com.atelie.ecommerce.domain.service.model.ServiceRoutingRule;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

public class DefaultServiceEngine implements ServiceEngine {

    private final ServiceProviderGateway providerGateway;
    private final ServiceRoutingRuleGateway routingRuleGateway;
    private final RuleMatcher ruleMatcher;

    public DefaultServiceEngine(
            ServiceProviderGateway providerGateway,
            ServiceRoutingRuleGateway routingRuleGateway,
            RuleMatcher ruleMatcher
    ) {
        this.providerGateway = providerGateway;
        this.routingRuleGateway = routingRuleGateway;
        this.ruleMatcher = ruleMatcher;
    }

    @Override
    public ResolvedProvider resolve(ServiceType type, ServiceContext ctx) {
        List<ServiceProvider> providers = providerGateway.findEnabledByTypeOrdered(type);
        if (providers == null || providers.isEmpty()) {
            throw new IllegalStateException("No enabled providers for service type: " + type);
        }

        List<ServiceRoutingRule> rules = routingRuleGateway.findEnabledByTypeOrdered(type);
        RouteContext routeCtx = toRouteContext(ctx); // Adapter

        if (rules != null && !rules.isEmpty()) {
            for (ServiceRoutingRule rule : rules) {
                RuleMatch match = ruleMatcher.matches(routeCtx, rule.matchJson());
                if (match.matched()) {
                    String providerCode = rule.providerCode();
                    Optional<ServiceProvider> byCode = providerGateway.findByCode(type, providerCode);
                    if (byCode.isPresent() && byCode.get().enabled()) {
                        return new ResolvedProvider(byCode.get(), "RULE_MATCH: " + match.reason());
                    }
                }
            }
        }
        return new ResolvedProvider(providers.get(0), "DEFAULT_PRIORITY");
    }

    private RouteContext toRouteContext(ServiceContext ctx) {
        String cep = (String) ctx.attributes().getOrDefault("cep", "");
        
        // Mantém a lógica de fallback se ctx.orderTotal() vier zero (embora Orchestrator agora garanta)
        BigDecimal total = ctx.orderTotal();
        if ((total == null || total.compareTo(BigDecimal.ZERO) == 0) && ctx.attributes().containsKey("subtotal")) {
             Object sub = ctx.attributes().get("subtotal");
             if (sub instanceof BigDecimal) total = (BigDecimal) sub;
        }

        return new RouteContext(
            ctx.country() != null ? ctx.country() : "BR",
            cep,
            total,
            ctx.attributes() // <--- Passando o mapa completo!
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/model/ServiceProvider.java ---
package com.atelie.ecommerce.domain.service.model;

import java.util.UUID;

public record ServiceProvider(
        UUID id,
        ServiceType serviceType,
        String code,
        String name,
        boolean enabled,
        int priority,
        String driverKey,
        boolean healthEnabled
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/model/ServiceRoutingRule.java ---
package com.atelie.ecommerce.domain.service.model;

import java.util.UUID;

/**
 * matchJson / behaviorJson serão interpretados pela engine.
 * (ex.: "country=BR", "orderTotal>=200", etc)
 */
public record ServiceRoutingRule(
        UUID id,
        ServiceType serviceType,
        String providerCode,
        boolean enabled,
        int priority,
        String matchJson,
        String behaviorJson
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/model/ServiceType.java ---
package com.atelie.ecommerce.domain.service.model;

public enum ServiceType {
    SHIPPING,
    PAYMENT,
    NOTIFICATION, // Novo: Para SMS/Email via Webhook
    GENERIC       // Novo: Para automações gerais
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/port/ServiceProviderGateway.java ---
package com.atelie.ecommerce.domain.service.port;

import com.atelie.ecommerce.domain.service.model.ServiceProvider;
import com.atelie.ecommerce.domain.service.model.ServiceType;

import java.util.List;
import java.util.Optional;

public interface ServiceProviderGateway {
    List<ServiceProvider> findEnabledByTypeOrdered(ServiceType type);
    Optional<ServiceProvider> findByCode(ServiceType type, String code);
    
    // Contrato para limpeza de cache
    void refresh();
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/port/ServiceRoutingRuleGateway.java ---
package com.atelie.ecommerce.domain.service.port;

import com.atelie.ecommerce.domain.service.model.ServiceRoutingRule;
import com.atelie.ecommerce.domain.service.model.ServiceType;

import java.util.List;

public interface ServiceRoutingRuleGateway {
    List<ServiceRoutingRule> findEnabledByTypeOrdered(ServiceType type);
    
    // Contrato para limpeza de cache
    void refresh();
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/port/ServiceProviderConfigGateway.java ---
package com.atelie.ecommerce.domain.service.port;

import java.util.Optional;

public interface ServiceProviderConfigGateway {
    Optional<String> findConfigJson(String providerCode, String environment);
    
    // Novo contrato para invalidar cache
    void refresh();
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/inventory/MovementType.java ---
package com.atelie.ecommerce.domain.inventory;

public enum MovementType {
    IN,      // Entrada (compra, devolução, ajuste)
    OUT,     // Saída (venda, perda, ajuste)
    RESERVED // Reservado (carrinho, aguardando pgto)
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/inventory/event/InventoryChangedEvent.java ---
package com.atelie.ecommerce.domain.inventory.event;

import java.util.UUID;

public record InventoryChangedEvent(
    UUID productId,
    Integer newQuantity
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/config/SystemConfigKey.java ---
package com.atelie.ecommerce.domain.config;

public enum SystemConfigKey {

    // Cache / Infra
    CACHE_TTL_SECONDS,

    // Shipping
    SHIPPING_J3_RATE,
    SHIPPING_FREE_LIMIT,
    SHIPPING_ENABLED,

    // Order
    ORDER_MIN_VALUE,
    ORDER_MAX_INSTALLMENTS
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/config/SystemConfigGateway.java ---
package com.atelie.ecommerce.domain.config;

import java.util.List;

public interface SystemConfigGateway {

    List<SystemConfig> findAll();
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/config/SystemConfig.java ---
package com.atelie.ecommerce.domain.config;

public class SystemConfig {

    private final String key;
    private final String value;

    public SystemConfig(String key, String value) {
        this.key = key;
        this.value = value;
    }

    public String key() {
        return key;
    }

    public String value() {
        return value;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/order/OrderStatus.java ---
package com.atelie.ecommerce.domain.order;

public enum OrderStatus {
    PENDING,
    PAID,
    SHIPPED,
    CANCELED
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/provider/RouteContext.java ---
package com.atelie.ecommerce.domain.provider;

import java.math.BigDecimal;
import java.util.Map;
import java.util.Collections;

public record RouteContext(
        String country,
        String cep,
        BigDecimal cartTotal,
        Map<String, Object> attributes // <--- O Pulo do Gato: Acesso total aos dados
) {
    public RouteContext {
        if (attributes == null) attributes = Collections.emptyMap();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/provider/RuleMatcher.java ---
package com.atelie.ecommerce.domain.provider;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.SimpleEvaluationContext; // Import Seguro
import java.util.Iterator;

public class RuleMatcher {

    private final ObjectMapper mapper = new ObjectMapper();
    private final ExpressionParser parser = new SpelExpressionParser();

    public RuleMatch matches(RouteContext ctx, String matchJson) {
        try {
            if (matchJson == null || matchJson.isBlank()) {
                return new RuleMatch(false, "empty_rule");
            }

            JsonNode root = mapper.readTree(matchJson);

            // 1. SpEL (Modo Seguro - Read Only)
            if (root.hasNonNull("expression")) {
                String expressionString = root.get("expression").asText();
                
                if (expressionString == null || expressionString.isBlank()) {
                    return new RuleMatch(false, "empty_expression");
                }
                
                // BLINDAGEM: SimpleEvaluationContext impede execução de métodos arbitrários
                SimpleEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding()
                        .withRootObject(ctx != null ? ctx : new Object()) // Define #ctx como raiz
                        .build();
                        
                // Disponibiliza a variável #ctx explicitamente também
                if (ctx != null) {
                    context.setVariable("ctx", ctx);
                }

                Expression exp = parser.parseExpression(expressionString);
                Boolean result = exp.getValue(context, Boolean.class);

                if (Boolean.TRUE.equals(result)) return new RuleMatch(true, "spel_matched");
                else return new RuleMatch(false, "spel_mismatch");
            }

            // 2. Legado (Retrocompatibilidade)
            if (root.hasNonNull("country")) {
                String c = root.get("country").asText();
                if (ctx.country() == null || !c.equalsIgnoreCase(ctx.country())) {
                    return new RuleMatch(false, "country_mismatch");
                }
            }
            
            if (root.hasNonNull("cep_prefix") && root.get("cep_prefix").isArray()) {
                boolean prefixMatch = false;
                String ctxCep = ctx.cep() != null ? ctx.cep().replaceAll("\\D+", "") : "";
                Iterator<JsonNode> elements = root.get("cep_prefix").elements();
                while (elements.hasNext()) {
                    if (ctxCep.startsWith(elements.next().asText())) {
                        prefixMatch = true;
                        break;
                    }
                }
                if (!prefixMatch) return new RuleMatch(false, "cep_prefix_mismatch");
            }
            
            if (root.hasNonNull("min_total")) {
                double min = root.get("min_total").asDouble();
                if (ctx.cartTotal() == null || ctx.cartTotal().doubleValue() < min) {
                    return new RuleMatch(false, "min_total_mismatch");
                }
            }

            return new RuleMatch(true, "legacy_matched");

        } catch (Exception e) {
            System.err.println("Erro ao avaliar regra: " + e.getMessage());
            return new RuleMatch(false, "invalid_match_json");
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/provider/RuleMatch.java ---
package com.atelie.ecommerce.domain.provider;

public record RuleMatch(
        boolean matched,
        String reason
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/common/event/EntityChangedEvent.java ---
package com.atelie.ecommerce.domain.common.event;

import org.springframework.context.ApplicationEvent;

public class EntityChangedEvent extends ApplicationEvent {
    private final String entityType;

    public EntityChangedEvent(Object source, String entityType) {
        super(source);
        this.entityType = entityType;
    }

    public String getEntityType() {
        return entityType;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/health/HealthController.java ---
package com.atelie.ecommerce.api.health;

import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HealthController {

    @GetMapping(value = "/health", produces = "text/plain;charset=UTF-8")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType("text/plain;charset=UTF-8"))
                .body("OK");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/category/CategoryController.java ---
package com.atelie.ecommerce.api.catalog.category;

import com.atelie.ecommerce.api.catalog.category.dto.CreateCategoryRequest;
import com.atelie.ecommerce.api.catalog.category.dto.CategoryResponse;
import com.atelie.ecommerce.application.service.catalog.category.CategoryService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/categories")
public class CategoryController {

    private final CategoryService service;

    public CategoryController(CategoryService service) {
        this.service = service;
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public CategoryResponse create(@Valid @RequestBody CreateCategoryRequest request) {
        return service.create(request);
    }

    @GetMapping
    public List<CategoryResponse> list() {
        return service.list();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/category/dto/CreateCategoryRequest.java ---
package com.atelie.ecommerce.api.catalog.category.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

public class CreateCategoryRequest {

    @NotBlank(message = "name is required")
    private String name;

    @NotNull(message = "active is required")
    private Boolean active;

    public CreateCategoryRequest() {}

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public Boolean getActive() { return active; }
    public void setActive(Boolean active) { this.active = active; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/category/dto/CategoryResponse.java ---
package com.atelie.ecommerce.api.catalog.category.dto;

import java.util.UUID;

public class CategoryResponse {

    private UUID id;
    private String name;
    private Boolean active;

    public CategoryResponse(UUID id, String name, Boolean active) {
        this.id = id;
        this.name = name;
        this.active = active;
    }

    public UUID getId() { return id; }
    public String getName() { return name; }
    public Boolean getActive() { return active; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/image/ProductImageController.java ---
package com.atelie.ecommerce.api.catalog.product.image;

import com.atelie.ecommerce.api.common.exception.NotFoundException;
import com.atelie.ecommerce.application.service.file.FileStorageService;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.util.UUID;

@RestController
@RequestMapping("/api/products")
public class ProductImageController {

    private final ProductRepository productRepository;
    private final FileStorageService fileStorageService;

    public ProductImageController(ProductRepository productRepository, FileStorageService fileStorageService) {
        this.productRepository = productRepository;
        this.fileStorageService = fileStorageService;
    }

    @PostMapping("/{id}/image")
    public ResponseEntity<String> uploadImage(@PathVariable UUID id, @RequestParam("file") MultipartFile file) {
        ProductEntity product = productRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Product not found"));

        String filename = fileStorageService.save(file);
        
        // CORREÇÃO: Salva apenas o nome do arquivo no banco (ex: "uuid.jpg")
        // Isso permite mudar o domínio da aplicação sem quebrar links antigos.
        product.setImageUrl(filename);
        productRepository.save(product);

        // Retorna a URL completa apenas para quem fez o upload visualizar na hora
        String fullUri = ServletUriComponentsBuilder.fromCurrentContextPath()
                .path("/uploads/")
                .path(filename)
                .toUriString();

        return ResponseEntity.ok(fullUri);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/ProductIntegrationController.java ---
package com.atelie.ecommerce.api.catalog.product;

import com.atelie.ecommerce.api.catalog.product.dto.LinkIntegrationRequest;
import com.atelie.ecommerce.application.service.catalog.product.ProductIntegrationService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/products")
public class ProductIntegrationController {

    private final ProductIntegrationService integrationService;

    public ProductIntegrationController(ProductIntegrationService integrationService) {
        this.integrationService = integrationService;
    }

    @PostMapping("/{productId}/integrations")
    public ResponseEntity<Void> linkProduct(
            @PathVariable UUID productId,
            @RequestBody @Valid LinkIntegrationRequest request) {
        
        integrationService.linkProduct(productId, request);
        return ResponseEntity.ok().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/ProductAiController.java ---
package com.atelie.ecommerce.api.catalog.product;

import com.atelie.ecommerce.application.service.ai.AiContentService;
import com.atelie.ecommerce.application.service.catalog.product.ProductService;
import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/products")
public class ProductAiController {

    private final AiContentService aiService;
    private final ProductService productService;
    private final ProductRepository productRepository;

    public ProductAiController(AiContentService aiService, 
                               ProductService productService,
                               ProductRepository productRepository) {
        this.aiService = aiService;
        this.productService = productService;
        this.productRepository = productRepository;
    }

    @PostMapping("/{id}/ai/generate-description")
    public ResponseEntity<Map<String, String>> generateDescription(@PathVariable UUID id) {
        ProductEntity product = productService.findById(id);
        
        // Pega atributos técnicos do JSONB ou nome
        String context = "Produto do Ateliê Filhos de Aruanda";
        
        String description = aiService.generateDescription(product.getName(), context);
        
        // Opcional: Já salva no produto ou só retorna para o Admin aprovar?
        // Aqui retornamos para o Admin ver, editar e depois salvar via PUT.
        return ResponseEntity.ok(Map.of("description", description));
    }

    @PostMapping("/{id}/ai/remove-background")
    public ResponseEntity<Map<String, String>> removeBackground(@PathVariable UUID id) {
        ProductEntity product = productService.findById(id);
        
        if (product.getImageUrl() == null) {
            return ResponseEntity.badRequest().body(Map.of("error", "Produto não tem imagem"));
        }

        String newUrl = aiService.removeImageBackground(product.getImageUrl());
        
        // Atualiza automático
        product.setImageUrl(newUrl);
        productRepository.save(product); // Dispara evento de sync também!

        return ResponseEntity.ok(Map.of("newImageUrl", newUrl));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/ProductVariantController.java ---
package com.atelie.ecommerce.api.catalog.product;

import com.atelie.ecommerce.api.catalog.product.dto.CreateVariantRequest;
import com.atelie.ecommerce.application.service.catalog.product.ProductVariantService;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/products")
public class ProductVariantController {

    private final ProductVariantService service;

    public ProductVariantController(ProductVariantService service) {
        this.service = service;
    }

    @PostMapping("/{productId}/variants")
    public ResponseEntity<ProductVariantEntity> create(
            @PathVariable UUID productId,
            @RequestBody @Valid CreateVariantRequest request) {
        return ResponseEntity.ok(service.create(productId, request));
    }

    @GetMapping("/{productId}/variants")
    public ResponseEntity<List<ProductVariantEntity>> list(@PathVariable UUID productId) {
        return ResponseEntity.ok(service.listByProduct(productId));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/ProductCreateRequest.java ---
package com.atelie.ecommerce.api.catalog.product;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

/**
 * DTO para receber os dados de criação de produto.
 * Garante que recebemos o ID da categoria separadamente para validação.
 */
public record ProductCreateRequest(
    String name,
    String description,
    BigDecimal price,
    Integer stockQuantity,
    UUID categoryId,
    List<String> images
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/dto/LinkIntegrationRequest.java ---
package com.atelie.ecommerce.api.catalog.product.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

public record LinkIntegrationRequest(
    @NotNull(message = "Integration type is required")
    String integrationType, // Agora aceita "SHOPEE", "MAGALU", etc.
    
    @NotBlank(message = "External ID is required")
    String externalId,
    
    String skuExternal
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/dto/CreateVariantRequest.java ---
package com.atelie.ecommerce.api.catalog.product.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import java.math.BigDecimal;

public record CreateVariantRequest(
    @NotBlank(message = "SKU é obrigatório")
    String sku,
    
    String gtin, // Opcional (gera automático se nulo)
    
    BigDecimal price, // Opcional
    
    @NotNull
    @PositiveOrZero
    Integer initialStock,
    
    String attributesJson // JSON String: '{"tamanho": "M"}'
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/dto/CreateProductRequest.java ---
package com.atelie.ecommerce.api.catalog.product.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.util.UUID;

public class CreateProductRequest {

    @NotBlank(message = "name is required")
    private String name;

    @NotBlank(message = "description is required")
    private String description;

    @NotNull(message = "price is required")
    private BigDecimal price;

    @NotNull(message = "categoryId is required")
    private UUID categoryId;

    @NotNull(message = "active is required")
    private Boolean active;

    public CreateProductRequest() {}

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public BigDecimal getPrice() { return price; }
    public void setPrice(BigDecimal price) { this.price = price; }

    public UUID getCategoryId() { return categoryId; }
    public void setCategoryId(UUID categoryId) { this.categoryId = categoryId; }

    public Boolean getActive() { return active; }
    public void setActive(Boolean active) { this.active = active; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/dto/ProductResponse.java ---
package com.atelie.ecommerce.api.catalog.product.dto;

import java.math.BigDecimal;
import java.util.UUID;

public class ProductResponse {

    private UUID id;
    private String name;
    private String description;
    private BigDecimal price;
    private UUID categoryId;
    private Boolean active;
    private String imageUrl; // Novo campo

    public ProductResponse(UUID id, String name, String description, BigDecimal price, UUID categoryId, Boolean active) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.price = price;
        this.categoryId = categoryId;
        this.active = active;
    }

    public UUID getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public BigDecimal getPrice() { return price; }
    public UUID getCategoryId() { return categoryId; }
    public Boolean getActive() { return active; }
    
    public String getImageUrl() { return imageUrl; }
    public void setImageUrl(String imageUrl) { this.imageUrl = imageUrl; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/catalog/product/ProductController.java ---
package com.atelie.ecommerce.api.catalog.product;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductRepository;
import com.atelie.ecommerce.application.service.catalog.product.ProductService; // Import Service

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import java.nio.file.*;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductRepository productRepository;
    private final ProductService productService; // Injeção do Service
    private final Path fileStorageLocation;

    public ProductController(ProductRepository productRepository, ProductService productService) {
        this.productRepository = productRepository;
        this.productService = productService;
        
        this.fileStorageLocation = Paths.get("uploads").toAbsolutePath().normalize();
        try {
            Files.createDirectories(this.fileStorageLocation);
        } catch (Exception ex) {
            throw new RuntimeException("Erro ao criar diretório de uploads.", ex);
        }
    }

    @GetMapping
    public ResponseEntity<List<ProductEntity>> getAll() {
        return ResponseEntity.ok(productRepository.findAll());
    }

    @GetMapping("/{id}")
    public ResponseEntity<ProductEntity> getById(@PathVariable UUID id) {
        return productRepository.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // CORREÇÃO: Usa DTO e chama o Service
    @PostMapping
    public ResponseEntity<ProductEntity> create(@RequestBody ProductCreateRequest request) {
        if (request.categoryId() == null) {
            return ResponseEntity.badRequest().build(); // Validação básica
        }

        // Mapeia DTO -> Entity
        ProductEntity product = new ProductEntity();
        product.setName(request.name());
        product.setDescription(request.description());
        product.setPrice(request.price());
        product.setStockQuantity(request.stockQuantity());
        product.setImages(request.images());
        
        // Datas e defaults são tratados pelo Service ou Entity
        product.setCreatedAt(LocalDateTime.now());
        product.setUpdatedAt(LocalDateTime.now());
        product.setActive(true);

        // Delega para o Service (que resolve a Categoria e cria Variantes)
        ProductEntity savedProduct = productService.saveProduct(product, request.categoryId());
        
        return ResponseEntity.ok(savedProduct);
    }
    
    @PostMapping("/upload-image")
    public ResponseEntity<String> uploadImage(@RequestParam("file") MultipartFile file) {
        try {
            String fileName = UUID.randomUUID().toString() + "_" + file.getOriginalFilename();
            Path targetLocation = this.fileStorageLocation.resolve(fileName);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
            return ResponseEntity.ok("/uploads/" + fileName);
        } catch (IOException ex) {
            return ResponseEntity.internalServerError().body("Falha no upload");
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<ProductEntity> update(@PathVariable UUID id, @RequestBody ProductEntity productDetails) {
        // TODO: Mover lógica de update para o Service futuramente para consistência
        return productRepository.findById(id)
            .map(existing -> {
                existing.setName(productDetails.getName());
                existing.setDescription(productDetails.getDescription());
                existing.setPrice(productDetails.getPrice());
                existing.setStockQuantity(productDetails.getStockQuantity());
                existing.setImages(productDetails.getImages());
                existing.setUpdatedAt(LocalDateTime.now());
                return ResponseEntity.ok(productRepository.save(existing));
            })
            .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable UUID id) {
        if (productRepository.existsById(id)) {
            productRepository.deleteById(id);
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.notFound().build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/auth/AuthController.java ---
package com.atelie.ecommerce.api.auth;

import com.atelie.ecommerce.api.auth.dto.*;
import com.atelie.ecommerce.application.service.auth.AuthService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth") // Prefixo /api restaurado
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/register")
    public ResponseEntity<Void> register(@Valid @RequestBody RegisterRequest request) {
        authService.register(request);
        return ResponseEntity.status(HttpStatus.CREATED).build();
    }

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        String token = authService.login(request);
        return ResponseEntity.ok(new LoginResponse(token));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/auth/dto/GoogleAuthUrlResponse.java ---
package com.atelie.ecommerce.api.auth.dto;

/**
 * DTO - GoogleAuthUrlResponse
 *
 * Contrato de saída do endpoint:
 * GET /auth/google/url
 */
public class GoogleAuthUrlResponse {

    private String authUrl;

    public GoogleAuthUrlResponse() {}

    public GoogleAuthUrlResponse(String authUrl) {
        this.authUrl = authUrl;
    }

    public String getAuthUrl() {
        return authUrl;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/auth/dto/LoginRequest.java ---
package com.atelie.ecommerce.api.auth.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class LoginRequest {
    @NotBlank(message = "E-mail é obrigatório")
    @Email(message = "E-mail inválido")
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    private String password;
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/auth/dto/LoginResponse.java ---
package com.atelie.ecommerce.api.auth.dto;

import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class LoginResponse {
    private String token;
    private String name;
    private String email;

    // Construtor preventivo: permite criar apenas com o token sem quebrar o Controller
    public LoginResponse(String token) {
        this.token = token;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/auth/dto/RegisterResponse.java ---
package com.atelie.ecommerce.api.auth.dto;

import java.util.UUID;

public record RegisterResponse(
    UUID id,
    String name,
    String email
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/auth/dto/RegisterRequest.java ---
package com.atelie.ecommerce.api.auth.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class RegisterRequest {

    @NotBlank
    private String name;

    @NotBlank
    @Email
    private String email;

    @NotBlank
    private String password;
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/webhook/WebhookController.java ---
package com.atelie.ecommerce.api.webhook;

import com.atelie.ecommerce.application.service.order.OrderService;
import com.atelie.ecommerce.application.service.fiscal.InvoiceService;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderEntity;
import com.atelie.ecommerce.infrastructure.persistence.order.OrderRepository;
import com.atelie.ecommerce.api.common.exception.NotFoundException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/webhooks")
@Slf4j
public class WebhookController {

    private final OrderService orderService;
    private final OrderRepository orderRepository;
    private final InvoiceService invoiceService;

    // CORREÇÃO: Sem default value. Deve vir do ambiente obrigatoriamente.
    @Value("${WEBHOOK_SECRET}")
    private String webhookSecret;

    public WebhookController(OrderService orderService, OrderRepository orderRepository, InvoiceService invoiceService) {
        this.orderService = orderService;
        this.orderRepository = orderRepository;
        this.invoiceService = invoiceService;
    }

    @PostMapping("/mercadopago")
    public ResponseEntity<?> handleMercadoPago(
            @RequestBody Map<String, Object> payload,
            @RequestHeader(value = "X-Webhook-Token", required = false) String token) {
        
        // Fail-safe: Se a injeção falhar silenciosamente (raro, mas possível), loga erro crítico.
        if (webhookSecret == null || webhookSecret.isBlank()) {
            log.error("VIOLAÇÃO DE CONTRATO: WEBHOOK_SECRET não foi injetada pelo ambiente.");
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Configuration Error");
        }

        if (token == null) {
            log.warn("Tentativa de acesso ao Webhook sem token.");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Invalid Webhook Token");
        }

        byte[] a = token.getBytes(java.nio.charset.StandardCharsets.UTF_8);
        byte[] b = webhookSecret.getBytes(java.nio.charset.StandardCharsets.UTF_8);
        if (!java.security.MessageDigest.isEqual(a, b)) {
            log.warn("Tentativa de acesso ao Webhook com token inválido.");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Invalid Webhook Token");
        }

        // ... Lógica de processamento segue igual ...
        String orderIdStr = null;
        if (payload.containsKey("external_reference")) {
            orderIdStr = (String) payload.get("external_reference");
        } else if (payload.containsKey("order_id")) {
             orderIdStr = payload.get("order_id").toString();
        }

        if (orderIdStr == null) return ResponseEntity.ok().build();

        try {
            UUID orderId = UUID.fromString(orderIdStr);
            String statusStr = (String) payload.getOrDefault("status", "unknown");

            if ("approved".equalsIgnoreCase(statusStr)) {
                validatePaymentAmount(orderId, payload);
                orderService.approveOrder(orderId);
                invoiceService.emitInvoiceForOrder(orderId);
                log.info("Processo de NFe iniciado para pedido {}", orderId);
            } 
            else if ("rejected".equalsIgnoreCase(statusStr) || "cancelled".equalsIgnoreCase(statusStr)) {
                orderService.cancelOrder(orderId, "Pagamento " + statusStr);
            }

        } catch (Exception e) {
            log.error("Erro processando webhook ref {}", orderIdStr, e);
            if (e instanceof SecurityException) return ResponseEntity.badRequest().body(e.getMessage());
            return ResponseEntity.ok().build();
        }

        return ResponseEntity.ok().build();
    }

    private void validatePaymentAmount(UUID orderId, Map<String, Object> payload) {
        if (payload.containsKey("transaction_amount")) {
            BigDecimal paidAmount = new BigDecimal(payload.get("transaction_amount").toString());
            OrderEntity order = orderRepository.findById(orderId)
                    .orElseThrow(() -> new NotFoundException("Pedido não encontrado"));

            if (paidAmount.compareTo(order.getTotalAmount()) < 0) {
                throw new SecurityException("Valor pago menor que o total");
            }
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/driver/webhook/UniversalWebhookDriver.java ---
package com.atelie.ecommerce.api.serviceengine.driver.webhook;

import com.atelie.ecommerce.api.serviceengine.driver.GenericWebhookDriver;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.Map;

/**
 * Driver Único para qualquer integração via Webhook.
 * Identificado no banco pela driver_key 'universal.webhook'.
 */
@Component
public class UniversalWebhookDriver extends GenericWebhookDriver {

    public UniversalWebhookDriver(RestTemplate restTemplate) {
        super(restTemplate);
    }

    @Override
    public String driverKey() {
        return "universal.webhook";
    }

    @Override
    public ServiceType serviceType() {
        // Vinculado ao tipo genérico, mas atende a qualquer chamado pelo Orchestrator via driver_key
        return ServiceType.GENERIC;
    }

    @Override
    public Map<String, Object> execute(Map<String, Object> request, Map<String, Object> config) {
        return super.execute(request, config);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/driver/shipping/StandardShippingDriver.java ---
package com.atelie.ecommerce.api.serviceengine.driver.shipping;

import com.atelie.ecommerce.api.serviceengine.ServiceDriver;
import com.atelie.ecommerce.api.serviceengine.util.DriverConfigReader;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@Component
public class StandardShippingDriver implements ServiceDriver {

    @Override
    public String driverKey() { return "shipping.standard"; }

    @Override
    public ServiceType serviceType() { return ServiceType.SHIPPING; }

    @Override
    public Map<String, Object> execute(Map<String, Object> request, Map<String, Object> config) {
        BigDecimal subtotal = DriverConfigReader.requireMoney(request.get("subtotal"), "subtotal");
        String cep = (String) request.getOrDefault("cep", "");

        BigDecimal rate = DriverConfigReader.requireBigDecimal(config, "rate");
        BigDecimal threshold = DriverConfigReader.requireBigDecimal(config, "free_threshold");
        String prefixes = DriverConfigReader.optionalString(config, "cep_prefixes", "");
        String providerName = DriverConfigReader.optionalString(config, "display_name", "Standard");

        boolean eligible = true;
        if (!prefixes.isBlank() && !cep.isBlank()) {
            String cepDigits = cep.replaceAll("\\D+", "");
            eligible = Arrays.stream(prefixes.split(","))
                    .map(String::trim)
                    .anyMatch(cepDigits::startsWith);
        }

        boolean free = subtotal.compareTo(threshold) >= 0;
        BigDecimal cost = (eligible && free) ? BigDecimal.ZERO : rate;

        Map<String, Object> response = new HashMap<>();
        response.put("provider", providerName);
        response.put("cost", cost);
        response.put("eligible", eligible);
        response.put("free_shipping", free);
        return response;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/driver/GenericWebhookDriver.java ---
package com.atelie.ecommerce.api.serviceengine.driver;

import com.atelie.ecommerce.api.serviceengine.ServiceDriver;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.client.RestTemplate;

import java.util.HashMap;
import java.util.Map;

// Classe base abstrata (não é mais @Component direto)
public abstract class GenericWebhookDriver implements ServiceDriver {

    private final RestTemplate restTemplate;

    protected GenericWebhookDriver(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @Override
    @SuppressWarnings("unchecked")
    public Map<String, Object> execute(Map<String, Object> request, Map<String, Object> config) {
        String url = (String) config.get("url");
        String authToken = (String) config.get("auth_token");
        
        if (url == null) throw new IllegalArgumentException("URL obrigatória na config do Webhook");

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        if (authToken != null) headers.set("Authorization", "Bearer " + authToken);

        HttpEntity<Map<String, Object>> entity = new HttpEntity<>(request, headers);

        try {
            Map<String, Object> response = restTemplate.postForObject(url, entity, Map.class);
            Map<String, Object> result = new HashMap<>();
            result.put("provider", "WEBHOOK_" + serviceType().name());
            result.put("raw_response", response);
            
            // Mapeamento inteligente de resposta
            if (response != null) {
                if (response.containsKey("price")) result.put("cost", response.get("price"));
                if (response.containsKey("cost")) result.put("cost", response.get("cost"));
                if (response.containsKey("status")) result.put("status", response.get("status"));
            }
            return result;
        } catch (Exception e) {
            return Map.of("error", true, "message", e.getMessage());
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/api/serviceengine/driver/payment/MercadoPagoPaymentDriver.java ---
package com.atelie.ecommerce.api.serviceengine.driver.payment;

import com.atelie.ecommerce.api.serviceengine.ServiceDriver;
import com.atelie.ecommerce.api.serviceengine.util.DriverConfigReader;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Component
public class MercadoPagoPaymentDriver implements ServiceDriver {

    private final RestTemplate restTemplate;
    private final Environment env;

    public MercadoPagoPaymentDriver(RestTemplate restTemplate, Environment env) {
        this.restTemplate = restTemplate;
        this.env = env;
    }

    @Override
    public String driverKey() { return "payment.mercadopago"; }

    @Override
    public ServiceType serviceType() { return ServiceType.PAYMENT; }

    @Override
    public Map<String, Object> execute(Map<String, Object> request, Map<String, Object> config) {
        String accessToken = DriverConfigReader.requireNonBlank(
            (String) config.get("access_token"), "access_token (Config MP)"
        );

        String notificationUrl = (String) config.get("notification_url");
        BigDecimal amount = (BigDecimal) request.get("amount");
        String email = (String) request.get("email");
        String externalRef = (String) request.get("orderId");

        Map<String, Object> mpRequest = new HashMap<>();
        mpRequest.put("transaction_amount", amount);
        mpRequest.put("description", "Pedido " + externalRef);
        mpRequest.put("payment_method_id", "pix");

        Map<String, Object> payer = new HashMap<>();
        payer.put("email", email);
        mpRequest.put("payer", payer);

        if (notificationUrl != null && !notificationUrl.isBlank()) {
            mpRequest.put("notification_url", notificationUrl);
        }

        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.setBearerAuth(accessToken);
            headers.set("X-Idempotency-Key", UUID.randomUUID().toString());

            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(mpRequest, headers);

            // CORREÇÃO: Fallback hardcoded removido. Exige MP_API_URL no .env ou Config Table.
            String apiUrl = env.getProperty("MP_API_URL");
            if (apiUrl == null || apiUrl.isBlank()) {
                throw new IllegalStateException("Configuração MP_API_URL ausente no ambiente!");
            }

            Map response = restTemplate.postForObject(apiUrl.trim(), entity, Map.class);

            Map<String, Object> result = new HashMap<>();
            result.put("provider", "MERCADO_PAGO");
            result.put("status", "pending");
            if (response != null) {
                result.put("external_id", response.get("id"));
                Map poi = (Map) response.get("point_of_interaction");
                if (poi != null) {
                    Map transData = (Map) poi.get("transaction_data");
                    if (transData != null) {
                        result.put("qr_code", transData.get("qr_code"));
                        result.put("qr_code_base64", transData.get("qr_code_base64"));
                    }
                }
            }
            return result;
        } catch (Exception e) {
            return Map.of("error", true, "message", "Erro MP: " + e.getMessage());
        }
    }
}
