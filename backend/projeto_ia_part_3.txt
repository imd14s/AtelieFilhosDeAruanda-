
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/order/OrderRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.order;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.UUID;

@Repository
public interface OrderRepository extends JpaRepository<OrderEntity, UUID> {

    // Soma o total de vendas (apenas pedidos pagos ou entregues)
    @Query("SELECT COALESCE(SUM(o.totalAmount), 0) FROM OrderEntity o WHERE o.status IN ('PAID', 'SHIPPED', 'DELIVERED')")
    BigDecimal sumTotalSales();

    // Conta quantos pedidos estão pendentes
    @Query("SELECT COUNT(o) FROM OrderEntity o WHERE o.status = 'PENDING'")
    long countPendingOrders();
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/order/OrderEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.order;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "orders")
public class OrderEntity {

    @Id
    private UUID id;

    @Column(name = "customer_name")
    private String customerName;

    private String status;
    
    @Column(name = "total_amount")
    private BigDecimal totalAmount;

    // Campos exigidos pelo código legado
    private String source; // Ex: "SITE", "MERCADO_LIVRE"
    
    @Column(name = "external_id")
    private String externalId;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItemEntity> items = new ArrayList<>();

    @Column(name = "created_at")
    private Instant createdAt; // Corrigido de LocalDateTime para Instant

    @Column(name = "updated_at")
    private Instant updatedAt;

    public OrderEntity() {}

    // Getters e Setters Completos
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public String getCustomerName() { return customerName; }
    public void setCustomerName(String customerName) { this.customerName = customerName; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public BigDecimal getTotalAmount() { return totalAmount; }
    public void setTotalAmount(BigDecimal totalAmount) { this.totalAmount = totalAmount; }

    public String getSource() { return source; }
    public void setSource(String source) { this.source = source; }

    public String getExternalId() { return externalId; }
    public void setExternalId(String externalId) { this.externalId = externalId; }

    public List<OrderItemEntity> getItems() { return items; }
    public void setItems(List<OrderItemEntity> items) {
        this.items = items;
        if (items != null) {
            items.forEach(item -> item.setOrder(this));
        }
    }
    public void addItem(OrderItemEntity item) {
        items.add(item);
        item.setOrder(this);
    }

    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) createdAt = Instant.now();
        updatedAt = Instant.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = Instant.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/order/OrderItemEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.order;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import jakarta.persistence.*;
import java.math.BigDecimal;
import java.util.UUID;

@Entity
@Table(name = "order_items")
public class OrderItemEntity {

    @Id
    private UUID id;

    @ManyToOne
    @JoinColumn(name = "order_id")
    private OrderEntity order;

    // Relacionamento real com Produto (não apenas ID)
    @ManyToOne
    @JoinColumn(name = "product_id")
    private ProductEntity product;

    // Relacionamento com Variante (SKU)
    @ManyToOne
    @JoinColumn(name = "variant_id")
    private ProductVariantEntity variant;

    @Column(name = "product_name")
    private String productName;

    private Integer quantity;
    
    @Column(name = "unit_price")
    private BigDecimal unitPrice;

    @Column(name = "total_price")
    private BigDecimal totalPrice;

    public OrderItemEntity() {}

    // Getters e Setters
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public OrderEntity getOrder() { return order; }
    public void setOrder(OrderEntity order) { this.order = order; }

    public ProductEntity getProduct() { return product; }
    public void setProduct(ProductEntity product) { this.product = product; }

    public ProductVariantEntity getVariant() { return variant; }
    public void setVariant(ProductVariantEntity variant) { this.variant = variant; }

    public String getProductName() { return productName; }
    public void setProductName(String productName) { this.productName = productName; }

    public Integer getQuantity() { return quantity; }
    public void setQuantity(Integer quantity) { this.quantity = quantity; }

    public BigDecimal getUnitPrice() { return unitPrice; }
    public void setUnitPrice(BigDecimal unitPrice) { this.unitPrice = unitPrice; }

    public BigDecimal getTotalPrice() { return totalPrice; }
    public void setTotalPrice(BigDecimal totalPrice) { this.totalPrice = totalPrice; }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductIntegrationRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;
import java.util.Optional;
import java.util.List;

@Repository
public interface ProductIntegrationRepository extends JpaRepository<ProductIntegrationEntity, UUID> {
    // Busca flexível por String
    Optional<ProductIntegrationEntity> findByExternalIdAndIntegrationType(String externalId, String integrationType);
    List<ProductIntegrationEntity> findByProductId(UUID productId);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductVariantRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface ProductVariantRepository extends JpaRepository<ProductVariantEntity, UUID> {
    
    List<ProductVariantEntity> findByProductId(UUID productId);
    boolean existsBySku(String sku);

    // Decremento Atômico no Nível da VARIANTE
    @Modifying
    @Query("UPDATE ProductVariantEntity v SET v.stockQuantity = v.stockQuantity - :quantity WHERE v.id = :id AND v.stockQuantity >= :quantity")
    int decrementStock(@Param("id") UUID id, @Param("quantity") int quantity);

    // Incremento Atômico
    @Modifying
    @Query("UPDATE ProductVariantEntity v SET v.stockQuantity = v.stockQuantity + :quantity WHERE v.id = :id")
    void incrementStock(@Param("id") UUID id, @Param("quantity") int quantity);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/entity/ProductEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.product.entity;

import com.atelie.ecommerce.infrastructure.persistence.category.CategoryEntity;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;
import java.util.List;
import java.util.ArrayList;

@Entity
@Table(name = "products")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductEntity {
    @Id
    private UUID id;
    
    private String name;
    
    @Column(columnDefinition = "TEXT")
    private String description;
    
    private BigDecimal price;
    
    @Column(name = "stock_quantity")
    private Integer stockQuantity;
    
    // Suporte a lista de imagens
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "product_images", joinColumns = @JoinColumn(name = "product_id"))
    @Column(name = "image_url")
    private List<String> images;
    
    @Column(name = "active")
    private Boolean active;
    
    @Column(name = "alert_enabled")
    private Boolean alertEnabled;

    // --- CORREÇÃO: Relacionamento com Categoria Restaurado ---
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    @JsonIgnore
    private CategoryEntity category;

    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // --- MÉTODOS DE COMPATIBILIDADE ---
    public String getImageUrl() {
        return (images != null && !images.isEmpty()) ? images.get(0) : null;
    }

    public void setImageUrl(String url) {
        if (this.images == null) this.images = new ArrayList<>();
        if (url != null && !this.images.contains(url)) {
            this.images.add(0, url);
        }
    }

    // Método auxiliar exigido pelo ProductManagementController
    public UUID getCategoryId() {
        return category != null ? category.getId() : null;
    }

    @PrePersist
    protected void onCreate() {
        if (id == null) id = UUID.randomUUID();
        if (createdAt == null) createdAt = LocalDateTime.now();
        if (updatedAt == null) updatedAt = LocalDateTime.now();
        if (active == null) active = true;
        if (alertEnabled == null) alertEnabled = false;
        if (images == null) images = new ArrayList<>();
        if (stockQuantity == null) stockQuantity = 0;
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductVariantEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "product_variants")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductVariantEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    @JsonIgnore
    private ProductEntity product;

    @Column(nullable = false, unique = true)
    private String sku;

    private String gtin;

    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    private Integer stockQuantity;

    @Column(name = "attributes_json", columnDefinition = "jsonb")
    private String attributesJson;

    @Column(nullable = false)
    private Boolean active;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    public void prePersist() {
        if (this.stockQuantity == null) this.stockQuantity = 0;
        if (this.active == null) this.active = true;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductIntegrationEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import jakarta.persistence.*;
import lombok.*;
import java.util.UUID;
import java.time.LocalDateTime;

@Entity
@Table(name = "product_integrations")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductIntegrationEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @ManyToOne
    @JoinColumn(name = "product_id")
    private ProductEntity product;

    @Column(name = "integration_type", nullable = false)
    private String integrationType;

    @Column(name = "external_id")
    private String externalId;

    @Column(name = "sku_external")
    private String skuExternal;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    public ProductIntegrationEntity(ProductEntity product, String integrationType, String externalId, String skuExternal) {
        this.product = product;
        this.integrationType = integrationType;
        this.externalId = externalId;
        this.skuExternal = skuExternal;
        this.createdAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.UUID;
import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<ProductEntity, UUID> {
    
    Page<ProductEntity> findByActiveTrue(Pageable pageable);

    @Query("SELECT p FROM ProductEntity p WHERE p.stockQuantity <= 5 AND p.alertEnabled = true")
    List<ProductEntity> findCriticalStock();
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/feature/FeatureFlagRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.feature;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface FeatureFlagRepository extends JpaRepository<FeatureFlagEntity, UUID> {
    Optional<FeatureFlagEntity> findByFlagKey(String flagKey);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/feature/FeatureFlagEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.feature;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "feature_flags")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FeatureFlagEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @Column(name = "flag_key", nullable = false, unique = true)
    private String flagKey;

    @Column(nullable = false)
    private boolean enabled;

    @Column(name = "value_json", columnDefinition = "text")
    private String valueJson;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    @PreUpdate
    public void prePersist() {
        this.updatedAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/JpaServiceRoutingRuleGateway.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.model.ServiceRoutingRule;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceRoutingRuleJpaRepository;
import org.springframework.stereotype.Component;
import java.time.Clock;
import java.util.List;

@Component
public class JpaServiceRoutingRuleGateway extends BaseCachingGateway implements ServiceRoutingRuleGateway {
    private final ServiceRoutingRuleJpaRepository repository;

    public JpaServiceRoutingRuleGateway(ServiceRoutingRuleJpaRepository repository, DynamicConfigService configService, Clock clock) {
        super(configService, clock);
        this.repository = repository;
    }

    @Override
    @SuppressWarnings("unchecked")
    public List<ServiceRoutingRule> findEnabledByTypeOrdered(ServiceType type) {
        checkCache();
        return (List<ServiceRoutingRule>) genericCache.computeIfAbsent("RULES_" + type,
            k -> repository.findByServiceTypeAndEnabledOrderByPriorityAsc(type, true)
                    .stream()
                    .map(e -> new ServiceRoutingRule(
                        e.getId(), 
                        e.getServiceType(), 
                        e.getProviderCode(), // Correção: providerCode vem antes de enabled
                        e.getEnabled(), 
                        e.getPriority(), 
                        e.getMatchJson(), 
                        e.getBehaviorJson()
                    ))
                    .toList());
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/media/MediaStorageService.java ---
package com.atelie.ecommerce.infrastructure.service.media;

import com.atelie.ecommerce.infrastructure.persistence.media.MediaAssetEntity;
import com.atelie.ecommerce.infrastructure.persistence.media.MediaAssetRepository;
import com.atelie.ecommerce.infrastructure.persistence.media.MediaAssetType;
import org.springframework.core.env.Environment;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.nio.file.*;
import java.security.MessageDigest;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class MediaStorageService {

    private final MediaAssetRepository repo;
    private final Environment env;

    public MediaStorageService(MediaAssetRepository repo, Environment env) {
        this.repo = repo;
        this.env = env;
    }

    public MediaAssetEntity upload(MultipartFile file, String type, boolean isPublic) {
        if (file == null || file.isEmpty()) throw new IllegalArgumentException("file is required");

        MediaAssetType assetType = parseType(type);

        long maxBytes = maxUploadBytes();
        if (file.getSize() > maxBytes) throw new IllegalArgumentException("file too large");

        String mime = normalizeMime(file.getContentType());
        ensureAllowedMime(assetType, mime);

        String ext = safeExtensionFromMime(mime);
        String uuid = UUID.randomUUID().toString();
        String storageKey = "media/" + uuid + ext;

        Path baseDir = Paths.get(env.getProperty("UPLOAD_DIR", "/app/uploads")).toAbsolutePath().normalize();
        Path target = baseDir.resolve(storageKey).normalize();
        if (!target.startsWith(baseDir)) throw new IllegalStateException("invalid storage path");

        try {
            Files.createDirectories(target.getParent());

            String sha = sha256Hex(file.getInputStream());

            Path tmp = Files.createTempFile(target.getParent(), "upload-", ".tmp");
            Files.copy(file.getInputStream(), tmp, StandardCopyOption.REPLACE_EXISTING);
            Files.move(tmp, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);

            MediaAssetEntity entity = new MediaAssetEntity();
            entity.setType(assetType);
            entity.setStorageKey(storageKey);
            entity.setOriginalFilename(safeOriginalName(file.getOriginalFilename()));
            entity.setMimeType(mime);
            entity.setSizeBytes(file.getSize());
            entity.setChecksumSha256(sha);
            entity.setPublic(isPublic);

            return repo.save(entity);
        } catch (Exception e) {
            throw new RuntimeException("failed to store media", e);
        }
    }

    public Optional<MediaDownload> loadPublic(long id) {
        return repo.findById(id).filter(MediaAssetEntity::isPublic).flatMap(this::loadEntity);
    }

    private Optional<MediaDownload> loadEntity(MediaAssetEntity entity) {
        Path baseDir = Paths.get(env.getProperty("UPLOAD_DIR", "/app/uploads")).toAbsolutePath().normalize();
        Path target = baseDir.resolve(entity.getStorageKey()).normalize();
        if (!target.startsWith(baseDir)) return Optional.empty();
        if (!Files.exists(target) || !Files.isRegularFile(target)) return Optional.empty();
        return Optional.of(new MediaDownload(target, entity.getMimeType(), entity.getSizeBytes()));
    }

    private MediaAssetType parseType(String raw) {
        if (raw == null) throw new IllegalArgumentException("type is required (IMAGE|VIDEO)");
        try { return MediaAssetType.valueOf(raw.trim().toUpperCase(Locale.ROOT)); }
        catch (Exception e) { throw new IllegalArgumentException("invalid type (IMAGE|VIDEO)"); }
    }

    private long maxUploadBytes() {
        String mbRaw = env.getProperty("MAX_UPLOAD_MB", "30").trim();
        long mb = Long.parseLong(mbRaw);
        if (mb < 1) mb = 1;
        return mb * 1024L * 1024L;
    }

    private String normalizeMime(String ct) {
        if (!StringUtils.hasText(ct)) return MediaType.APPLICATION_OCTET_STREAM_VALUE;
        return ct.trim().toLowerCase(Locale.ROOT);
    }

    private void ensureAllowedMime(MediaAssetType type, String mime) {
        Set<String> allowed = allowedMimes(type);
        if (!allowed.contains(mime)) throw new IllegalArgumentException("mime not allowed: " + mime);
    }

    private Set<String> allowedMimes(MediaAssetType type) {
        String raw = (type == MediaAssetType.IMAGE)
            ? env.getProperty("ALLOWED_IMAGE_MIME", "image/jpeg,image/png,image/webp")
            : env.getProperty("ALLOWED_VIDEO_MIME", "video/mp4,video/webm");

        return Arrays.stream(raw.split(","))
            .map(String::trim)
            .filter(s -> !s.isBlank())
            .map(s -> s.toLowerCase(Locale.ROOT))
            .collect(Collectors.toSet());
    }

    private String safeExtensionFromMime(String mime) {
        return switch (mime) {
            case "image/jpeg" -> ".jpg";
            case "image/png" -> ".png";
            case "image/webp" -> ".webp";
            case "video/mp4" -> ".mp4";
            case "video/webm" -> ".webm";
            default -> "";
        };
    }

    private String safeOriginalName(String original) {
        if (original == null) return null;
        String name = original.replace("\\", "/");
        name = name.substring(name.lastIndexOf('/') + 1);
        name = name.replaceAll("[^A-Za-z0-9._-]", "_");
        if (name.length() > 120) name = name.substring(name.length() - 120);
        return name;
    }

    private static String sha256Hex(InputStream in) throws Exception {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] buf = new byte[8192];
        int r;
        while ((r = in.read(buf)) > 0) md.update(buf, 0, r);
        byte[] dig = md.digest();
        StringBuilder sb = new StringBuilder();
        for (byte b : dig) sb.append(String.format("%02x", b));
        return sb.toString();
    }

    public record MediaDownload(Path path, String mimeType, long sizeBytes) {}
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/ServiceEngineConfig.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.serviceengine.DriverRegistry;
import com.atelie.ecommerce.api.serviceengine.ServiceDriver;
import com.atelie.ecommerce.api.serviceengine.ServiceOrchestrator;
import com.atelie.ecommerce.domain.provider.RuleMatcher;
import com.atelie.ecommerce.domain.service.engine.DefaultServiceEngine;
import com.atelie.ecommerce.domain.service.engine.ServiceEngine;
import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class ServiceEngineConfig {

    @Bean
    public RuleMatcher ruleMatcher() {
        return new RuleMatcher();
    }

    @Bean
    public DriverRegistry driverRegistry(List<ServiceDriver> drivers) {
        return new DriverRegistry(drivers);
    }

    @Bean
    public ServiceEngine domainServiceEngine(
            ServiceProviderGateway providerGateway,
            ServiceRoutingRuleGateway routingRuleGateway,
            RuleMatcher ruleMatcher
    ) {
        return new DefaultServiceEngine(providerGateway, routingRuleGateway, ruleMatcher);
    }

    @Bean
    public ServiceOrchestrator serviceOrchestrator(
            ServiceEngine engine,
            ServiceProviderConfigGateway configGateway,
            DriverRegistry driverRegistry
    ) {
        return new ServiceOrchestrator(engine, configGateway, driverRegistry);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/BaseCachingGateway.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.common.event.EntityChangedEvent;
import org.springframework.context.event.EventListener;
import java.time.Clock;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public abstract class BaseCachingGateway {
    protected final DynamicConfigService configService;
    protected final Clock clock;
    protected LocalDateTime lastUpdate = LocalDateTime.MIN;
    protected final Map<String, Object> genericCache = new ConcurrentHashMap<>();

    protected BaseCachingGateway(DynamicConfigService configService, Clock clock) {
        this.configService = configService;
        this.clock = clock;
    }

    @EventListener
    public void handleEntityChanged(EntityChangedEvent event) {
        refresh();
    }

    protected void checkCache() {
        if (lastUpdate.equals(LocalDateTime.MIN)) {
            lastUpdate = LocalDateTime.now(clock);
            return;
        }
        if (LocalDateTime.now(clock).isAfter(lastUpdate.plusSeconds(configService.getLong("CACHE_TTL_SECONDS", 300)))) {
            refresh();
        }
    }

    public synchronized void refresh() {
        genericCache.clear();
        lastUpdate = LocalDateTime.now(clock);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/JpaServiceProviderConfigGateway.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderConfigJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderJpaRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class JpaServiceProviderConfigGateway implements ServiceProviderConfigGateway {

    private static final Logger log = LoggerFactory.getLogger(JpaServiceProviderConfigGateway.class);

    private final ServiceProviderJpaRepository providerRepo;
    private final ServiceProviderConfigJpaRepository configRepo;
    private final DynamicConfigService dynamicConfigService;
    private final Clock clock;

    private final Map<String, String> cache = new ConcurrentHashMap<>();
    private LocalDateTime lastUpdate = LocalDateTime.MIN;

    public JpaServiceProviderConfigGateway(
            ServiceProviderJpaRepository providerRepo,
            ServiceProviderConfigJpaRepository configRepo,
            DynamicConfigService dynamicConfigService,
            Clock clock
    ) {
        this.providerRepo = providerRepo;
        this.configRepo = configRepo;
        this.dynamicConfigService = dynamicConfigService;
        this.clock = clock;
    }

    private long ttlSeconds() {
        return dynamicConfigService.getLong(DynamicConfigService.CACHE_TTL_SECONDS_KEY, 300);
    }

    private void checkCache() {
        if (lastUpdate.equals(LocalDateTime.MIN)) return;
        if (LocalDateTime.now(clock).isAfter(lastUpdate.plusSeconds(ttlSeconds()))) {
            refresh();
        }
    }

    @Override
    public Optional<String> findConfigJson(String providerCode, String environment) {
        checkCache();

        String key = providerCode + ":" + environment;
        if (cache.containsKey(key)) return Optional.of(cache.get(key));

        UUID providerId = providerRepo.findByCode(providerCode).map(p -> p.getId()).orElse(null);
        if (providerId == null) return Optional.empty();

        Optional<String> json = configRepo
                .findTopByProviderIdAndEnvironmentOrderByVersionDesc(providerId, environment)
                .map(c -> c.getConfigJson());

        json.ifPresent(j -> cache.put(key, j));
        if (lastUpdate.equals(LocalDateTime.MIN)) lastUpdate = LocalDateTime.now(clock);
        return json;
    }

    @Override
    public void refresh() {
        cache.clear();
        lastUpdate = LocalDateTime.now(clock);
        log.info("ServiceProviderConfig cache cleared.");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/JpaServiceProviderGateway.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.model.ServiceProvider;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderJpaRepository;
import org.springframework.stereotype.Component;
import java.time.Clock;
import java.util.List;

@Component
public class JpaServiceProviderGateway extends BaseCachingGateway implements ServiceProviderGateway {
    private final ServiceProviderJpaRepository repository;

    public JpaServiceProviderGateway(ServiceProviderJpaRepository repository, DynamicConfigService configService, Clock clock) {
        super(configService, clock);
        this.repository = repository;
    }

    @Override
    @SuppressWarnings("unchecked")
    public List<ServiceProvider> findEnabledByTypeOrdered(ServiceType type) {
        checkCache();
        return (List<ServiceProvider>) genericCache.computeIfAbsent("LIST_" + type, 
            k -> repository.findByServiceTypeAndEnabledOrderByPriorityAsc(type, true)
                    .stream().map(e -> new ServiceProvider(
                        e.getId(), 
                        e.getServiceType(), 
                        e.getCode(), 
                        e.getName(), 
                        e.getEnabled(), 
                        e.getPriority(), 
                        e.getDriverKey(), 
                        e.getHealthEnabled()
                    ))
                    .toList());
    }

    @Override
    public java.util.Optional<ServiceProvider> findByCode(ServiceType type, String code) {
        return repository.findByServiceTypeAndEnabledOrderByPriorityAsc(type, true)
                .stream()
                .filter(e -> e.getCode().equalsIgnoreCase(code))
                .findFirst()
                .map(e -> new ServiceProvider(
                    e.getId(), 
                    e.getServiceType(), // Correção: Passa Enum direto
                    e.getCode(), 
                    e.getName(), 
                    e.getEnabled(), 
                    e.getPriority(), 
                    e.getDriverKey(), 
                    e.getHealthEnabled()
                ));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/config/ClockConfig.java ---
package com.atelie.ecommerce.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Clock;

@Configuration
public class ClockConfig {

    @Bean
    public Clock systemClock() {
        return Clock.systemUTC();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/config/OpenApiConfig.java ---
package com.atelie.ecommerce.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI ecommerceOpenAPI() {
        return new OpenAPI()
                .info(new Info().title("Ecommerce Core API")
                .description("API 100% Mutável com Service Engine Dinâmico")
                .version("v1.0"));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/config/security/SecurityConfig.java ---
package com.atelie.ecommerce.infrastructure.config.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .csrf(csrf -> csrf.disable()) // Desabilitado para APIs REST
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/health", "/api/products/**", "/api/categories/**", "/api/dashboard/**").permitAll()
                .anyRequest().permitAll() // Temporariamente liberado para debug
            );
        
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000", "http://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/config/AsyncConfig.java ---
package com.atelie.ecommerce.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync // <--- Agora o @Async do listener funciona de verdade
public class AsyncConfig {
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/http/RestTemplateConfig.java ---
package com.atelie.ecommerce.infrastructure.http;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
import java.time.Duration;

@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .setConnectTimeout(Duration.ofSeconds(5)) // 5s para conectar
                .setReadTimeout(Duration.ofSeconds(10))   // 10s para receber dados
                .build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/PasswordConfig.java ---
package com.atelie.ecommerce.infrastructure.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/AuthenticationConfig.java ---
package com.atelie.ecommerce.infrastructure.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class AuthenticationConfig {

    @Bean
    public AuthenticationProvider authenticationProvider(
            UserDetailsService userDetailsService,
            PasswordEncoder passwordEncoder
    ) {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder);
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/TokenProvider.java ---
package com.atelie.ecommerce.infrastructure.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import java.security.Key;
import java.util.Date;
import java.util.List;
import java.util.function.Function;

@Component
public class TokenProvider {

    @Value("${JWT_SECRET}")
    private String secret;

    // ENV: JWT_EXPIRATION_MS (ex: 86400000)
    @Value("${JWT_EXPIRATION_MS}")
    private long expirationMs;

    // ENV: JWT_ROLES_CLAIM (default "roles")
    @Value("${JWT_ROLES_CLAIM:roles}")
    private String rolesClaim;

    private Key key;

    @PostConstruct
    public void init() {
        byte[] keyBytes = io.jsonwebtoken.io.Decoders.BASE64.decode(secret);
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateToken(Authentication authentication) {
        UserDetails userPrincipal = (UserDetails) authentication.getPrincipal();

        List<String> roles = authentication.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        return Jwts.builder()
            .setSubject(userPrincipal.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expirationMs))
            .claim(rolesClaim, roles)
            .signWith(key, SignatureAlgorithm.HS256)
            .compact();
    }

    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }

    public List<String> getRolesFromToken(String token) {
        Claims claims = getAllClaims(token);
        Object raw = claims.get(rolesClaim);

        if (raw == null) return List.of();

        if (raw instanceof List<?>) {
            return ((List<?>) raw).stream().map(String::valueOf).toList();
        }

        // fallback seguro (se vier string única)
        return List.of(String.valueOf(raw));
    }

    public boolean validateTokenBasic(String token) {
        // parse valida assinatura; expiração validamos abaixo
        getAllClaims(token);
        return !isTokenExpired(token);
    }

    public boolean validateTokenWithUserDetails(String token, UserDetails userDetails) {
        final String username = getUsernameFromToken(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    private Claims getAllClaims(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(key)
            .build()
            .parseClaimsJws(token)
            .getBody();
    }

    private <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private boolean isTokenExpired(String token) {
        final Date expiration = getClaimFromToken(token, Claims::getExpiration);
        return expiration.before(new Date());
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/CustomUserDetailsService.java ---
package com.atelie.ecommerce.infrastructure.security;

import com.atelie.ecommerce.infrastructure.persistence.auth.UserRepository;
import com.atelie.ecommerce.infrastructure.persistence.auth.entity.UserEntity;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        UserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));

        // CORREÇÃO: Converte a role do banco (ex: "ADMIN") para Authority ("ROLE_ADMIN")
        String roleName = user.getRole() == null ? "USER" : user.getRole().toUpperCase();
        if (!roleName.startsWith("ROLE_")) {
            roleName = "ROLE_" + roleName;
        }

        return new User(
            user.getEmail(), 
            user.getPassword(), 
            List.of(new SimpleGrantedAuthority(roleName))
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/JwtAuthenticationFilter.java ---
package com.atelie.ecommerce.infrastructure.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.core.env.Environment;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final TokenProvider tokenProvider;
    private final CustomUserDetailsService userDetailsService;
    private final Environment env;

    public JwtAuthenticationFilter(TokenProvider tokenProvider,
                                   CustomUserDetailsService userDetailsService,
                                   Environment env) {
        this.tokenProvider = tokenProvider;
        this.userDetailsService = userDetailsService;
        this.env = env;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {

        String header = request.getHeader("Authorization");
        if (header == null || !header.startsWith("Bearer ")) {
            chain.doFilter(request, response);
            return;
        }

        String token = header.substring(7);

        String username;
        try {
            username = tokenProvider.getUsernameFromToken(token);
        } catch (Exception e) {
            logger.error("Invalid JWT (cannot extract subject)", e);
            chain.doFilter(request, response);
            return;
        }

        if (username == null || SecurityContextHolder.getContext().getAuthentication() != null) {
            chain.doFilter(request, response);
            return;
        }

        boolean useClaimRoles = Boolean.parseBoolean(env.getProperty("JWT_USE_CLAIM_ROLES", "true"));

        try {
            if (useClaimRoles) {
                List<String> roles = tokenProvider.getRolesFromToken(token);

                // Só aplica stateless se o token realmente tiver roles
                if (!roles.isEmpty() && tokenProvider.validateTokenBasic(token)) {
                    var authorities = roles.stream()
                        .map(SimpleGrantedAuthority::new)
                        .toList();

                    UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(username, null, authorities);

                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authToken);

                    chain.doFilter(request, response);
                    return;
                }
            }

            // Fallback: modo antigo (depende de UserDetails/DB)
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            if (tokenProvider.validateTokenWithUserDetails(token, userDetails)) {
                UsernamePasswordAuthenticationToken authToken =
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }

        } catch (Exception e) {
            logger.error("JWT validation failed", e);
        }

        chain.doFilter(request, response);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/catalog/event/ProductSavedEvent.java ---
package com.atelie.ecommerce.domain.catalog.event;

import java.util.UUID;

/**
 * Evento de domínio emitido quando um produto é salvo/criado.
 *
 * Esse evento é usado para disparar integrações assíncronas (ex.: sync multicanal),
 * sem acoplar o core a um provider específico.
 */
public record ProductSavedEvent(
        UUID productId,
        boolean isNew
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/engine/ServiceContext.java ---
package com.atelie.ecommerce.domain.service.engine;

import java.math.BigDecimal;
import java.util.Map;

public record ServiceContext(
        String country,
        BigDecimal orderTotal,
        Map<String, Object> attributes
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/engine/ResolvedProvider.java ---
package com.atelie.ecommerce.domain.service.engine;

import com.atelie.ecommerce.domain.service.model.ServiceProvider;

public record ResolvedProvider(
        ServiceProvider provider,
        String reason
) {}
