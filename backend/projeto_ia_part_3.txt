
--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/order/OrderEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.order;

import jakarta.persistence.*;
import lombok.Data;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "orders")
@Data
public class OrderEntity {

    @Id
    @Column(name = "id", nullable = false)
    private UUID id;

    @Column(name = "source", nullable = false)
    private String source;

    @Column(name = "external_id", nullable = false)
    private String externalId;

    @Column(name = "customer_name")
    private String customerName;

    @Column(name = "customer_email")
    private String customerEmail;

    @Column(name = "total_amount", nullable = false)
    private BigDecimal totalAmount;

    @Column(name = "status", nullable = false)
    private String status;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    // --- CORRE√á√ÉO DE CONCORR√äNCIA ---
    @Version
    private Long version;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<OrderItemEntity> items;
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/order/OrderItemEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.order;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.atelie.ecommerce.infrastructure.persistence.product.ProductVariantEntity;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;
import java.math.BigDecimal;
import java.util.UUID;

@Entity
@Table(name = "order_items")
@Data
public class OrderItemEntity {

    @Id
    private UUID id;

    @JsonIgnore
    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private OrderEntity order;

    @ManyToOne
    @JoinColumn(name = "product_id", nullable = false)
    private ProductEntity product;

    // --- CORRE√á√ÉO CR√çTICA: Mapeamento da Variante ---
    @ManyToOne
    @JoinColumn(name = "variant_id", nullable = true) // Nullable para suportar legado
    private ProductVariantEntity variant;

    @Column(nullable = false)
    private Integer quantity;

    @Column(name = "unit_price", nullable = false)
    private BigDecimal unitPrice;

    @Column(name = "total_price", nullable = false)
    private BigDecimal totalPrice;
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductIntegrationRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;
import java.util.Optional;
import java.util.List;

@Repository
public interface ProductIntegrationRepository extends JpaRepository<ProductIntegrationEntity, UUID> {
    // Busca flex√≠vel por String
    Optional<ProductIntegrationEntity> findByExternalIdAndIntegrationType(String externalId, String integrationType);
    List<ProductIntegrationEntity> findByProductId(UUID productId);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductVariantRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface ProductVariantRepository extends JpaRepository<ProductVariantEntity, UUID> {
    
    List<ProductVariantEntity> findByProductId(UUID productId);
    boolean existsBySku(String sku);

    // Decremento At√¥mico no N√≠vel da VARIANTE
    @Modifying
    @Query("UPDATE ProductVariantEntity v SET v.stockQuantity = v.stockQuantity - :quantity WHERE v.id = :id AND v.stockQuantity >= :quantity")
    int decrementStock(@Param("id") UUID id, @Param("quantity") int quantity);

    // Incremento At√¥mico
    @Modifying
    @Query("UPDATE ProductVariantEntity v SET v.stockQuantity = v.stockQuantity + :quantity WHERE v.id = :id")
    void incrementStock(@Param("id") UUID id, @Param("quantity") int quantity);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/entity/ProductEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.product.entity;

import com.atelie.ecommerce.infrastructure.persistence.category.CategoryEntity;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;
import java.util.List;
import java.util.ArrayList;

@Entity
@Table(name = "products")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductEntity {
    @Id
    private UUID id;
    
    private String name;
    
    @Column(columnDefinition = "TEXT")
    private String description;
    
    private BigDecimal price;
    
    @Column(name = "stock_quantity")
    private Integer stockQuantity;
    
    // Suporte a lista de imagens
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "product_images", joinColumns = @JoinColumn(name = "product_id"))
    @Column(name = "image_url")
    private List<String> images;
    
    @Column(name = "active")
    private Boolean active;
    
    @Column(name = "alert_enabled")
    private Boolean alertEnabled;

    // --- CORRE√á√ÉO: Relacionamento com Categoria Restaurado ---
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    @JsonIgnore
    private CategoryEntity category;

    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // --- M√âTODOS DE COMPATIBILIDADE ---
    public String getImageUrl() {
        return (images != null && !images.isEmpty()) ? images.get(0) : null;
    }

    public void setImageUrl(String url) {
        if (this.images == null) this.images = new ArrayList<>();
        if (url != null && !this.images.contains(url)) {
            this.images.add(0, url);
        }
    }

    // M√©todo auxiliar exigido pelo ProductManagementController
    public UUID getCategoryId() {
        return category != null ? category.getId() : null;
    }

    @PrePersist
    protected void onCreate() {
        if (id == null) id = UUID.randomUUID();
        if (createdAt == null) createdAt = LocalDateTime.now();
        if (updatedAt == null) updatedAt = LocalDateTime.now();
        if (active == null) active = true;
        if (alertEnabled == null) alertEnabled = false;
        if (images == null) images = new ArrayList<>();
        if (stockQuantity == null) stockQuantity = 0;
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductVariantEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "product_variants")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductVariantEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    @JsonIgnore
    private ProductEntity product;

    @Column(nullable = false, unique = true)
    private String sku;

    private String gtin;

    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    private Integer stockQuantity;

    @Column(name = "attributes_json", columnDefinition = "jsonb")
    private String attributesJson;

    @Column(nullable = false)
    private Boolean active;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    public void prePersist() {
        if (this.stockQuantity == null) this.stockQuantity = 0;
        if (this.active == null) this.active = true;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductIntegrationEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;
import jakarta.persistence.*;
import lombok.*;
import java.util.UUID;
import java.time.LocalDateTime;

@Entity
@Table(name = "product_integrations")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductIntegrationEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @ManyToOne
    @JoinColumn(name = "product_id")
    private ProductEntity product;

    @Column(name = "integration_type", nullable = false)
    private String integrationType;

    @Column(name = "external_id")
    private String externalId;

    @Column(name = "sku_external")
    private String skuExternal;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    public ProductIntegrationEntity(ProductEntity product, String integrationType, String externalId, String skuExternal) {
        this.product = product;
        this.integrationType = integrationType;
        this.externalId = externalId;
        this.skuExternal = skuExternal;
        this.createdAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/product/ProductRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.product;

import com.atelie.ecommerce.infrastructure.persistence.product.entity.ProductEntity;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.UUID;
import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<ProductEntity, UUID> {
    
    Page<ProductEntity> findByActiveTrue(Pageable pageable);

    @Query("SELECT p FROM ProductEntity p WHERE p.stockQuantity <= 5 AND p.alertEnabled = true")
    List<ProductEntity> findCriticalStock();
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/feature/FeatureFlagRepository.java ---
package com.atelie.ecommerce.infrastructure.persistence.feature;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface FeatureFlagRepository extends JpaRepository<FeatureFlagEntity, UUID> {
    Optional<FeatureFlagEntity> findByFlagKey(String flagKey);
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/persistence/feature/FeatureFlagEntity.java ---
package com.atelie.ecommerce.infrastructure.persistence.feature;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "feature_flags")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FeatureFlagEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @Column(name = "flag_key", nullable = false, unique = true)
    private String flagKey;

    @Column(nullable = false)
    private boolean enabled;

    @Column(name = "value_json", columnDefinition = "text")
    private String valueJson;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    @PreUpdate
    public void prePersist() {
        this.updatedAt = LocalDateTime.now();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/JpaServiceRoutingRuleGateway.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.model.ServiceRoutingRule;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceRoutingRuleJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceRoutingRuleEntity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Component
public class JpaServiceRoutingRuleGateway implements ServiceRoutingRuleGateway {

    private static final Logger log = LoggerFactory.getLogger(JpaServiceRoutingRuleGateway.class);

    private final ServiceRoutingRuleJpaRepository repo;
    private final DynamicConfigService dynamicConfigService;
    private final Clock clock;

    private final Map<String, List<ServiceRoutingRule>> cache = new ConcurrentHashMap<>();
    private LocalDateTime lastUpdate = LocalDateTime.MIN;

    public JpaServiceRoutingRuleGateway(ServiceRoutingRuleJpaRepository repo, DynamicConfigService dynamicConfigService, Clock clock) {
        this.repo = repo;
        this.dynamicConfigService = dynamicConfigService;
        this.clock = clock;
    }

    private long ttlSeconds() {
        return dynamicConfigService.getLong(DynamicConfigService.CACHE_TTL_SECONDS_KEY, 300);
    }

    private void checkCache() {
        if (lastUpdate.equals(LocalDateTime.MIN)) return;
        if (LocalDateTime.now(clock).isAfter(lastUpdate.plusSeconds(ttlSeconds()))) {
            refresh();
        }
    }

    @Override
    public List<ServiceRoutingRule> findEnabledByTypeOrdered(ServiceType type) {
        checkCache();

        return cache.computeIfAbsent(type.name(), k ->
                repo.findByServiceTypeAndEnabledOrderByPriorityAsc(k, true)
                        .stream()
                        .map(this::toDomain)
                        .collect(Collectors.toList())
        );
    }

    @Override
    public void refresh() {
        cache.clear();
        lastUpdate = LocalDateTime.now(clock);
        log.info("ServiceRoutingRuleGateway cache cleared.");
    }

    private ServiceRoutingRule toDomain(ServiceRoutingRuleEntity e) {
        return new ServiceRoutingRule(
                e.getId(),
                ServiceType.valueOf(e.getServiceType()),
                e.getProviderCode(),
                e.isEnabled(),
                e.getPriority(),
                e.getMatchJson(),
                e.getBehaviorJson()
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/media/MediaStorageService.java ---
package com.atelie.ecommerce.infrastructure.service.media;

import com.atelie.ecommerce.infrastructure.persistence.media.MediaAssetEntity;
import com.atelie.ecommerce.infrastructure.persistence.media.MediaAssetRepository;
import com.atelie.ecommerce.infrastructure.persistence.media.MediaAssetType;
import org.springframework.core.env.Environment;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.nio.file.*;
import java.security.MessageDigest;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class MediaStorageService {

    private final MediaAssetRepository repo;
    private final Environment env;

    public MediaStorageService(MediaAssetRepository repo, Environment env) {
        this.repo = repo;
        this.env = env;
    }

    public MediaAssetEntity upload(MultipartFile file, String type, boolean isPublic) {
        if (file == null || file.isEmpty()) throw new IllegalArgumentException("file is required");

        MediaAssetType assetType = parseType(type);

        long maxBytes = maxUploadBytes();
        if (file.getSize() > maxBytes) throw new IllegalArgumentException("file too large");

        String mime = normalizeMime(file.getContentType());
        ensureAllowedMime(assetType, mime);

        String ext = safeExtensionFromMime(mime);
        String uuid = UUID.randomUUID().toString();
        String storageKey = "media/" + uuid + ext;

        Path baseDir = Paths.get(env.getProperty("UPLOAD_DIR", "/app/uploads")).toAbsolutePath().normalize();
        Path target = baseDir.resolve(storageKey).normalize();
        if (!target.startsWith(baseDir)) throw new IllegalStateException("invalid storage path");

        try {
            Files.createDirectories(target.getParent());

            String sha = sha256Hex(file.getInputStream());

            Path tmp = Files.createTempFile(target.getParent(), "upload-", ".tmp");
            Files.copy(file.getInputStream(), tmp, StandardCopyOption.REPLACE_EXISTING);
            Files.move(tmp, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);

            MediaAssetEntity entity = new MediaAssetEntity();
            entity.setType(assetType);
            entity.setStorageKey(storageKey);
            entity.setOriginalFilename(safeOriginalName(file.getOriginalFilename()));
            entity.setMimeType(mime);
            entity.setSizeBytes(file.getSize());
            entity.setChecksumSha256(sha);
            entity.setPublic(isPublic);

            return repo.save(entity);
        } catch (Exception e) {
            throw new RuntimeException("failed to store media", e);
        }
    }

    public Optional<MediaDownload> loadPublic(long id) {
        return repo.findById(id).filter(MediaAssetEntity::isPublic).flatMap(this::loadEntity);
    }

    private Optional<MediaDownload> loadEntity(MediaAssetEntity entity) {
        Path baseDir = Paths.get(env.getProperty("UPLOAD_DIR", "/app/uploads")).toAbsolutePath().normalize();
        Path target = baseDir.resolve(entity.getStorageKey()).normalize();
        if (!target.startsWith(baseDir)) return Optional.empty();
        if (!Files.exists(target) || !Files.isRegularFile(target)) return Optional.empty();
        return Optional.of(new MediaDownload(target, entity.getMimeType(), entity.getSizeBytes()));
    }

    private MediaAssetType parseType(String raw) {
        if (raw == null) throw new IllegalArgumentException("type is required (IMAGE|VIDEO)");
        try { return MediaAssetType.valueOf(raw.trim().toUpperCase(Locale.ROOT)); }
        catch (Exception e) { throw new IllegalArgumentException("invalid type (IMAGE|VIDEO)"); }
    }

    private long maxUploadBytes() {
        String mbRaw = env.getProperty("MAX_UPLOAD_MB", "30").trim();
        long mb = Long.parseLong(mbRaw);
        if (mb < 1) mb = 1;
        return mb * 1024L * 1024L;
    }

    private String normalizeMime(String ct) {
        if (!StringUtils.hasText(ct)) return MediaType.APPLICATION_OCTET_STREAM_VALUE;
        return ct.trim().toLowerCase(Locale.ROOT);
    }

    private void ensureAllowedMime(MediaAssetType type, String mime) {
        Set<String> allowed = allowedMimes(type);
        if (!allowed.contains(mime)) throw new IllegalArgumentException("mime not allowed: " + mime);
    }

    private Set<String> allowedMimes(MediaAssetType type) {
        String raw = (type == MediaAssetType.IMAGE)
            ? env.getProperty("ALLOWED_IMAGE_MIME", "image/jpeg,image/png,image/webp")
            : env.getProperty("ALLOWED_VIDEO_MIME", "video/mp4,video/webm");

        return Arrays.stream(raw.split(","))
            .map(String::trim)
            .filter(s -> !s.isBlank())
            .map(s -> s.toLowerCase(Locale.ROOT))
            .collect(Collectors.toSet());
    }

    private String safeExtensionFromMime(String mime) {
        return switch (mime) {
            case "image/jpeg" -> ".jpg";
            case "image/png" -> ".png";
            case "image/webp" -> ".webp";
            case "video/mp4" -> ".mp4";
            case "video/webm" -> ".webm";
            default -> "";
        };
    }

    private String safeOriginalName(String original) {
        if (original == null) return null;
        String name = original.replace("\\", "/");
        name = name.substring(name.lastIndexOf('/') + 1);
        name = name.replaceAll("[^A-Za-z0-9._-]", "_");
        if (name.length() > 120) name = name.substring(name.length() - 120);
        return name;
    }

    private static String sha256Hex(InputStream in) throws Exception {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] buf = new byte[8192];
        int r;
        while ((r = in.read(buf)) > 0) md.update(buf, 0, r);
        byte[] dig = md.digest();
        StringBuilder sb = new StringBuilder();
        for (byte b : dig) sb.append(String.format("%02x", b));
        return sb.toString();
    }

    public record MediaDownload(Path path, String mimeType, long sizeBytes) {}
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/ServiceEngineConfig.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.serviceengine.DriverRegistry;
import com.atelie.ecommerce.api.serviceengine.ServiceDriver;
import com.atelie.ecommerce.api.serviceengine.ServiceOrchestrator;
import com.atelie.ecommerce.domain.provider.RuleMatcher;
import com.atelie.ecommerce.domain.service.engine.DefaultServiceEngine;
import com.atelie.ecommerce.domain.service.engine.ServiceEngine;
import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.domain.service.port.ServiceRoutingRuleGateway;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class ServiceEngineConfig {

    @Bean
    public RuleMatcher ruleMatcher() {
        return new RuleMatcher();
    }

    @Bean
    public DriverRegistry driverRegistry(List<ServiceDriver> drivers) {
        return new DriverRegistry(drivers);
    }

    @Bean
    public ServiceEngine domainServiceEngine(
            ServiceProviderGateway providerGateway,
            ServiceRoutingRuleGateway routingRuleGateway,
            RuleMatcher ruleMatcher
    ) {
        return new DefaultServiceEngine(providerGateway, routingRuleGateway, ruleMatcher);
    }

    @Bean
    public ServiceOrchestrator serviceOrchestrator(
            ServiceEngine engine,
            ServiceProviderConfigGateway configGateway,
            DriverRegistry driverRegistry
    ) {
        return new ServiceOrchestrator(engine, configGateway, driverRegistry);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/JpaServiceProviderConfigGateway.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.port.ServiceProviderConfigGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderConfigJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderJpaRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class JpaServiceProviderConfigGateway implements ServiceProviderConfigGateway {

    private static final Logger log = LoggerFactory.getLogger(JpaServiceProviderConfigGateway.class);

    private final ServiceProviderJpaRepository providerRepo;
    private final ServiceProviderConfigJpaRepository configRepo;
    private final DynamicConfigService dynamicConfigService;
    private final Clock clock;

    private final Map<String, String> cache = new ConcurrentHashMap<>();
    private LocalDateTime lastUpdate = LocalDateTime.MIN;

    public JpaServiceProviderConfigGateway(
            ServiceProviderJpaRepository providerRepo,
            ServiceProviderConfigJpaRepository configRepo,
            DynamicConfigService dynamicConfigService,
            Clock clock
    ) {
        this.providerRepo = providerRepo;
        this.configRepo = configRepo;
        this.dynamicConfigService = dynamicConfigService;
        this.clock = clock;
    }

    private long ttlSeconds() {
        return dynamicConfigService.getLong(DynamicConfigService.CACHE_TTL_SECONDS_KEY, 300);
    }

    private void checkCache() {
        if (lastUpdate.equals(LocalDateTime.MIN)) return;
        if (LocalDateTime.now(clock).isAfter(lastUpdate.plusSeconds(ttlSeconds()))) {
            refresh();
        }
    }

    @Override
    public Optional<String> findConfigJson(String providerCode, String environment) {
        checkCache();

        String key = providerCode + ":" + environment;
        if (cache.containsKey(key)) return Optional.of(cache.get(key));

        UUID providerId = providerRepo.findByCode(providerCode).map(p -> p.getId()).orElse(null);
        if (providerId == null) return Optional.empty();

        Optional<String> json = configRepo
                .findTopByProviderIdAndEnvironmentOrderByVersionDesc(providerId, environment)
                .map(c -> c.getConfigJson());

        json.ifPresent(j -> cache.put(key, j));
        if (lastUpdate.equals(LocalDateTime.MIN)) lastUpdate = LocalDateTime.now(clock);
        return json;
    }

    @Override
    public void refresh() {
        cache.clear();
        lastUpdate = LocalDateTime.now(clock);
        log.info("ServiceProviderConfig cache cleared.");
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/service/JpaServiceProviderGateway.java ---
package com.atelie.ecommerce.infrastructure.service;

import com.atelie.ecommerce.api.config.DynamicConfigService;
import com.atelie.ecommerce.domain.service.model.ServiceProvider;
import com.atelie.ecommerce.domain.service.model.ServiceType;
import com.atelie.ecommerce.domain.service.port.ServiceProviderGateway;
import com.atelie.ecommerce.infrastructure.persistence.service.jpa.ServiceProviderJpaRepository;
import com.atelie.ecommerce.infrastructure.persistence.service.model.ServiceProviderEntity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Component
public class JpaServiceProviderGateway implements ServiceProviderGateway {

    private static final Logger log = LoggerFactory.getLogger(JpaServiceProviderGateway.class);

    private final ServiceProviderJpaRepository repo;
    private final DynamicConfigService dynamicConfigService;
    private final Clock clock;

    private final Map<String, List<ServiceProvider>> listCache = new ConcurrentHashMap<>();
    private final Map<String, ServiceProvider> codeCache = new ConcurrentHashMap<>();
    private LocalDateTime lastUpdate = LocalDateTime.MIN;

    public JpaServiceProviderGateway(
            ServiceProviderJpaRepository repo,
            DynamicConfigService dynamicConfigService,
            Clock clock
    ) {
        this.repo = repo;
        this.dynamicConfigService = dynamicConfigService;
        this.clock = clock;
    }

    private long ttlSeconds() {
        return dynamicConfigService.getLong(DynamicConfigService.CACHE_TTL_SECONDS_KEY, 300);
    }

    private void checkCache() {
        if (lastUpdate.equals(LocalDateTime.MIN)) return;

        LocalDateTime now = LocalDateTime.now(clock);
        if (now.isAfter(lastUpdate.plusSeconds(ttlSeconds()))) {
            refresh();
        }
    }

    @Override
    public void refresh() {
        listCache.clear();
        codeCache.clear();
        lastUpdate = LocalDateTime.now(clock);
        log.info("ServiceProviderGateway cache cleared.");
    }

    @Override
    public Optional<ServiceProvider> findByCode(ServiceType type, String code) {
        checkCache();

        String key = type.name() + ":" + code;
        if (codeCache.containsKey(key)) return Optional.of(codeCache.get(key));

        var result = repo.findByCode(code)
                .filter(e -> safeTypeEquals(type, e.getServiceType()))
                .map(this::toDomain);

        result.ifPresent(sp -> codeCache.put(key, sp));
        if (lastUpdate.equals(LocalDateTime.MIN)) lastUpdate = LocalDateTime.now(clock);

        return result;
    }

    @Override
    public List<ServiceProvider> findEnabledByTypeOrdered(ServiceType type) {
        checkCache();

        if (listCache.containsKey(type.name())) return listCache.get(type.name());

        var result = repo.findByServiceTypeAndEnabledOrderByPriorityAsc(type.name(), true)
                .stream()
                .map(this::toDomain)
                .collect(Collectors.toList());

        listCache.put(type.name(), result);
        if (lastUpdate.equals(LocalDateTime.MIN)) lastUpdate = LocalDateTime.now(clock);
        return result;
    }

    private ServiceProvider toDomain(ServiceProviderEntity e) {
        return new ServiceProvider(
                e.getId(),
                ServiceType.valueOf(e.getServiceType()),
                e.getCode(),
                e.getName(),
                e.isEnabled(),
                e.getPriority(),
                e.getDriverKey(),
                e.isHealthEnabled()
        );
    }

    private boolean safeTypeEquals(ServiceType expected, String raw) {
        try {
            return expected == ServiceType.valueOf(raw);
        } catch (Exception e) {
            return false;
        }
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/config/ClockConfig.java ---
package com.atelie.ecommerce.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Clock;

@Configuration
public class ClockConfig {

    @Bean
    public Clock systemClock() {
        return Clock.systemUTC();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/config/OpenApiConfig.java ---
package com.atelie.ecommerce.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI ecommerceOpenAPI() {
        return new OpenAPI()
                .info(new Info().title("Ecommerce Core API")
                .description("API 100% Mut√°vel com Service Engine Din√¢mico")
                .version("v1.0"));
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/config/security/SecurityConfig.java ---
package com.atelie.ecommerce.infrastructure.config.security;

import com.atelie.ecommerce.infrastructure.security.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final Environment env;
    private final JwtAuthenticationFilter jwtFilter;

    public SecurityConfig(Environment env, JwtAuthenticationFilter jwtFilter) {
        this.env = env;
        this.jwtFilter = jwtFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/health").permitAll()
                .requestMatchers("/api/files/view/**").permitAll()

                // üîê ADMIN ONLY
                .requestMatchers("/api/admin/**").hasRole("ADMIN")

                // üîê resto exige login
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public UrlBasedCorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();

        String appEnv = env.getProperty("APP_ENV", "dev");
        String raw = env.getProperty("CORS_ALLOWED_ORIGINS", "").trim();

        config.addAllowedHeader("*");
        config.addAllowedMethod("*");

        if ("dev".equalsIgnoreCase(appEnv)) {
            config.setAllowCredentials(false);
            config.setAllowedOriginPatterns(List.of("*"));
        } else {
            if (raw.isBlank() || "*".equals(raw)) {
                throw new IllegalStateException("CORS_ALLOWED_ORIGINS must be explicitly defined in production");
            }

            config.setAllowCredentials(true);
            List<String> origins = Arrays.stream(raw.split(","))
                .map(String::trim)
                .filter(s -> !s.isBlank())
                .collect(Collectors.toList());

            origins.forEach(config::addAllowedOrigin);
        }

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/config/AsyncConfig.java ---
package com.atelie.ecommerce.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync // <--- Agora o @Async do listener funciona de verdade
public class AsyncConfig {
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/http/RestTemplateConfig.java ---
package com.atelie.ecommerce.infrastructure.http;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
import java.time.Duration;

@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .setConnectTimeout(Duration.ofSeconds(5)) // 5s para conectar
                .setReadTimeout(Duration.ofSeconds(10))   // 10s para receber dados
                .build();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/PasswordConfig.java ---
package com.atelie.ecommerce.infrastructure.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/AuthenticationConfig.java ---
package com.atelie.ecommerce.infrastructure.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class AuthenticationConfig {

    @Bean
    public AuthenticationProvider authenticationProvider(
            UserDetailsService userDetailsService,
            PasswordEncoder passwordEncoder
    ) {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder);
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/TokenProvider.java ---
package com.atelie.ecommerce.infrastructure.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import java.security.Key;
import java.util.Date;
import java.util.List;
import java.util.function.Function;

@Component
public class TokenProvider {

    @Value("${JWT_SECRET}")
    private String secret;

    // ENV: JWT_EXPIRATION_MS (ex: 86400000)
    @Value("${JWT_EXPIRATION_MS}")
    private long expirationMs;

    // ENV: JWT_ROLES_CLAIM (default "roles")
    @Value("${JWT_ROLES_CLAIM:roles}")
    private String rolesClaim;

    private Key key;

    @PostConstruct
    public void init() {
        byte[] keyBytes = io.jsonwebtoken.io.Decoders.BASE64.decode(secret);
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateToken(Authentication authentication) {
        UserDetails userPrincipal = (UserDetails) authentication.getPrincipal();

        List<String> roles = authentication.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        return Jwts.builder()
            .setSubject(userPrincipal.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expirationMs))
            .claim(rolesClaim, roles)
            .signWith(key, SignatureAlgorithm.HS256)
            .compact();
    }

    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }

    public List<String> getRolesFromToken(String token) {
        Claims claims = getAllClaims(token);
        Object raw = claims.get(rolesClaim);

        if (raw == null) return List.of();

        if (raw instanceof List<?>) {
            return ((List<?>) raw).stream().map(String::valueOf).toList();
        }

        // fallback seguro (se vier string √∫nica)
        return List.of(String.valueOf(raw));
    }

    public boolean validateTokenBasic(String token) {
        // parse valida assinatura; expira√ß√£o validamos abaixo
        getAllClaims(token);
        return !isTokenExpired(token);
    }

    public boolean validateTokenWithUserDetails(String token, UserDetails userDetails) {
        final String username = getUsernameFromToken(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    private Claims getAllClaims(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(key)
            .build()
            .parseClaimsJws(token)
            .getBody();
    }

    private <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private boolean isTokenExpired(String token) {
        final Date expiration = getClaimFromToken(token, Claims::getExpiration);
        return expiration.before(new Date());
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/CustomUserDetailsService.java ---
package com.atelie.ecommerce.infrastructure.security;

import com.atelie.ecommerce.infrastructure.persistence.auth.UserRepository;
import com.atelie.ecommerce.infrastructure.persistence.auth.entity.UserEntity;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        UserEntity user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));

        // CORRE√á√ÉO: Converte a role do banco (ex: "ADMIN") para Authority ("ROLE_ADMIN")
        String roleName = user.getRole() == null ? "USER" : user.getRole().toUpperCase();
        if (!roleName.startsWith("ROLE_")) {
            roleName = "ROLE_" + roleName;
        }

        return new User(
            user.getEmail(), 
            user.getPassword(), 
            List.of(new SimpleGrantedAuthority(roleName))
        );
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/infrastructure/security/JwtAuthenticationFilter.java ---
package com.atelie.ecommerce.infrastructure.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.core.env.Environment;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final TokenProvider tokenProvider;
    private final CustomUserDetailsService userDetailsService;
    private final Environment env;

    public JwtAuthenticationFilter(TokenProvider tokenProvider,
                                   CustomUserDetailsService userDetailsService,
                                   Environment env) {
        this.tokenProvider = tokenProvider;
        this.userDetailsService = userDetailsService;
        this.env = env;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {

        String header = request.getHeader("Authorization");
        if (header == null || !header.startsWith("Bearer ")) {
            chain.doFilter(request, response);
            return;
        }

        String token = header.substring(7);

        String username;
        try {
            username = tokenProvider.getUsernameFromToken(token);
        } catch (Exception e) {
            logger.error("Invalid JWT (cannot extract subject)", e);
            chain.doFilter(request, response);
            return;
        }

        if (username == null || SecurityContextHolder.getContext().getAuthentication() != null) {
            chain.doFilter(request, response);
            return;
        }

        boolean useClaimRoles = Boolean.parseBoolean(env.getProperty("JWT_USE_CLAIM_ROLES", "true"));

        try {
            if (useClaimRoles) {
                List<String> roles = tokenProvider.getRolesFromToken(token);

                // S√≥ aplica stateless se o token realmente tiver roles
                if (!roles.isEmpty() && tokenProvider.validateTokenBasic(token)) {
                    var authorities = roles.stream()
                        .map(SimpleGrantedAuthority::new)
                        .toList();

                    UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(username, null, authorities);

                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authToken);

                    chain.doFilter(request, response);
                    return;
                }
            }

            // Fallback: modo antigo (depende de UserDetails/DB)
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            if (tokenProvider.validateTokenWithUserDetails(token, userDetails)) {
                UsernamePasswordAuthenticationToken authToken =
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }

        } catch (Exception e) {
            logger.error("JWT validation failed", e);
        }

        chain.doFilter(request, response);
    }
}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/catalog/event/ProductSavedEvent.java ---
package com.atelie.ecommerce.domain.catalog.event;

import java.util.UUID;

/**
 * Evento de dom√≠nio emitido quando um produto √© salvo/criado.
 *
 * Esse evento √© usado para disparar integra√ß√µes ass√≠ncronas (ex.: sync multicanal),
 * sem acoplar o core a um provider espec√≠fico.
 */
public record ProductSavedEvent(
        UUID productId,
        boolean isNew
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/engine/ServiceContext.java ---
package com.atelie.ecommerce.domain.service.engine;

import java.math.BigDecimal;
import java.util.Map;

public record ServiceContext(
        String country,
        BigDecimal orderTotal,
        Map<String, Object> attributes
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/engine/ResolvedProvider.java ---
package com.atelie.ecommerce.domain.service.engine;

import com.atelie.ecommerce.domain.service.model.ServiceProvider;

public record ResolvedProvider(
        ServiceProvider provider,
        String reason
) {}

--- ARQUIVO: ./src/main/java/com/atelie/ecommerce/domain/service/engine/ServiceEngine.java ---
package com.atelie.ecommerce.domain.service.engine;

import com.atelie.ecommerce.domain.service.model.ServiceType;

/**
 * Interface Core para Motores de Servi√ßo.
 * Define o contrato para resolu√ß√£o de provedores baseado em regras.
 */
public interface ServiceEngine {
    
    /**
     * Resolve qual provedor deve processar a requisi√ß√£o baseada no contexto.
     *
     * @param type Tipo do servi√ßo (ex: PAYMENT, SHIPPING)
     * @param ctx Contexto da execu√ß√£o (dados vari√°veis)
     * @return O provedor resolvido e a estrat√©gia utilizada
     */
    ResolvedProvider resolve(ServiceType type, ServiceContext ctx);
}
